<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Hướng dẫn SQL từ A-Z</title>
    <style>
      :root {
        --indigo: #667eea;
        --purple: #764ba2;
      }
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      html {
        scroll-behavior: smooth;
      }
      body {
        font-family: "Segoe UI", Tahoma, sans-serif;
        background: linear-gradient(135deg, var(--indigo), var(--purple));
        min-height: 100vh;
        color: #1f2937;
        line-height: 1.6;
      }
      .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
      }
      .header {
        background: rgba(255, 255, 255, 0.12);
        backdrop-filter: blur(10px);
        border-radius: 16px;
        padding: 16px 24px;
        margin-bottom: 24px;
        border: 1px solid rgba(255, 255, 255, 0.25);
        color: #fff;
      }
      .course-line {
        display: flex;
        gap: 18px;
        align-items: center;
        flex-wrap: wrap;
      }
      .course-code {
        color: #ffd700;
        font-weight: 800;
        font-size: 22px;
      }
      .author {
        opacity: 0.9;
        font-size: 14px;
      }
      .fb-link a {
        color: #ffd700;
        font-weight: 700;
        text-decoration: none;
      }
      .fb-link a:hover {
        text-decoration: underline;
      }
      .main-container {
        display: flex;
        gap: 20px;
        align-items: flex-start;
      }
      .sidebar {
        width: 320px;
        background: #fff;
        border-radius: 14px;
        padding: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
        max-height: 80vh;
        overflow-y: auto;
        position: sticky;
        top: 20px;
      }
      .sidebar h3 {
        color: var(--indigo);
        font-size: 18px;
        margin-bottom: 10px;
        text-align: center;
      }
      .tabs {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 12px;
      }
      .tab-btn {
        background: linear-gradient(135deg, #f8f9ff, #e8f2ff);
        border: 1px solid #e6e9ff;
        color: var(--purple);
        font-size: 14px;
        padding: 10px;
        border-radius: 8px;
        cursor: pointer;
        transition: 0.2s;
        font-weight: 700;
      }
      .tab-btn.active,
      .tab-btn:hover {
        background: linear-gradient(135deg, var(--indigo), var(--purple));
        color: #fff;
      }
      .tab-content {
        display: none;
      }
      .tab-content.active {
        display: block;
      }
      .toc-item {
        padding: 8px 10px;
        cursor: pointer;
        color: #374151;
        border-radius: 8px;
        transition: 0.15s;
        font-size: 14px;
        margin: 2px 0;
      }
      .toc-item:hover,
      .toc-item.active {
        background: rgba(102, 126, 234, 0.15);
        color: var(--indigo);
        padding-left: 14px;
        font-weight: 700;
      }
      .content-area {
        flex: 1;
        background: #fff;
        border-radius: 16px;
        padding: 28px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.08);
        max-height: 80vh;
        overflow-y: auto;
      }
      .search-box {
        width: 100%;
        padding: 12px 14px;
        margin-bottom: 16px;
        border: 2px solid var(--indigo);
        border-radius: 10px;
        font-size: 16px;
      }
      .section {
        display: none;
        animation: fadeIn 0.35s ease-in;
      }
      .section.active {
        display: block;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(8px);
        }
        to {
          opacity: 1;
          transform: none;
        }
      }
      .section h2 {
        color: var(--indigo);
        font-size: 26px;
        margin: 0 0 16px 0;
        padding-bottom: 10px;
        border-bottom: 3px solid var(--indigo);
      }
      .section h3 {
        color: var(--purple);
        font-size: 18px;
        margin: 20px 0 10px;
        padding: 10px;
        background: linear-gradient(135deg, #f8f9ff, #e8f2ff);
        border-left: 5px solid var(--indigo);
        border-radius: 8px;
      }
      .code-block {
        background: #f8f9fa;
        color: #2d3748;
        padding: 20px;
        border-radius: 12px;
        font-family: "Consolas", "Monaco", "Courier New", monospace;
        font-size: 14px;
        line-height: 1.8;
        overflow-x: auto;
        position: relative;
        margin: 15px 0;
        border: 1px solid #e2e8f0;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
        white-space: pre-line;
      }
      .code-block::before {
        content: "SQL";
        position: absolute;
        top: 8px;
        right: 12px;
        background: linear-gradient(135deg, var(--indigo), var(--purple));
        color: #fff;
        border-radius: 6px;
        font-size: 12px;
        padding: 4px 8px;
        font-weight: 600;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      /* Enhanced SQL Syntax Highlighting */
      .code-block .keyword {
        color: #0066cc;
        font-weight: bold;
      }
      .code-block .string {
        color: #22863a;
        font-weight: 500;
      }
      .code-block .number {
        color: #e36209;
        font-weight: 500;
      }
      .code-block .comment {
        color: #6a737d;
        font-style: italic;
        opacity: 0.8;
        font-size: 13px;
      }
      .code-block .function {
        color: #6f42c1;
        font-weight: 600;
      }
      .code-block .datatype {
        color: #d73a49;
        font-weight: 600;
      }
      .code-block .operator {
        color: #005cc5;
        font-weight: 500;
      }
      .code-block .table {
        color: #032f62;
        font-weight: 500;
      }
      .code-block .column {
        color: #24292e;
      }

      /* Legacy classes for compatibility */
      .sql-keyword {
        color: #0066cc;
        font-weight: bold;
      }
      .sql-string {
        color: #22863a;
      }
      .sql-comment {
        color: #6a737d;
        font-style: italic;
      }
      .sql-number {
        color: #e36209;
      }
      .sql-function {
      .sql-function {
        color: #800080;
        font-weight: bold;
      }
      .sql-operator {
        color: #ff0000;
        font-weight: bold;
      }
      .example,
      .info-box,
      .success-box,
      .highlight-box,
      .note {
        border-radius: 10px;
        padding: 14px;
        margin: 12px 0;
      }
      .example {
        background: #f7fafc;
        border-left: 4px solid #4299e1;
      }
      .info-box {
        background: linear-gradient(135deg, #ebf8ff, #bee3f8);
        border-left: 4px solid #3182ce;
      }
      .success-box {
        background: linear-gradient(135deg, #f0fff4, #c6f6d5);
        border-left: 4px solid #38a169;
      }
      .highlight-box {
        background: linear-gradient(135deg, #fff5f5, #fed7d7);
        border-left: 4px solid #e53e3e;
      }
      .note {
        background: #fffbeb;
        border-left: 4px solid #f6ad55;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
        background: #fff;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);
        border: 1px solid #e2e8f0;
      }

      thead {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      }

      th {
        padding: 16px 20px;
        text-align: left;
        color: #fff;
        font-weight: 600;
        font-size: 14px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        border-bottom: none;
        position: relative;
      }

      th:not(:last-child)::after {
        content: '';
        position: absolute;
        right: 0;
        top: 25%;
        height: 50%;
        width: 1px;
        background: rgba(255, 255, 255, 0.2);
      }

      td {
        padding: 14px 20px;
        text-align: left;
        border-bottom: 1px solid #f1f5f9;
        color: #334155;
        font-size: 14px;
        line-height: 1.5;
        vertical-align: top;
      }

      tbody tr {
        transition: all 0.2s ease;
      }

      tbody tr:hover {
        background: linear-gradient(135deg, #f8fafc, #f1f5f9);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
      }

      tbody tr:nth-child(even) {
        background: #f8fafc;
      }

      tbody tr:nth-child(even):hover {
        background: linear-gradient(135deg, #f1f5f9, #e2e8f0);
      }

      tbody tr:last-child td {
        border-bottom: none;
      }

      /* Table content styling */
      table td b {
        color: #1e293b;
        font-weight: 600;
      }

      table td code {
        background: #f1f5f9;
        color: #e11d48;
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 13px;
        font-family: "Consolas", "Monaco", monospace;
      }

      /* Special table types */
      .datatype-table {
        margin: 25px 0;
      }

      .datatype-table th {
        background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
        font-size: 13px;
      }

      .comparison-table {
        margin: 25px 0;
      }

      .comparison-table th {
        background: linear-gradient(135deg, #059669 0%, #0d9488 100%);
        font-size: 13px;
      }

      .features-table {
        margin: 25px 0;
      }

      .features-table th {
        background: linear-gradient(135deg, #dc2626 0%, #ea580c 100%);
        font-size: 13px;
      }

      /* Status indicators in tables */
      .status-yes {
        color: #059669;
        font-weight: 600;
      }

      .status-no {
        color: #dc2626;
        font-weight: 600;
      }

      .status-partial {
        color: #d97706;
        font-weight: 600;
      }

      /* Table badges */
      .table-badge {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .badge-high {
        background: #dcfce7;
        color: #166534;
      }

      .badge-medium {
        background: #fef3c7;
        color: #92400e;
      }

      .badge-low {
        background: #fee2e2;
        color: #991b1b;
      }

      .badge-feature {
        background: #e0e7ff;
        color: #3730a3;
      }
      .back-to-top {
        position: fixed;
        bottom: 24px;
        right: 24px;
        background: var(--indigo);
        color: #fff;
        border: none;
        border-radius: 50%;
        width: 48px;
        height: 48px;
        cursor: pointer;
        font-size: 18px;
        display: none;
      }
      .back-to-top:hover {
        background: var(--purple);
      }
      @media (max-width: 1024px) {
        .main-container {
          flex-direction: column;
        }
        .sidebar {
          width: 100%;
          position: relative;
          max-height: none;
        }
        .content-area {
          max-height: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <div class="fb-link">
          📘 Facebook:
          <a
            href="https://www.facebook.com/vu.hoang.79219"
            target="_blank"
            rel="noopener"
            >Hoàng Hoàng</a
          >
        </div>
        <div class="course-line">
          <div class="course-code">DBI202</div>
          <div class="author">Tác giả: HOÀNG HOÀNG</div>
        </div>
      </div>

      <div class="main-container">
        <!-- Sidebar -->
        <aside class="sidebar">
          <h3>🔍 Mục Lục</h3>
          <div class="tabs">
            <button class="tab-btn active" data-tab="basic">
              PHẦN I: CƠ BẢN
            </button>
            <button class="tab-btn" data-tab="constraints">
              PHẦN II: CONSTRAINTS & INDEX
            </button>
            <button class="tab-btn" data-tab="basic-sql">
              PHẦN III: SQL CƠ BẢN
            </button>
            <button class="tab-btn" data-tab="advanced">
              PHẦN IV: NÂNG CAO
            </button>
            <button class="tab-btn" data-tab="expert">
              PHẦN V: CẤU TRÚC NÂNG CAO
            </button>
            <button class="tab-btn" data-tab="videos">🎬 VIDEO TRICKS</button>
          </div>

          <div class="tab-content active" id="basic">
            <div class="toc-item" data-target="datatype">1. Datatype</div>
            <div class="toc-item" data-target="char-varchar">
              2. CHAR vs VARCHAR
            </div>
            <div class="toc-item" data-target="conversion">
              3. Chuyển đổi kiểu
            </div>
            <div class="toc-item" data-target="truncate-drop-delete">
              4. TRUNCATE vs DROP vs DELETE
            </div>
            <div class="toc-item" data-target="identity-sequence">
              5. Identity vs Sequence
            </div>
          </div>

          <div class="tab-content" id="constraints">
            <div class="toc-item" data-target="constraint">6. Constraint</div>
            <div class="toc-item" data-target="constraint-ways">
              7. Cách tạo constraint
            </div>
            <div class="toc-item" data-target="unique-pk">8. Unique vs PK</div>
            <div class="toc-item" data-target="index">9. Index</div>
          </div>

          <div class="tab-content" id="basic-sql">
            <div class="toc-item" data-target="sql-order">
              10. Thứ tự thực thi SQL
            </div>
            <div class="toc-item" data-target="where-having">
              11. WHERE vs HAVING
            </div>
            <div class="toc-item" data-target="union-merge">
              12. UNION, MERGE, PIVOT, INTERSECT
            </div>
            <div class="toc-item" data-target="relationship">
              13. Relationship & Chuẩn hóa
            </div>
            <div class="toc-item" data-target="group-by">14. GROUP BY</div>
            <div class="toc-item" data-target="functions">15. Các function</div>
          </div>

          <div class="tab-content" id="advanced">
            <div class="toc-item" data-target="join">16. JOIN</div>
            <div class="toc-item" data-target="view">17. VIEW</div>
            <div class="toc-item" data-target="subquery">18. SUBQUERY</div>
            <div class="toc-item" data-target="ranking">
              19. Ranking / Window
            </div>
            <div class="toc-item" data-target="cte">20. CTE</div>
          </div>

          <div class="tab-content" id="expert">
            <div class="toc-item" data-target="conditions">
              21. Lệnh điều khiển
            </div>
            <div class="toc-item" data-target="udf">22. UDF</div>
            <div class="toc-item" data-target="sp">23. Stored Procedure</div>
            <div class="toc-item" data-target="exception">24. Exception</div>
            <div class="toc-item" data-target="transaction">
              25. Transaction
            </div>
            <div class="toc-item" data-target="trigger">26. Trigger</div>
            <div class="toc-item" data-target="acid">27. ACID</div>
          </div>

          <div class="tab-content" id="videos">
            <div class="toc-item" data-target="video-tricks">
              🎬 Mẹo & Video
            </div>
          </div>
        </aside>

        <!-- Content -->
        <main class="content-area">
          <input
            type="text"
            class="search-box"
            placeholder="🔍 Tìm kiếm..."
            id="searchBox"
          />

          <!-- 1 -->
          <section class="section active" id="datatype">
            <h2>📊 DATATYPE CỦA SQL - HƯỚNG DẪN CHI TIẾT</h2>

            <h3>� 1. KIỂU SỐ (NUMERIC TYPES)</h3>

            <h3>Số nguyên (Integer Types)</h3>
            <table class="datatype-table">
              <thead>
                <tr>
                  <th>Kiểu dữ liệu</th>
                  <th>Phạm vi giá trị</th>
                  <th>Kích thước</th>
                  <th>Khi nào sử dụng</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>TINYINT</b></td>
                  <td>0 đến 255</td>
                  <td><span class="table-badge badge-high">1 byte</span></td>
                  <td>Tuổi, tháng, trạng thái</td>
                </tr>
                <tr>
                  <td><b>SMALLINT</b></td>
                  <td>-32,768 đến 32,767</td>
                  <td><span class="table-badge badge-high">2 bytes</span></td>
                  <td>Số lượng nhỏ, năm</td>
                </tr>
                <tr>
                  <td><b>INT</b></td>
                  <td>-2,147,483,648 đến 2,147,483,647</td>
                  <td><span class="table-badge badge-medium">4 bytes</span></td>
                  <td>ID, số lượng thông thường</td>
                </tr>
                <tr>
                  <td><b>BIGINT</b></td>
                  <td>
                    -9,223,372,036,854,775,808 đến 9,223,372,036,854,775,807
                  </td>
                  <td><span class="table-badge badge-low">8 bytes</span></td>
                  <td>ID lớn, timestamp</td>
                </tr>
              </tbody>
            </table>

            <div class="example">
              <h4>Ví dụ thực tế:</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">SanPham</span> (
                  <span class="column">ID</span> <span class="datatype">INT</span>,
                  <span class="column">SoLuongTon</span> <span class="datatype">SMALLINT</span>,
                  <span class="column">TrangThai</span> <span class="datatype">TINYINT</span>,
                  <span class="column">ViewCount</span> <span class="datatype">BIGINT</span>
                );

                <span class="keyword">INSERT INTO</span> <span class="table">SanPham</span>
                <span class="keyword">VALUES</span> (<span class="number">1001</span>, <span class="number">150</span>, <span class="number">1</span>, <span class="number">2500000</span>);
              </div>
            </div>

            <h3>💰 Số thập phân (Decimal Types)</h3>
            <table class="datatype-table">
              <thead>
                <tr>
                  <th>Kiểu dữ liệu</th>
                  <th>Mô tả</th>
                  <th>Độ chính xác</th>
                  <th>Sử dụng</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>DECIMAL(p,s)</b></td>
                  <td>Số thập phân chính xác</td>
                  <td><span class="status-yes">Cao</span></td>
                  <td>Tiền tệ, tỷ lệ chính xác</td>
                </tr>
                <tr>
                  <td><b>NUMERIC(p,s)</b></td>
                  <td>Giống DECIMAL</td>
                  <td><span class="status-yes">Cao</span></td>
                  <td>Tính toán tài chính</td>
                </tr>
                <tr>
                  <td><b>FLOAT</b></td>
                  <td>Số thực dấu phẩy động</td>
                  <td><span class="status-no">Thấp</span></td>
                  <td>Tính toán khoa học</td>
                </tr>
                <tr>
                  <td><b>REAL</b></td>
                  <td>Số thực độ chính xác đơn</td>
                  <td><span class="status-partial">Trung bình</span></td>
                  <td>Tọa độ, measurement</td>
                </tr>
              </tbody>
            </table>

            <div class="example">
              <h4>Ví dụ chi tiết:</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">DonHang</span> (
                  <span class="column">ID</span> <span class="datatype">INT</span>,
                  <span class="column">Gia</span> <span class="datatype">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),
                  <span class="column">ThueVAT</span> <span class="datatype">DECIMAL</span>(<span class="number">5</span>,<span class="number">4</span>),
                  <span class="column">KhoiLuong</span> <span class="datatype">FLOAT</span>,
                  <span class="column">TyLeGiamGia</span> <span class="datatype">REAL</span>
                );

                <span class="keyword">INSERT INTO</span> <span class="table">DonHang</span>
                <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1299000.50</span>, <span class="number">0.1000</span>, <span class="number">2.756891</span>, <span class="number">0.15</span>), 
                       (<span class="number">2</span>, <span class="number">850000.00</span>, <span class="number">0.0800</span>, <span class="number">1.234567</span>, <span class="number">0.20</span>);

                <span class="keyword">SELECT</span>
                <span class="column">ID</span>, <span class="column">Gia</span>,
                <span class="column">Gia</span> <span class="operator">*</span>
                <span class="column">ThueVAT</span>
                <span class="keyword">AS</span>
                <span class="column">TienThue</span>,
                <span class="column">Gia</span>
                <span class="operator">*</span> (<span class="number">1</span>
                <span class="operator">+</span>
                <span class="column">ThueVAT</span>)
                <span class="keyword">AS</span>
                <span class="column">GiaSauThue</span>
                <span class="keyword">FROM</span>
                <span class="table">DonHang</span>;
              </div>
            </div>

            <div class="highlight-box">
              <h4>⚠️ Lưu ý về FLOAT vs DECIMAL:</h4>
              <div class="code-block">
                <span class="comment">-- FLOAT có thể mất độ chính xác</span>
                <span class="keyword">SELECT</span> <span class="number">0.1</span> <span class="operator">+</span> <span class="number">0.2</span> <span class="keyword">AS</span> <span class="column">FloatResult</span>,       <span class="comment">-- Kết quả: 0.30000000000000004</span>
                       <span class="function">CAST</span>(<span class="number">0.1</span> <span class="keyword">AS</span> <span class="datatype">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>)) <span class="operator">+</span> <span class="function">CAST</span>(<span class="number">0.2</span> <span class="keyword">AS</span> <span class="datatype">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>)) <span class="keyword">AS</span> <span class="column">DecimalResult</span> <span class="comment">-- Kết quả: 0.30</span>
                <span class="comment">-- Vì vậy với tiền tệ luôn dùng DECIMAL!</span>
              </div>
            </div>

            <h3>📝 2. KIỂU CHUỖI (STRING TYPES)</h3>
            <table class="comparison-table">
              <thead>
                <tr>
                  <th>Kiểu</th>
                  <th>Đặc điểm</th>
                  <th>Kích thước</th>
                  <th>Sử dụng</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>CHAR(n)</b></td>
                  <td>Độ dài cố định</td>
                  <td><span class="table-badge badge-low">n bytes</span></td>
                  <td>Mã code cố định</td>
                </tr>
                <tr>
                  <td><b>VARCHAR(n)</b></td>
                  <td>Độ dài thay đổi</td>
                  <td>
                    <span class="table-badge badge-high"
                      >Thực tế + 2 bytes</span
                    >
                  </td>
                  <td>Tên, mô tả</td>
                </tr>
                <tr>
                  <td><b>TEXT</b></td>
                  <td>Văn bản dài</td>
                  <td>Rất lớn</td>
                  <td>Nội dung, mô tả chi tiết</td>
                </tr>
                <tr>
                  <td><b>NCHAR(n)</b></td>
                  <td>Unicode cố định</td>
                  <td>n * 2 bytes</td>
                  <td>Đa ngôn ngữ</td>
                </tr>
                <tr>
                  <td><b>NVARCHAR(n)</b></td>
                  <td>Unicode thay đổi</td>
                  <td>Thực tế * 2 + 2 bytes</td>
                  <td>Tên tiếng Việt</td>
                </tr>
              </tbody>
            </table>

            <div class="example">
              <h4>Ví dụ so sánh CHAR vs VARCHAR:</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">Demo</span> (
                  <span class="column">MaKH</span> <span class="datatype">CHAR</span>(<span class="number">10</span>), 
                  <span class="column">TenKH</span> <span class="datatype">VARCHAR</span>(<span class="number">50</span>), 
                  <span class="column">GhiChu</span> <span class="datatype">TEXT</span>
                );

                <span class="keyword">INSERT INTO</span> <span class="table">Demo</span>
                <span class="keyword">VALUES</span> (<span class="string">'KH001'</span>, <span class="string">'Nguyễn Văn An'</span>, <span class="string">'Khách hàng VIP từ năm 2020'</span>),
                       (<span class="string">'KH002'</span>, <span class="string">'Trần Thị Bình'</span>, <span class="string">'Khách hàng thường xuyên mua hàng'</span>);

                <span class="keyword">SELECT</span> <span class="column">MaKH</span>,
                <span class="function">LEN</span>(<span class="column"
                  >MaKH</span
                >) <span class="keyword">AS</span>
                <span class="column">DoDaiMaKH</span>,
                <span class="column">TenKH</span>,
                <span class="function">LEN</span>(<span class="column"
                  >TenKH</span
                >) <span class="keyword">AS</span>
                <span class="column">DoDaiTenKH</span>
                <span class="keyword">FROM</span>
                <span class="table">Demo</span>;
              </div>
            </div>

            <div class="info-box">
              <h4>🌏 Unicode cho tiếng Việt:</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">KhachHang</span> (
                  <span class="column">ID</span> <span class="datatype">INT</span>,
                  <span class="column">TenKH</span> <span class="datatype">NVARCHAR</span>(<span class="number">100</span>), 
                  <span class="column">DiaChi</span> <span class="datatype">NVARCHAR</span>(<span class="number">200</span>), 
                  <span class="column">GhiChu</span> <span class="datatype">NTEXT</span>
                );
                );

                <span class="keyword">INSERT INTO</span>
                <span class="table">KhachHang</span>
                <span class="keyword">VALUES</span> (<span class="number"
                  >1</span
                >, <span class="string">N'Nguyễn Văn Ánh'</span>,
                <span class="string">N'123 Đường Lê Lợi, Quận 1, TP.HCM'</span>,
                <span class="string">N'Khách hàng có uy tín cao'</span>);
              </div>
            </div>

            <h3>📅 3. KIỂU NGÀY THÁNG (DATE/TIME TYPES)</h3>
            <table class="datatype-table">
              <thead>
                <tr>
                  <th>Kiểu</th>
                  <th>Phạm vi</th>
                  <th>Định dạng</th>
                  <th>Độ chính xác</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>DATE</b></td>
                  <td>0001-01-01 đến 9999-12-31</td>
                  <td><code>YYYY-MM-DD</code></td>
                  <td><span class="table-badge badge-feature">Ngày</span></td>
                </tr>
                <tr>
                  <td><b>TIME</b></td>
                  <td>00:00:00.0000000 đến 23:59:59.9999999</td>
                  <td><code>HH:MM:SS</code></td>
                  <td>
                    <span class="table-badge badge-feature">Thời gian</span>
                  </td>
                </tr>
                <tr>
                  <td><b>DATETIME</b></td>
                  <td>1753-01-01 đến 9999-12-31</td>
                  <td>YYYY-MM-DD HH:MM:SS</td>
                  <td>3.33ms</td>
                </tr>
                <tr>
                  <td><b>DATETIME2</b></td>
                  <td>0001-01-01 đến 9999-12-31</td>
                  <td>YYYY-MM-DD HH:MM:SS.nnnnnnn</td>
                  <td>100ns</td>
                </tr>
                <tr>
                  <td><b>TIMESTAMP</b></td>
                  <td>1970-01-01 đến 2038-01-19</td>
                  <td>Unix timestamp</td>
                  <td>1 giây</td>
                </tr>
              </tbody>
            </table>

            <div class="example">
              <h4>Ví dụ thực tế:</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">LichSuGiaoDich</span> (
                    <span class="column">ID</span> <span class="datatype">INT</span>,
                    <span class="column">NgayGiaoDich</span> <span class="datatype">DATE</span>,
                    <span class="column">GioGiaoDich</span> <span class="datatype">TIME</span>,
                    <span class="column">ThoiDiemDayDu</span> <span class="datatype">DATETIME2</span>
                );

                <span class="keyword">INSERT INTO</span> <span class="table">LichSuGiaoDich</span> 
                <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'2023-12-01'</span>, <span class="string">'14:30:00'</span>, <span class="string">'2023-12-01 14:30:25'</span>);
              </div>
            </div>

            <div class="success-box">
              <h4>🕒 Ví dụ tính toán thời gian:</h4>
              <div class="code-block">
                <span class="keyword">SELECT</span>
                <span class="function">GETDATE</span>()
                <span class="keyword">AS</span>
                <span class="column">HienTai</span>,
                <span class="function">DATEADD</span>(<span class="keyword"
                  >DAY</span
                >, <span class="number">7</span>,
                <span class="function">GETDATE</span>())
                <span class="keyword">AS</span>
                <span class="column">Sau7Ngay</span>,
                <span class="function">DATEADD</span>(<span class="keyword"
                  >MONTH</span
                >, <span class="number">-3</span>,
                <span class="function">GETDATE</span>())
                <span class="keyword">AS</span>
                <span class="column">Truoc3Thang</span>,
                <span class="function">DATEADD</span>(<span class="keyword"
                  >YEAR</span
                >, <span class="number">1</span>,
                <span class="function">GETDATE</span>())
                <span class="keyword">AS</span>
                <span class="column">SangNam</span>;

                <span class="keyword">SELECT</span>
                <span class="function">CONVERT</span>(<span class="datatype"
                  >VARCHAR</span
                >(<span class="number">10</span>),
                <span class="function">GETDATE</span>(),
                <span class="number">103</span>)
                <span class="keyword">AS</span>
                <span class="column">DD_MM_YYYY</span>,
                <span class="function">CONVERT</span>(<span class="datatype"
                  >VARCHAR</span
                >(<span class="number">10</span>),
                <span class="function">GETDATE</span>(),
                <span class="number">101</span>)
                <span class="keyword">AS</span>
                <span class="column">MM_DD_YYYY</span>; as MM_DD_YYYY, --
                12/01/2023 FORMAT(GETDATE(), 'dd/MM/yyyy') as DinhDangVN; --
                01/12/2023
              </div>
            </div>

            <h3>✅ 4. KIỂU BOOLEAN VÀ BINARY</h3>
            <div class="example">
              <h4>🔧 Kiểu Boolean (BIT):</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">CauHinh</span> (
                    <span class="column">ID</span> <span class="datatype">INT</span>,
                    <span class="column">TenCauHinh</span> <span class="datatype">VARCHAR</span>(<span class="number">50</span>),
                    <span class="column">GiaTriBoolean</span> <span class="datatype">BIT</span>, <span class="comment">-- 0 = False, 1 = True</span>
                    <span class="column">MoTa</span> <span class="datatype">VARCHAR</span>(<span class="number">100</span>)
                );
                
                <span class="keyword">INSERT INTO</span> <span class="table">CauHinh</span> 
                <span class="keyword">VALUES</span> 
                    (<span class="number">1</span>, <span class="string">'AllowRegistration'</span>, <span class="number">1</span>, <span class="string">'Cho phép đăng ký mới'</span>),
                    (<span class="number">2</span>, <span class="string">'MaintenanceMode'</span>, <span class="number">0</span>, <span class="string">'Chế độ bảo trì'</span>),
                    (<span class="number">3</span>, <span class="string">'EnableNotification'</span>, <span class="number">1</span>, <span class="string">'Bật thông báo'</span>);
                       
                <span class="comment">-- Sử dụng</span>
                <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="table">CauHinh</span> 
                <span class="keyword">WHERE</span> <span class="column">GiaTriBoolean</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- Lấy các cấu hình đang bật</span>
              </div>
            </div>

            <div class="example">
              <h4>💾 Kiểu Binary:</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">TapTin</span> (
                    <span class="column">ID</span> <span class="datatype">INT</span>,
                    <span class="column">TenFile</span> <span class="datatype">VARCHAR</span>(<span class="number">100</span>),
                    <span class="column">NoiDung</span> <span class="datatype">VARBINARY</span>(<span class="keyword">MAX</span>),
                    <span class="column">KichThuoc</span> <span class="datatype">INT</span>
                );
                
                <span class="keyword">INSERT INTO</span> <span class="table">TapTin</span> 
                <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'logo.png'</span>, <span class="string">0x89504E470D0A...</span>, <span class="number">2048</span>);
                
                <span class="comment">-- Lấy thông tin file</span>
                <span class="keyword">SELECT</span> <span class="column">TenFile</span>, <span class="column">KichThuoc</span>, <span class="column">LoaiFile</span>, 
                       <span class="function">LEN</span>(<span class="column">NoiDung</span>) <span class="keyword">AS</span> <span class="column">KichThuocThucTe</span> 
                <span class="keyword">FROM</span> <span class="table">TapTin</span>;
              </div>
            </div>

            <h3>🆔 5. KIỂU ĐẶC BIỆT</h3>
            <div class="example">
              <h4>IDENTITY - Tự động tăng:</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">KhachHang</span> (
                    <span class="column">ID</span> <span class="datatype">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>), <span class="comment">-- Bắt đầu từ 1, mỗi lần tăng 1</span>
                    <span class="column">MaKH</span> <span class="keyword">AS</span> <span class="string">'KH'</span> <span class="operator">+</span> <span class="function">RIGHT</span>(<span class="string">'000'</span> <span class="operator">+</span> <span class="function">CAST</span>(<span class="column">ID</span> <span class="keyword">AS</span> <span class="datatype">VARCHAR</span>(<span class="number">3</span>)), <span class="number">3</span>), <span class="comment">-- Computed column</span>
                    <span class="column">TenKH</span> <span class="datatype">VARCHAR</span>(<span class="number">100</span>),
                    <span class="column">NgayTao</span> <span class="datatype">DATETIME</span> <span class="keyword">DEFAULT</span> <span class="function">GETDATE</span>()
                );
                
                <span class="keyword">INSERT INTO</span> <span class="table">KhachHang</span> (<span class="column">TenKH</span>)
                <span class="keyword">VALUES</span> (<span class="string">'Nguyễn Văn A'</span>), (<span class="string">'Trần Thị B'</span>);
              </div>
            </div>

            <div class="note">
              <h4>📋 Nguyên tắc chọn datatype:</h4>
              <p><b>1. Số nguyên:</b></p>
              <ul>
                <li>ID nhỏ (< 32,000): SMALLINT</li>
                <li>ID thông thường: INT</li>
                <li>ID rất lớn, timestamp: BIGINT</li>
              </ul>
              <p><b>2. Tiền tệ:</b></p>
              <ul>
                <li>Luôn dùng DECIMAL(15,2) hoặc DECIMAL(18,4)</li>
                <li>Không bao giờ dùng FLOAT cho tiền!</li>
              </ul>
              <p><b>3. Chuỗi:</b></p>
              <ul>
                <li>Mã code cố định: CHAR(n)</li>
                <li>Tên, mô tả: NVARCHAR(n) (hỗ trợ Unicode)</li>
                <li>Nội dung dài: NTEXT</li>
              </ul>
            </div>

            <div class="highlight-box">
              <h4>⚡ Performance Tips:</h4>
              <ul>
                <li>Datatype nhỏ hơn = truy vấn nhanh hơn</li>
                <li>Index hiệu quả hơn trên datatype phù hợp</li>
                <li>
                  Tránh chuyển đổi datatype không cần thiết trong WHERE clause
                </li>
              </ul>
            </div>
          </section>

          <!-- 2 -->
          <section class="section" id="char-varchar">
            <h2>2. Phân biệt CHAR vs VARCHAR</h2>

            <h3>📝 CHAR (Character)</h3>
            <p>
              CHAR là kiểu dữ liệu chuỗi ký tự có <b>độ dài cố định</b>. Khi bạn
              khai báo một cột với kiểu dữ liệu CHAR(n), hệ thống sẽ luôn cấp
              phát một không gian lưu trữ là n ký tự, bất kể bạn lưu trữ bao
              nhiêu ký tự thực tế.
            </p>

            <div class="success-box">
              <h4>✅ Ưu điểm:</h4>
              <p>
                Tốc độ truy xuất nhanh hơn vì độ dài đã được xác định trước,
                giúp hệ thống không phải tốn thời gian để tính toán độ dài.
              </p>
            </div>

            <div class="highlight-box">
              <h4>❌ Nhược điểm:</h4>
              <p>
                Lãng phí không gian lưu trữ. Nếu dữ liệu bạn nhập ngắn hơn độ
                dài đã khai báo, hệ thống sẽ tự động thêm các khoảng trắng
                (padding) vào cuối chuỗi cho đủ n ký tự.
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ:</h4>
              <p>
                Giả sử bạn khai báo một cột <code>ma_san_pham</code> có kiểu dữ
                liệu là <code>CHAR(10)</code>.
              </p>
              <ul>
                <li>
                  Khi bạn lưu giá trị <code>'SP001'</code>, hệ thống sẽ lưu
                  <code>'SP001 '</code> (chuỗi 'SP001' cùng 5 khoảng trắng ở
                  cuối), chiếm 10 byte.
                </li>
                <li>
                  Khi bạn lưu giá trị <code>'SP12345678'</code>, hệ thống sẽ lưu
                  <code>'SP12345678'</code> (chuỗi đầy đủ 10 ký tự), chiếm 10
                  byte.
                </li>
              </ul>
            </div>

            <div class="info-box">
              <h4>🎯 Khi nào nên dùng CHAR?</h4>
              <p>
                Nên dùng CHAR cho các trường dữ liệu có độ dài cố định và ngắn,
                ví dụ như mã bưu điện, mã quốc gia (như 'VN', 'US'), hay các mã
                sản phẩm, mã danh mục có độ dài không thay đổi.
              </p>
            </div>

            <h3>🔄 VARCHAR (Variable Character)</h3>
            <p>
              VARCHAR là kiểu dữ liệu chuỗi ký tự có <b>độ dài thay đổi</b>. Khi
              bạn khai báo một cột với kiểu dữ liệu VARCHAR(n), hệ thống chỉ cấp
              phát không gian lưu trữ bằng với độ dài thực tế của chuỗi bạn
              nhập, cộng thêm một hoặc hai byte để lưu thông tin về độ dài của
              chuỗi.
            </p>

            <div class="success-box">
              <h4>✅ Ưu điểm:</h4>
              <p>Tiết kiệm không gian lưu trữ hiệu quả.</p>
            </div>

            <div class="highlight-box">
              <h4>❌ Nhược điểm:</h4>
              <p>
                Tốc độ xử lý có thể chậm hơn CHAR một chút vì hệ thống phải đọc
                thêm thông tin về độ dài chuỗi trước khi truy xuất dữ liệu.
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ:</h4>
              <p>
                Giả sử bạn khai báo một cột <code>ten_san_pham</code> có kiểu dữ
                liệu là <code>VARCHAR(50)</code>.
              </p>
              <ul>
                <li>
                  Khi bạn lưu giá trị <code>'Áo thun'</code>, hệ thống chỉ lưu
                  <code>'Áo thun'</code> (khoảng 7 ký tự) cộng với 1-2 byte độ
                  dài, tổng cộng chỉ chiếm khoảng 8-9 byte.
                </li>
                <li>
                  Khi bạn lưu giá trị
                  <code>'Điện thoại iPhone 15 Pro Max'</code>, hệ thống sẽ lưu
                  đúng chuỗi này, không thêm khoảng trắng và chỉ chiếm dung
                  lượng cần thiết.
                </li>
              </ul>
            </div>

            <div class="info-box">
              <h4>🎯 Khi nào nên dùng VARCHAR?</h4>
              <p>
                VARCHAR là lựa chọn phổ biến nhất và được khuyên dùng cho hầu
                hết các trường dữ liệu chuỗi có độ dài không xác định hoặc thay
                đổi nhiều, ví dụ như tên, địa chỉ, mô tả sản phẩm, email, và các
                đoạn văn bản.
              </p>
            </div>

            <h3>📊 Tóm tắt sự khác biệt</h3>
            <table class="comparison-table">
              <thead>
                <tr>
                  <th>Đặc điểm</th>
                  <th>CHAR(n)</th>
                  <th>VARCHAR(n)</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>Độ dài</b></td>
                  <td>
                    <span class="table-badge badge-warning">Cố định</span>
                  </td>
                  <td>
                    <span class="table-badge badge-feature">Thay đổi</span>
                  </td>
                </tr>
                <tr>
                  <td><b>Dung lượng</b></td>
                  <td>Luôn chiếm n byte (đã bao gồm khoảng trắng)</td>
                  <td>
                    Chỉ chiếm dung lượng thực tế của chuỗi + 1 hoặc 2 byte cho
                    độ dài
                  </td>
                </tr>
                <tr>
                  <td><b>Tốc độ</b></td>
                  <td><span class="status-yes">Nhanh hơn</span></td>
                  <td><span class="status-partial">Chậm hơn một chút</span></td>
                </tr>
                <tr>
                  <td><b>Tiết kiệm không gian</b></td>
                  <td>
                    <span class="status-no">Không hiệu quả (lãng phí)</span>
                  </td>
                  <td><span class="status-yes">Rất hiệu quả</span></td>
                </tr>
                <tr>
                  <td><b>Sử dụng phù hợp</b></td>
                  <td>Dữ liệu có độ dài cố định, ngắn</td>
                  <td>Dữ liệu có độ dài thay đổi</td>
                </tr>
              </tbody>
            </table>

            <div class="example">
              <h4>Ví dụ tổng hợp:</h4>
              <p>Giả sử bạn có một bảng <code>users</code> (người dùng).</p>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">users</span> (
                  <span class="column">id</span> <span class="datatype">INT</span>,
                  <span class="column">first_name</span> <span class="datatype">VARCHAR</span>(<span class="number">50</span>), 
                  <span class="column">last_name</span> <span class="datatype">VARCHAR</span>(<span class="number">50</span>), 
                  <span class="column">country_code</span> <span class="datatype">CHAR</span>(<span class="number">2</span>), 
                  <span class="column">phone_number</span> <span class="datatype">VARCHAR</span>(<span class="number">15</span>)
                );
              </div>
              <p><b>Trong ví dụ trên:</b></p>
              <ul>
                <li>
                  <code>first_name</code> và <code>last_name</code> dùng VARCHAR
                  vì tên người có độ dài khác nhau.
                </li>
                <li>
                  <code>country_code</code> dùng CHAR vì mã quốc gia luôn có 2
                  ký tự.
                </li>
                <li>
                  <code>phone_number</code> dùng VARCHAR vì độ dài số điện thoại
                  có thể thay đổi tùy theo quốc gia.
                </li>
              </ul>
            </div>
          </section>

          <!-- 3 -->
          <section class="section" id="conversion">
            <h2>3. Chuyển đổi giữa các kiểu dữ liệu</h2>

            <h3>🔄 1. CAST (chuyển đổi kiểu dữ liệu chung)</h3>
            <p>
              Hàm <b>CAST</b> là một hàm tiêu chuẩn trong SQL và được hỗ trợ bởi
              hầu hết các hệ quản trị cơ sở dữ liệu (như SQL Server, MySQL,
              PostgreSQL, Oracle).
            </p>

            <div class="info-box">
              <h4>📝 Cú pháp:</h4>
              <p><code>CAST(biểu_thức AS kiểu_dữ_liệu)</code></p>
              <h4>🎯 Chức năng:</h4>
              <p>
                Chuyển đổi một biểu thức thành một kiểu dữ liệu đã chỉ định.
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ:</h4>

              <h5><b>Chuyển số thành chuỗi:</b></h5>
              <div class="code-block">
                <span class="keyword">SELECT</span> <span class="function">CAST</span>(<span class="number">123</span> <span class="keyword">AS</span> <span class="datatype">VARCHAR</span>(<span class="number">10</span>)); 
                <span class="comment">-- Kết quả: '123'</span>
              </div>
              <p>
                Đây là cách bạn có thể nối một giá trị số vào một chuỗi văn bản.
                Ví dụ:
              </p>
              <div class="code-block">
                <span class="keyword">SELECT</span> <span class="string">'Sản phẩm có mã là: '</span> <span class="operator">+</span> <span class="function">CAST</span>(<span class="number">123</span> <span class="keyword">AS</span> <span class="datatype">VARCHAR</span>(<span class="number">10</span>));
              </div>

              <h5><b>Chuyển chuỗi thành số:</b></h5>
              <div class="code-block">
                <span class="keyword">SELECT</span> <span class="function">CAST</span>(<span class="string">'123.45'</span> <span class="keyword">AS</span> <span class="datatype">DECIMAL</span>(<span class="number">5</span>, <span class="number">2</span>)); 
                <span class="comment">-- Kết quả: 123.45</span>
              </div>

              <h5><b>Chuyển chuỗi thành ngày tháng:</b></h5>
              <div class="code-block">
                <span class="keyword">SELECT</span> <span class="function">CAST</span>(<span class="string">'2025-09-21'</span> <span class="keyword">AS</span> <span class="datatype">DATE</span>); 
                <span class="comment">-- Kết quả: 2025-09-21</span>
              </div>
            </div>

            <h3>🎨 2. CONVERT (chuyển đổi kiểu dữ liệu có định dạng)</h3>
            <p>
              Hàm <b>CONVERT</b> là hàm riêng của SQL Server và một số hệ quản
              trị cơ sở dữ liệu khác, cung cấp các tùy chọn định dạng nâng cao
              hơn CAST, đặc biệt hữu ích khi xử lý dữ liệu ngày tháng.
            </p>

            <div class="info-box">
              <h4>📝 Cú pháp:</h4>
              <p>
                <code>CONVERT(kiểu_dữ_liệu, biểu_thức, [kiểu_định_dạng])</code>
              </p>
              <h4>🎯 Chức năng:</h4>
              <p>
                Chuyển đổi một biểu thức thành một kiểu dữ liệu, với khả năng
                chỉ định một mã định dạng (style code) cụ thể.
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ:</h4>

              <h5><b>Định dạng ngày tháng:</b></h5>
              <div class="code-block">
                <span class="keyword">SELECT</span>
                <span class="function">CONVERT</span>(<span class="datatype"
                  >VARCHAR</span
                >, <span class="function">GETDATE</span>(),
                <span class="number">103</span>);
              </div>
              <p>
                Số <b>103</b> là một mã định dạng cho biết kiểu dd/MM/yyyy. SQL
                Server có nhiều mã định dạng khác nhau để xử lý các kiểu ngày
                tháng khác.
              </p>

              <h5><b>Ví dụ khác:</b></h5>
              <div class="code-block">
                <span class="comment">-- Định dạng ngày tháng kiểu yyyy-MM-dd</span>
                <span class="keyword">SELECT</span> <span class="function">CONVERT</span>(<span class="datatype">VARCHAR</span>, <span class="function">GETDATE</span>(), <span class="number">23</span>); 
                <span class="comment">-- Kết quả: '2025-09-21'</span>
              </div>
            </div>

            <h3>📊 Tóm tắt sự khác biệt</h3>
            <table class="comparison-table">
              <thead>
                <tr>
                  <th>Đặc điểm</th>
                  <th>CAST</th>
                  <th>CONVERT</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>Tính tương thích</b></td>
                  <td>
                    <span class="status-yes">Hầu hết các hệ quản trị CSDL</span>
                  </td>
                  <td>
                    <span class="status-partial">Chủ yếu là SQL Server</span>
                  </td>
                </tr>
                <tr>
                  <td><b>Cú pháp</b></td>
                  <td>
                    Đơn giản: <code>CAST(biểu_thức AS kiểu_dữ_liệu)</code>
                  </td>
                  <td>
                    Phức tạp hơn:
                    <code
                      >CONVERT(kiểu_dữ_liệu, biểu_thức, [mã_định_dạng])</code
                    >
                  </td>
                </tr>
                <tr>
                  <td><b>Chức năng</b></td>
                  <td>Chuyển đổi kiểu dữ liệu cơ bản</td>
                  <td>
                    Chuyển đổi kiểu dữ liệu với các tùy chọn định dạng chi tiết,
                    đặc biệt cho ngày tháng
                  </td>
                </tr>
                <tr>
                  <td><b>Định dạng</b></td>
                  <td>Không có tùy chọn định dạng</td>
                  <td>Có tùy chọn định dạng thông qua mã số (style code)</td>
                </tr>
              </tbody>
            </table>

            <div class="success-box">
              <h4>💡 Khuyến nghị sử dụng:</h4>
              <ul>
                <li>
                  <b>Dùng CAST</b> cho các chuyển đổi đơn giản và để đảm bảo
                  tính tương thích với nhiều hệ CSDL khác nhau
                </li>
                <li>
                  <b>Dùng CONVERT</b> khi cần định dạng chi tiết, đặc biệt với
                  ngày tháng trong SQL Server
                </li>
              </ul>
            </div>

            <div class="highlight-box">
              <h4>⚠️ Lưu ý quan trọng:</h4>
              <ul>
                <li>
                  Luôn kiểm tra tính hợp lệ của dữ liệu trước khi chuyển đổi
                </li>
                <li>
                  Một số chuyển đổi có thể gây mất dữ liệu (ví dụ: từ DECIMAL
                  sang INT)
                </li>
                <li>
                  Chuỗi không hợp lệ sẽ gây lỗi khi chuyển đổi sang số hoặc ngày
                </li>
              </ul>
            </div>
          </section>

          <!-- 4 -->
          <section class="section" id="truncate-drop-delete">
            <h2>4. TRUNCATE vs DROP vs DELETE</h2>

            <h3>🗑️ TRUNCATE</h3>
            <p>
              <b>TRUNCATE</b> là một lệnh Định nghĩa Dữ liệu (DDL - Data
              Definition Language). Nó được sử dụng để xóa tất cả các hàng khỏi
              một bảng một cách nhanh chóng.
            </p>

            <div class="info-box">
              <h4>🎯 Chức năng:</h4>
              <p>Xóa toàn bộ dữ liệu trong bảng.</p>

              <h4>⚡ Tác dụng:</h4>
              <p>
                Giống như DELETE không có điều kiện WHERE, nhưng hiệu quả hơn
                nhiều. Lệnh này hoạt động bằng cách giải phóng không gian lưu
                trữ của bảng, giống như cách bạn dọn sạch một căn nhà bằng cách
                quẳng tất cả đồ đạc đi mà không phải dọn dẹp từng món một.
              </p>

              <h4>🔒 Giao dịch:</h4>
              <p>
                Đây là một lệnh DDL, vì vậy nó thường tự động xác nhận (commit)
                và không thể hoàn tác (rollback).
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ:</h4>
              <div class="code-block">
                <span class="keyword">TRUNCATE TABLE</span>
                <span class="table">orders</span>;
              </div>
            </div>

            <div class="success-box">
              <h4>🎯 Khi nào nên dùng:</h4>
              <p>
                Khi bạn muốn xóa toàn bộ dữ liệu của một bảng lớn một cách nhanh
                chóng và hiệu quả, và bạn không cần phải khôi phục lại dữ liệu
                đó.
              </p>
            </div>

            <h3>💀 DROP</h3>
            <p>
              <b>DROP</b> là một lệnh Định nghĩa Dữ liệu (DDL). Nó được sử dụng
              để xóa hoàn toàn một đối tượng cơ sở dữ liệu (như bảng, chỉ mục,
              hoặc lược đồ).
            </p>

            <div class="info-box">
              <h4>🎯 Chức năng:</h4>
              <p>Xóa cả cấu trúc (schema) lẫn dữ liệu.</p>

              <h4>⚡ Tác dụng:</h4>
              <p>
                Khi bạn DROP một bảng, toàn bộ bảng đó và tất cả dữ liệu bên
                trong sẽ bị loại bỏ vĩnh viễn khỏi cơ sở dữ liệu.
              </p>

              <h4>🔒 Giao dịch:</h4>
              <p>
                Tương tự TRUNCATE, DROP cũng là một lệnh DDL và không thể hoàn
                tác (rollback).
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ:</h4>
              <div class="code-block">
                <span class="keyword">DROP TABLE</span>
                <span class="table">stocks</span>;
              </div>
            </div>

            <div class="success-box">
              <h4>🎯 Khi nào nên dùng:</h4>
              <p>
                Khi bạn không còn cần một bảng nào đó nữa và muốn xóa nó vĩnh
                viễn khỏi cơ sở dữ liệu của mình.
              </p>
            </div>

            <h3>✂️ DELETE</h3>
            <p>
              <b>DELETE</b> là một lệnh Thao tác Dữ liệu (DML - Data
              Manipulation Language). Nó được sử dụng để xóa một hoặc nhiều hàng
              khỏi một bảng.
            </p>

            <div class="info-box">
              <h4>🎯 Chức năng:</h4>
              <p>Xóa dữ liệu theo một điều kiện cụ thể.</p>

              <h4>⚡ Tác dụng:</h4>
              <p>
                Lệnh này xóa từng hàng một, mất nhiều thời gian hơn so với
                TRUNCATE, đặc biệt với các bảng lớn. Tuy nhiên, nó cho phép bạn
                chỉ xóa những hàng mà bạn muốn.
              </p>

              <h4>🔒 Giao dịch:</h4>
              <p>
                Là một lệnh DML, DELETE có thể hoàn tác (rollback). Điều này rất
                hữu ích khi bạn lỡ tay xóa nhầm dữ liệu.
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ:</h4>
              <div class="code-block">
                DELETE FROM customers WHERE city = 'Tokyo'; -- Xóa tất cả khách
                hàng ở Tokyo DELETE FROM customers WHERE registration_date <
                '2020-01-01'; -- Xóa khách hàng đăng ký trước năm 2020 DELETE
                FROM orders WHERE status = 'CANCELLED'; -- Xóa các đơn hàng đã
                hủy
              </div>
            </div>

            <div class="success-box">
              <h4>🎯 Khi nào nên dùng:</h4>
              <p>
                Khi bạn cần xóa một tập hợp con của dữ liệu trong một bảng hoặc
                khi bạn muốn có khả năng hoàn tác lại thao tác xóa.
              </p>
            </div>

            <h3>📊 Bảng tóm tắt</h3>
            <table class="comparison-table">
              <thead>
                <tr>
                  <th>Đặc điểm</th>
                  <th>TRUNCATE</th>
                  <th>DROP</th>
                  <th>DELETE</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>Loại lệnh</b></td>
                  <td><span class="table-badge badge-medium">DDL</span></td>
                  <td><span class="table-badge badge-medium">DDL</span></td>
                  <td><span class="table-badge badge-feature">DML</span></td>
                </tr>
                <tr>
                  <td><b>Phạm vi</b></td>
                  <td>Xóa toàn bộ dữ liệu trong bảng</td>
                  <td>Xóa toàn bộ bảng và cấu trúc</td>
                  <td>
                    Xóa các hàng được chọn (hoặc tất cả hàng nếu không có WHERE)
                  </td>
                </tr>
                <tr>
                  <td><b>Tốc độ</b></td>
                  <td><span class="status-yes">Rất nhanh</span></td>
                  <td><span class="status-yes">Nhanh</span></td>
                  <td>
                    <span class="status-no"
                      >Chậm hơn, đặc biệt với bảng lớn</span
                    >
                  </td>
                </tr>
                <tr>
                  <td><b>Hoàn tác</b></td>
                  <td>
                    <span class="status-no">Không thể (không có rollback)</span>
                  </td>
                  <td>
                    <span class="status-no">Không thể (không có rollback)</span>
                  </td>
                  <td><span class="status-yes">Có thể (có rollback)</span></td>
                </tr>
                <tr>
                  <td><b>Trường hợp sử dụng</b></td>
                  <td>Xóa nhanh toàn bộ dữ liệu để chuẩn bị cho dữ liệu mới</td>
                  <td>Xóa vĩnh viễn một bảng không còn cần thiết</td>
                  <td>Xóa dữ liệu có điều kiện hoặc cần khả năng khôi phục</td>
                </tr>
              </tbody>
            </table>

            <div class="highlight-box">
              <h4>⚠️ Lưu ý quan trọng:</h4>
              <ul>
                <li>
                  <b>TRUNCATE và DROP</b> không thể hoàn tác - hãy thận trọng
                  khi sử dụng!
                </li>
                <li>
                  <b>DELETE</b> có thể sử dụng trong transaction và có thể
                  rollback
                </li>
                <li><b>TRUNCATE</b> nhanh hơn DELETE rất nhiều với bảng lớn</li>
                <li><b>DROP</b> xóa cả cấu trúc bảng, không chỉ dữ liệu</li>
              </ul>
            </div>

            <div class="example">
              <h4>Ví dụ thực tế so sánh:</h4>
              <div class="code-block">
                <span class="comment">-- Tạo bảng test</span>
                <span class="keyword">CREATE TABLE</span> <span class="table">test_data</span> (
                    <span class="column">id</span> <span class="datatype">INT</span>,
                    <span class="column">name</span> <span class="datatype">VARCHAR</span>(<span class="number">50</span>),
                    <span class="column">created_date</span> <span class="datatype">DATE</span>
                );
                
                <span class="comment">-- Thêm dữ liệu</span>
                <span class="keyword">INSERT INTO</span> <span class="table">test_data</span> 
                <span class="keyword">VALUES</span> 
                    (<span class="number">1</span>, <span class="string">'Item 1'</span>, <span class="string">'2023-01-01'</span>),
                    (<span class="number">2</span>, <span class="string">'Item 2'</span>, <span class="string">'2023-02-01'</span>),
                    (<span class="number">3</span>, <span class="string">'Item 3'</span>, <span class="string">'2023-03-01'</span>);
                
                <span class="comment">-- DELETE: Xóa có điều kiện (có thể rollback)</span>
                <span class="keyword">BEGIN TRANSACTION</span>;
                <span class="comment">-- DELETE: Xóa có điều kiện</span>
                <span class="keyword">DELETE FROM</span> <span class="table">test_data</span> <span class="keyword">WHERE</span> <span class="column">id</span> <span class="operator">=</span> <span class="number">1</span>;
                
                <span class="comment">-- TRUNCATE: Xóa toàn bộ</span>
                <span class="keyword">TRUNCATE TABLE</span> <span class="table">test_data</span>;
                
                <span class="comment">-- DROP: Xóa bảng</span>
                <span class="keyword">DROP TABLE</span> <span class="table">test_data</span>;
              </div>
            </div>
          </section>

          <!-- 5 -->
          <section class="section" id="identity-sequence">
            <h2>5. Identity vs Sequence</h2>

            <h3>🔢 1. IDENTITY (cột tự tăng)</h3>
            <p>
              <b>IDENTITY</b> là một thuộc tính được gán cho một cột trong một
              bảng. Nó tự động tạo ra một số duy nhất, tăng dần cho mỗi bản ghi
              mới được thêm vào.
            </p>

            <div class="info-box">
              <h4>📋 Đặc điểm:</h4>
              <ul>
                <li>
                  <b>Phạm vi:</b> Độc lập và chỉ áp dụng cho một bảng cụ thể.
                  Mỗi bảng có một cột IDENTITY riêng biệt.
                </li>
                <li>
                  <b>Tạo số:</b> Số được tạo ra tự động và tuần tự khi bạn chèn
                  (insert) dữ liệu vào bảng. Bạn không cần phải chỉ định giá trị
                  cho cột này.
                </li>
                <li><b>Cú pháp:</b> Thường được khai báo khi tạo bảng.</li>
              </ul>
            </div>

            <div class="example">
              <h4>Ví dụ:</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">orders</span> (
                    <span class="column">order_id</span> <span class="datatype">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">PRIMARY KEY</span>, <span class="comment">-- IDENTITY(seed, increment)</span>
                    <span class="column">customer_id</span> <span class="datatype">INT</span>,
                    <span class="column">order_date</span> <span class="datatype">DATE</span>
                );
              </div>
              <p>Trong đó, <code>IDENTITY(1,1)</code> có nghĩa là:</p>
              <ul>
                <li>
                  <b>1 đầu tiên (seed):</b> Giá trị bắt đầu của số tự tăng.
                </li>
                <li>
                  <b>1 thứ hai (increment):</b> Bước nhảy giữa các giá trị.
                </li>
              </ul>
            </div>

            <div class="success-box">
              <h4>🎯 Khi nào nên dùng:</h4>
              <p>
                Khi bạn cần một khóa chính (primary key) tự động tăng cho một
                bảng duy nhất, chẳng hạn như order_id hoặc product_id. Đây là
                cách đơn giản và phổ biến nhất để tạo ID duy nhất cho mỗi bản
                ghi.
              </p>
            </div>

            <h3>🎲 2. SEQUENCE (đối tượng tạo số)</h3>
            <p>
              <b>SEQUENCE</b> là một đối tượng cơ sở dữ liệu độc lập, được sử
              dụng để tạo ra một chuỗi các số duy nhất, tuần tự. Nó có thể được
              sử dụng bởi một hoặc nhiều bảng.
            </p>

            <div class="info-box">
              <h4>📋 Đặc điểm:</h4>
              <ul>
                <li>
                  <b>Phạm vi:</b> Độc lập với bảng và có thể được dùng chung cho
                  nhiều bảng. SEQUENCE tồn tại như một đối tượng riêng biệt
                  trong cơ sở dữ liệu.
                </li>
                <li>
                  <b>Tạo số:</b> Bạn phải gọi một hàm để lấy giá trị tiếp theo
                  từ SEQUENCE.
                </li>
                <li>
                  <b>Trong SQL Server:</b>
                  <code>NEXT VALUE FOR sequence_name</code>
                </li>
                <li>
                  <b>Trong Oracle/PostgreSQL:</b>
                  <code>sequence_name.NEXTVAL</code>
                </li>
                <li>
                  <b>Tính toàn vẹn:</b> Thậm chí khi một giao dịch bị hủy bỏ
                  (rollback), số đã lấy từ SEQUENCE sẽ không được cấp lại. Điều
                  này có thể dẫn đến các số bị thiếu (gap) trong chuỗi.
                </li>
              </ul>
            </div>

            <div class="example">
              <h4>Ví dụ:</h4>
              <div class="code-block">
                -- Tạo một SEQUENCE có tên là seq_transaction_id, bắt đầu từ 1
                và tăng 1
                <span class="keyword">CREATE SEQUENCE</span> <span class="table">seq_transaction_id</span> 
                <span class="keyword">START WITH</span> <span class="number">1</span> <span class="keyword">INCREMENT BY</span> <span class="number">1</span>;
                
                <span class="comment">-- Sử dụng SEQUENCE khi thêm dữ liệu vào bảng</span>
                <span class="keyword">INSERT INTO</span> <span class="table">transactions</span> (<span class="column">transaction_id</span>, <span class="column">transaction_date</span>)
                <span class="keyword">VALUES</span> (<span class="keyword">NEXT VALUE FOR</span> <span class="table">seq_transaction_id</span>, <span class="function">GETDATE</span>());
                
                <span class="comment">-- Có thể sử dụng cùng SEQUENCE cho nhiều bảng khác nhau</span>
                <span class="keyword">INSERT INTO</span> <span class="table">audit_log</span> (<span class="column">log_id</span>, <span class="column">action</span>, <span class="column">timestamp</span>) 
                <span class="keyword">VALUES</span> (<span class="keyword">NEXT VALUE FOR</span> <span class="table">seq_transaction_id</span>, <span class="string">'LOGIN'</span>, <span class="function">GETDATE</span>());
              </div>
            </div>

            <div class="success-box">
              <h4>🎯 Khi nào nên dùng:</h4>
              <p>
                Khi bạn cần tạo ID duy nhất và có thể chia sẻ giữa nhiều bảng,
                ví dụ như ID cho các giao dịch liên quan đến nhiều bảng khác
                nhau. SEQUENCE cũng hữu ích khi bạn cần tạo ID trước khi chèn
                vào bảng.
              </p>
            </div>

            <h3>📊 Bảng tóm tắt sự khác biệt</h3>
            <table class="comparison-table">
              <thead>
                <tr>
                  <th>Đặc điểm</th>
                  <th>IDENTITY</th>
                  <th>SEQUENCE</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>Phạm vi</b></td>
                  <td>Cột cụ thể trong một bảng duy nhất</td>
                  <td>Đối tượng độc lập, có thể dùng chung cho nhiều bảng</td>
                </tr>
                <tr>
                  <td><b>Cách sử dụng</b></td>
                  <td>
                    <span class="table-badge badge-warning"
                      >Tự động tạo giá trị khi chèn dữ liệu</span
                    >
                  </td>
                  <td>
                    <span class="table-badge badge-feature"
                      >Phải gọi hàm để lấy giá trị tiếp theo</span
                    >
                  </td>
                </tr>
                <tr>
                  <td><b>Tính linh hoạt</b></td>
                  <td>
                    <span class="status-partial"
                      >Kém linh hoạt hơn, chỉ dùng cho một cột duy nhất</span
                    >
                  </td>
                  <td>
                    <span class="status-yes"
                      >Linh hoạt hơn, có thể dùng cho nhiều bảng, lấy giá trị
                      trước khi chèn</span
                    >
                  </td>
                </tr>
                <tr>
                  <td><b>Vị trí</b></td>
                  <td>Thuộc tính của cột trong <code>CREATE TABLE</code></td>
                  <td>Đối tượng riêng biệt trong cơ sở dữ liệu</td>
                </tr>
                <tr>
                  <td><b>Tính tương thích</b></td>
                  <td>
                    Hầu hết các hệ quản trị CSDL đều có cơ chế tương tự (<code
                      >AUTO_INCREMENT</code
                    >
                    trong MySQL)
                  </td>
                  <td>Phổ biến trong Oracle, PostgreSQL, và SQL Server</td>
                </tr>
              </tbody>
            </table>

            <div class="example">
              <h4>Ví dụ thực tế so sánh:</h4>
              <div class="code-block">
                <span class="comment">-- IDENTITY: Đơn giản cho một bảng</span>
                <span class="keyword">CREATE TABLE</span> <span class="table">customers</span> (
                    <span class="column">customer_id</span> <span class="datatype">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">PRIMARY KEY</span>,
                    <span class="column">customer_name</span> <span class="datatype">NVARCHAR</span>(<span class="number">100</span>),
                    <span class="column">email</span> <span class="datatype">NVARCHAR</span>(<span class="number">100</span>)
                );
                
                <span class="comment">-- Chèn dữ liệu</span>
                <span class="keyword">INSERT INTO</span> <span class="table">customers</span> (<span class="column">customer_name</span>, <span class="column">email</span>)
                <span class="keyword">VALUES</span> (<span class="string">N'Nguyễn Văn A'</span>, <span class="string">'a@email.com'</span>);
                
                <span class="comment">-- SEQUENCE: Linh hoạt cho nhiều bảng</span>
                <span class="keyword">CREATE SEQUENCE</span> <span class="table">seq_global_id</span> 
                <span class="keyword">START WITH</span> <span class="number">1000</span> <span class="keyword">INCREMENT BY</span> <span class="number">1</span>;
                
                <span class="keyword">CREATE TABLE</span> <span class="table">orders</span> (
                    <span class="column">order_id</span> <span class="datatype">INT</span> <span class="keyword">PRIMARY KEY</span>,
                    <span class="column">customer_id</span> <span class="datatype">INT</span>,
                    <span class="column">order_date</span> <span class="datatype">DATE</span>
                );
                
                <span class="keyword">CREATE TABLE</span> <span class="table">invoices</span> (
                    <span class="column">invoice_id</span> <span class="datatype">INT</span> <span class="keyword">PRIMARY KEY</span>,
                    <span class="column">order_id</span> <span class="datatype">INT</span>,
                    <span class="column">amount</span> <span class="datatype">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>)
                );
                
                <span class="comment">-- Sử dụng cùng sequence cho cả hai bảng</span>
                <span class="keyword">INSERT INTO</span> <span class="table">orders</span> 
                <span class="keyword">VALUES</span> (<span class="keyword">NEXT VALUE FOR</span> <span class="table">seq_global_id</span>, <span class="number">1</span>, <span class="function">GETDATE</span>());
                
                <span class="keyword">INSERT INTO</span> <span class="table">invoices</span> 
                <span class="keyword">VALUES</span> (<span class="keyword">NEXT VALUE FOR</span> <span class="table">seq_global_id</span>, <span class="number">1001</span>, <span class="number">150000.00</span>);
              </div>
            </div>

            <div class="highlight-box">
              <h4>💡 Lựa chọn phù hợp:</h4>
              <ul>
                <li>
                  <b>Chọn IDENTITY</b> khi bạn cần ID đơn giản cho một bảng cụ
                  thể
                </li>
                <li>
                  <b>Chọn SEQUENCE</b> khi bạn cần chia sẻ số tự tăng giữa nhiều
                  bảng hoặc cần linh hoạt hơn trong việc tạo ID
                </li>
                <li>
                  <b>IDENTITY</b> dễ sử dụng và phổ biến hơn cho các ứng dụng
                  đơn giản
                </li>
                <li>
                  <b>SEQUENCE</b> mạnh mẽ hơn cho các thiết kế cơ sở dữ liệu
                  phức tạp
                </li>
              </ul>
            </div>
          </section>

          <!-- 6 -->
          <section class="section" id="constraint">
            <h2>6. Constraint trong SQL</h2>

            <h3>🔒 Constraint là gì?</h3>
            <p>
              <b>Constraint (ràng buộc)</b> là các quy tắc được áp dụng cho cột
              hoặc bảng trong cơ sở dữ liệu để giới hạn loại dữ liệu có thể được
              chèn vào. Mục đích chính của chúng là để đảm bảo tính toàn vẹn và
              độ chính xác của dữ liệu trong cơ sở dữ liệu.
            </p>

            <div class="info-box">
              <h4>📝 Các loại Constraint phổ biến:</h4>
              <p>
                <b>NOT NULL</b>, <b>UNIQUE</b>, <b>PRIMARY KEY</b>,
                <b>FOREIGN KEY</b>, <b>CHECK</b>, <b>DEFAULT</b>
              </p>
            </div>

            <h3>❌ 1. NOT NULL</h3>
            <p>
              Ràng buộc <b>NOT NULL</b> đảm bảo rằng một cột không thể có giá
              trị NULL. Điều này có nghĩa là bạn phải luôn cung cấp một giá trị
              cho cột đó khi thêm một hàng mới.
            </p>

            <div class="example">
              <h4>Ví dụ:</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">products</span> (
                    <span class="column">product_id</span> <span class="datatype">INT</span> <span class="keyword">PRIMARY KEY</span>,
                    <span class="column">product_name</span> <span class="datatype">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT NULL</span>, <span class="comment">-- Tên sản phẩm không được phép để trống</span>
                    <span class="column">description</span> <span class="datatype">TEXT</span>,
                    <span class="column">price</span> <span class="datatype">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">NOT NULL</span> <span class="comment">-- Giá sản phẩm bắt buộc phải có</span>
                );
              </div>
              <p>
                Cột <code>product_name</code> không được phép để trống - khách
                hàng cần biết tên sản phẩm.
              </p>
            </div>

            <h3>🔑 2. UNIQUE</h3>
            <p>
              Ràng buộc <b>UNIQUE</b> đảm bảo rằng tất cả các giá trị trong một
              cột là duy nhất. Nó cho phép giá trị NULL, nhưng mỗi giá trị NULL
              cũng phải là duy nhất.
            </p>

            <div class="example">
              <h4>Ví dụ:</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">users</span> (
                    <span class="column">user_id</span> <span class="datatype">INT</span> <span class="keyword">PRIMARY KEY</span>,
                    <span class="column">username</span> <span class="datatype">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">UNIQUE</span>, <span class="comment">-- Tên đăng nhập phải duy nhất</span>
                    <span class="column">email</span> <span class="datatype">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">UNIQUE</span>, <span class="comment">-- Email phải duy nhất</span>
                    <span class="column">phone</span> <span class="datatype">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">UNIQUE</span> <span class="comment">-- Số điện thoại phải duy nhất</span>
                );
              </div>
              <p>
                Mỗi người dùng phải có một địa chỉ email riêng biệt - không được
                trùng lặp.
              </p>
            </div>

            <h3>🗝️ 3. PRIMARY KEY (Khóa Chính)</h3>
            <p>
              Ràng buộc <b>PRIMARY KEY</b> là một tổ hợp của NOT NULL và UNIQUE.
              Nó dùng để xác định duy nhất một hàng trong một bảng. Một bảng chỉ
              có thể có một khóa chính, và giá trị của nó không bao giờ được
              phép thay đổi (thường là một ID tự tăng).
            </p>

            <div class="example">
              <h4>Ví dụ:</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">customers</span> (
                    <span class="column">customer_id</span> <span class="datatype">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">PRIMARY KEY</span>, <span class="comment">-- ID khách hàng tự tăng</span>
                    <span class="column">customer_name</span> <span class="datatype">NVARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,
                    <span class="column">registration_date</span> <span class="datatype">DATE</span> <span class="keyword">DEFAULT</span> <span class="function">GETDATE</span>()
                );
              </div>
              <p>
                Cột <code>customer_id</code> là duy nhất và không được phép để
                trống - đây là danh tính của mỗi khách hàng.
              </p>
            </div>

            <h3>🔗 4. FOREIGN KEY (Khóa Ngoại)</h3>
            <p>
              Ràng buộc <b>FOREIGN KEY</b> được dùng để liên kết hai bảng với
              nhau. Nó đảm bảo rằng các giá trị trong một cột của bảng này (khóa
              ngoại) phải tương ứng với một giá trị trong cột khóa chính của
              bảng khác. Điều này giúp duy trì mối quan hệ và tính toàn vẹn tham
              chiếu giữa các bảng.
            </p>

            <div class="example">
              <h4>Ví dụ:</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">orders</span> (
                    <span class="column">order_id</span> <span class="datatype">INT</span> <span class="keyword">PRIMARY KEY</span>,
                    <span class="column">customer_id</span> <span class="datatype">INT</span>,
                    <span class="column">order_date</span> <span class="datatype">DATE</span>,
                    <span class="column">total_amount</span> <span class="datatype">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),
                    <span class="keyword">FOREIGN KEY</span> (<span class="column">customer_id</span>) <span class="keyword">REFERENCES</span> <span class="table">customers</span>(<span class="column">customer_id</span>)
                );
              </div>
              <p>
                Trong ví dụ này, <code>customer_id</code> trong bảng
                <code>orders</code> là khóa ngoại, nó phải tham chiếu đến một
                <code>customer_id</code> có thật trong bảng
                <code>customers</code>.
              </p>
            </div>

            <h3>✅ 5. CHECK</h3>
            <p>
              Ràng buộc <b>CHECK</b> cho phép bạn đặt một điều kiện cụ thể mà
              tất cả các giá trị trong một cột phải tuân theo.
            </p>

            <div class="example">
              <h4>Ví dụ:</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">employees</span> (
                    <span class="column">employee_id</span> <span class="datatype">INT</span> <span class="keyword">PRIMARY KEY</span>,
                    <span class="column">employee_name</span> <span class="datatype">NVARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,
                    <span class="column">age</span> <span class="datatype">INT</span> <span class="keyword">CHECK</span> (<span class="column">age</span> <span class="operator">=</span> <span class="number">18</span> <span class="keyword">AND</span> <span class="column">age</span> <span class="operator"><=</span> <span class="number">65</span>), <span class="comment">-- Tuổi từ 18-65</span>
                    <span class="column">salary</span> <span class="datatype">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">CHECK</span> (<span class="column">salary</span> <span class="operator">></span> <span class="number">0</span>), <span class="comment">-- Lương phải dương</span>
                    <span class="column">department</span> <span class="datatype">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">CHECK</span> (<span class="column">department</span> <span class="keyword">IN</span> (<span class="string">'IT'</span>, <span class="string">'HR'</span>, <span class="string">'Finance'</span>, <span class="string">'Marketing'</span>))
                );
              </div>
              <p>
                Cột <code>age</code> chỉ chấp nhận các giá trị từ 18 đến 65 tuổi
                - phù hợp với độ tuổi lao động.
              </p>
            </div>

            <h3>🎯 6. DEFAULT</h3>
            <p>
              Ràng buộc <b>DEFAULT</b> cung cấp một giá trị mặc định cho một
              cột. Nếu không có giá trị nào được chỉ định khi chèn một hàng, giá
              trị mặc định sẽ tự động được sử dụng.
            </p>

            <div class="example">
              <h4>Ví dụ:</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">orders</span> (
                    <span class="column">order_id</span> <span class="datatype">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">PRIMARY KEY</span>,
                    <span class="column">customer_id</span> <span class="datatype">INT</span>,
                    <span class="column">order_date</span> <span class="datatype">DATE</span> <span class="keyword">DEFAULT</span> <span class="function">GETDATE</span>(), <span class="comment">-- Ngày đặt hàng mặc định là hôm nay</span>
                    <span class="column">status</span> <span class="datatype">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">'PENDING'</span>, <span class="comment">-- Trạng thái mặc định là 'PENDING'</span>
                    <span class="column">priority</span> <span class="datatype">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>, <span class="comment">-- Độ ưu tiên mặc định là 1</span>
                    <span class="column">notes</span> <span class="datatype">NVARCHAR</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="string">N'Không có ghi chú'</span>
                );
              </div>
              <p>
                Nếu không khai báo trạng thái, nó sẽ tự động được đặt là
                <code>'PENDING'</code>.
              </p>
            </div>

            <h3>🔧 Ví dụ tổng hợp</h3>
            <p>
              Bạn có thể thêm các ràng buộc trực tiếp khi tạo bảng hoặc sau đó
              bằng lệnh ALTER TABLE. Dưới đây là ví dụ sử dụng ALTER TABLE để
              thêm một ràng buộc FOREIGN KEY.
            </p>

            <div class="example">
              <div class="code-block">
                ALTER TABLE orders ADD CONSTRAINT FK_customer FOREIGN KEY
                (customer_id) REFERENCES customers(customer_id);
              </div>
              <p><b>Giải thích từng phần:</b></p>
              <ul>
                <li>
                  <code>ALTER TABLE orders</code>: Lệnh này cho biết bạn muốn
                  thay đổi cấu trúc của bảng orders.
                </li>
                <li>
                  <code>ADD CONSTRAINT FK_customer</code>: Thêm một ràng buộc
                  mới và đặt tên là FK_customer. Việc đặt tên giúp bạn dễ dàng
                  quản lý và xóa ràng buộc sau này.
                </li>
                <li>
                  <code>FOREIGN KEY (customer_id)</code>: Chỉ định cột
                  customer_id trong bảng orders là khóa ngoại.
                </li>
                <li>
                  <code>REFERENCES customers(customer_id)</code>: Chỉ định rằng
                  khóa ngoại này tham chiếu đến cột customer_id là khóa chính
                  trong bảng customers.
                </li>
              </ul>
            </div>

            <div class="success-box">
              <h4>💡 Lợi ích của Constraints:</h4>
              <ul>
                <li>
                  <b>Đảm bảo tính toàn vẹn dữ liệu:</b> Ngăn chặn dữ liệu không
                  hợp lệ
                </li>
                <li>
                  <b>Tự động kiểm tra:</b> Database tự động kiểm tra ràng buộc
                  khi thêm/sửa dữ liệu
                </li>
                <li>
                  <b>Hiệu suất tốt hơn:</b> Một số constraint giúp tối ưu hóa
                  truy vấn
                </li>
                <li>
                  <b>Tính nhất quán:</b> Đảm bảo dữ liệu luôn tuân theo quy tắc
                  nghiệp vụ
                </li>
              </ul>
            </div>

            <div class="highlight-box">
              <h4>⚠️ Lưu ý quan trọng:</h4>
              <ul>
                <li>
                  Constraint được kiểm tra mỗi khi có thao tác INSERT, UPDATE
                </li>
                <li>
                  Vi phạm constraint sẽ gây ra lỗi và rollback transaction
                </li>
                <li>Nên đặt tên có ý nghĩa cho constraint để dễ quản lý</li>
                <li>
                  FOREIGN KEY constraint có thể ảnh hưởng đến hiệu suất với bảng
                  lớn
                </li>
              </ul>
            </div>
          </section>

          <!-- 7 -->
          <section class="section" id="constraint-ways">
            <h2>7. Có mấy cách tạo constraint?</h2>

            <h3>🎯 1. Tạo constraint khi khởi tạo bảng (CREATE TABLE)</h3>
            <p>
              Đây là phương pháp phổ biến và được khuyến khích sử dụng. Bạn định
              nghĩa các ràng buộc ngay trong câu lệnh CREATE TABLE. Cách này
              giúp cấu trúc bảng của bạn rõ ràng ngay từ đầu và đảm bảo tính
              toàn vẹn dữ liệu ngay khi bảng được tạo.
            </p>

            <div class="info-box">
              <h4>📝 Cú pháp:</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">table_name</span> (
                    <span class="column">column1</span> <span class="datatype">datatype</span> <span class="keyword">CONSTRAINT_1</span>,
                    <span class="column">column2</span> <span class="datatype">datatype</span> <span class="keyword">CONSTRAINT_2</span>,
                    ...
                    <span class="keyword">CONSTRAINT_N</span>
                );
              </div>
            </div>

            <div class="example">
              <h4>Ví dụ chi tiết:</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">products</span> (
                    <span class="column">product_id</span> <span class="datatype">INT</span> <span class="keyword">PRIMARY KEY</span>,
                    <span class="column">product_name</span> <span class="datatype">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span> <span class="keyword">UNIQUE</span>,
                    <span class="column">price</span> <span class="datatype">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">CHECK</span> (<span class="column">price</span> <span class="operator">></span> <span class="number">0</span>),
                    <span class="column">category_id</span> <span class="datatype">INT</span> <span class="keyword">REFERENCES</span> <span class="table">categories</span>(<span class="column">category_id</span>)
                );
              </div>
              <p>Trong ví dụ này:</p>
              <ul>
                <li>
                  <code>product_id</code> và <code>product_name</code> được định
                  nghĩa ràng buộc trực tiếp
                </li>
                <li>
                  Ràng buộc <code>UNIQUE</code> và <code>FOREIGN KEY</code> được
                  định nghĩa riêng biệt ở cuối
                </li>
                <li>
                  Cách này thường được dùng khi ràng buộc áp dụng cho nhiều cột
                  hoặc cần đặt tên cụ thể
                </li>
              </ul>
            </div>

            <div class="success-box">
              <h4>✅ Ưu điểm của cách này:</h4>
              <ul>
                <li>
                  <b>Cấu trúc rõ ràng:</b> Toàn bộ ràng buộc được định nghĩa
                  cùng lúc
                </li>
                <li>
                  <b>Đảm bảo tính toàn vẹn:</b> Ràng buộc có hiệu lực ngay từ
                  khi tạo bảng
                </li>
                <li>
                  <b>Dễ đọc và bảo trì:</b> Developers có thể hiểu cấu trúc bảng
                  ngay lập tức
                </li>
                <li>
                  <b>Hiệu suất tốt:</b> Không cần thêm thao tác ALTER sau này
                </li>
              </ul>
            </div>

            <h3>🔧 2. Tạo constraint sau khi bảng đã tồn tại (ALTER TABLE)</h3>
            <p>
              Nếu bạn cần thêm một ràng buộc vào một bảng đã có sẵn, bạn sử dụng
              câu lệnh ALTER TABLE. Phương pháp này hữu ích khi bạn muốn thay
              đổi cấu trúc của bảng mà không cần phải xóa và tạo lại bảng.
            </p>

            <div class="info-box">
              <h4>📝 Cú pháp:</h4>
              <div class="code-block">
                ALTER TABLE table_name ADD CONSTRAINT constraint_name
                constraint_type (column_name);
              </div>
            </div>

            <div class="example">
              <h4>Ví dụ thực tế:</h4>
              <p>
                Giả sử bạn đã có một bảng <code>products</code> nhưng chưa có
                ràng buộc UNIQUE cho tên sản phẩm. Bạn có thể thêm nó như sau:
              </p>
              <div class="code-block">
                -- Thêm ràng buộc UNIQUE ALTER TABLE products ADD CONSTRAINT
                UQ_product_name UNIQUE (product_name); -- Thêm ràng buộc CHECK
                cho giá ALTER TABLE products ADD CONSTRAINT CHK_price_positive
                CHECK (price > 0); -- Thêm ràng buộc FOREIGN KEY ALTER TABLE
                products ADD CONSTRAINT FK_supplier FOREIGN KEY (supplier_id)
                REFERENCES suppliers(supplier_id); -- Thêm ràng buộc DEFAULT
                (cách khác) ALTER TABLE products ADD CONSTRAINT DF_status
                DEFAULT 'ACTIVE' FOR status;
              </div>
              <p>
                Lệnh này sẽ thêm một ràng buộc tên là
                <code>UQ_product_name</code> vào bảng products, đảm bảo rằng tên
                sản phẩm không bị trùng lặp.
              </p>
            </div>

            <div class="highlight-box">
              <h4>⚠️ Lưu ý quan trọng khi dùng ALTER TABLE:</h4>
              <ul>
                <li>
                  <b>Kiểm tra dữ liệu hiện tại:</b> Đảm bảo dữ liệu đã có tuân
                  thủ ràng buộc mới
                </li>
                <li>
                  <b>Backup trước khi thay đổi:</b> Phòng trường hợp có lỗi xảy
                  ra
                </li>
                <li>
                  <b>Thời gian thực thi:</b> Với bảng lớn có thể mất thời gian
                  để kiểm tra toàn bộ dữ liệu
                </li>
                <li>
                  <b>Lock bảng:</b> Trong quá trình thêm constraint, bảng có thể
                  bị lock
                </li>
              </ul>
            </div>

            <h3>📊 Tóm tắt so sánh</h3>
            <table class="comparison-table">
              <thead>
                <tr>
                  <th>Phương pháp</th>
                  <th>Ưu điểm</th>
                  <th>Nhược điểm</th>
                  <th>Trường hợp sử dụng</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>CREATE TABLE</b></td>
                  <td>
                    <span class="status-yes"
                      >Cấu trúc rõ ràng, đảm bảo tính toàn vẹn ngay từ đầu</span
                    >
                  </td>
                  <td>
                    <span class="status-no"
                      >Không thể thêm ràng buộc cho bảng đã tồn tại</span
                    >
                  </td>
                  <td>
                    <span class="table-badge badge-feature"
                      >Khởi tạo bảng mới</span
                    >
                  </td>
                </tr>
                <tr>
                  <td><b>ALTER TABLE</b></td>
                  <td>
                    <span class="status-yes"
                      >Linh hoạt, cho phép thay đổi cấu trúc bảng hiện có</span
                    >
                  </td>
                  <td>
                    <span class="status-partial"
                      >Cần cẩn thận, có thể gây lỗi nếu dữ liệu hiện tại không
                      tuân thủ ràng buộc</span
                    >
                  </td>
                  <td>
                    <span class="table-badge badge-warning"
                      >Sửa đổi bảng đã có sẵn</span
                    >
                  </td>
                </tr>
              </tbody>
            </table>

            <div class="example">
              <h4>Ví dụ tổng hợp - Kịch bản thực tế:</h4>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">employees</span> (
                    <span class="column">employee_id</span> <span class="datatype">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">PRIMARY KEY</span>,
                    <span class="column">employee_name</span> <span class="datatype">NVARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,
                    <span class="column">email</span> <span class="datatype">NVARCHAR</span>(<span class="number">100</span>) <span class="keyword">UNIQUE</span>,
                    <span class="column">salary</span> <span class="datatype">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">CHECK</span> (<span class="column">salary</span> <span class="operator">></span> <span class="number">0</span>)
                );
              </div>
                
                <span class="comment">-- Bước 3: Thêm bảng phòng ban và liên kết</span>
                <span class="keyword">CREATE TABLE</span> <span class="table">departments</span> (
                    <span class="column">department_id</span> <span class="datatype">INT</span> <span class="keyword">PRIMARY KEY</span>,
                    <span class="column">department_name</span> <span class="datatype">NVARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT NULL</span>
                );
                
                <span class="comment">-- Thêm cột department_id vào bảng employees</span>
                <span class="keyword">ALTER TABLE</span> <span class="table">employees</span> <span class="keyword">ADD</span> <span class="column">department_id</span> <span class="datatype">INT</span>;
                
                <span class="comment">-- Tạo foreign key constraint</span>
                <span class="keyword">ALTER TABLE</span> <span class="table">employees</span> 
                <span class="keyword">ADD CONSTRAINT</span> <span class="column">FK_employee_department</span> 
                <span class="keyword">FOREIGN KEY</span> (<span class="column">department_id</span>) <span class="keyword">REFERENCES</span> <span class="table">departments</span>(<span class="column">department_id</span>);
              </div>
            </div>

            <div class="success-box">
              <h4>💡 Khuyến nghị tốt nhất:</h4>
              <ul>
                <li>
                  <b>Ưu tiên CREATE TABLE:</b> Định nghĩa đầy đủ constraint khi
                  thiết kế ban đầu
                </li>
                <li>
                  <b>Sử dụng ALTER TABLE:</b> Cho việc bảo trì và mở rộng hệ
                  thống
                </li>
                <li>
                  <b>Đặt tên có ý nghĩa:</b> Sử dụng prefix như UQ_, FK_, CHK_
                  để dễ quản lý
                </li>
                <li>
                  <b>Kiểm tra trước khi thêm:</b> Đảm bảo dữ liệu hiện tại phù
                  hợp với constraint mới
                </li>
              </ul>
            </div>
          </section>

          <!-- 8 -->
          <section class="section" id="unique-pk">
            <h2>8. Unique vs Primary Key</h2>

            <h3>🔑 1. UNIQUE (Khóa Duy Nhất)</h3>
            <p>
              <b>UNIQUE</b> là một ràng buộc (constraint) đảm bảo rằng tất cả
              các giá trị trong một cột (hoặc một nhóm cột) đều là duy nhất. Nó
              ngăn chặn việc trùng lặp dữ liệu trong các cột được áp dụng.
            </p>

            <div class="info-box">
              <h4>📋 Tính chất của UNIQUE:</h4>
              <ul>
                <li>
                  <b>Cho phép NULL:</b> Một cột có ràng buộc UNIQUE có thể chứa
                  một hoặc nhiều giá trị NULL
                </li>
                <li>
                  <b>Số lượng:</b> Một bảng có thể có nhiều ràng buộc UNIQUE
                </li>
                <li>
                  <b>Mục đích:</b> Đảm bảo tính duy nhất của dữ liệu nhưng không
                  nhận dạng bản ghi
                </li>
              </ul>
            </div>

            <div class="example">
              <h4>Ví dụ UNIQUE:</h4>
              <p>
                Giả sử bạn có một bảng <code>customers</code> (khách hàng) và
                muốn đảm bảo rằng mỗi khách hàng chỉ có một địa chỉ email duy
                nhất.
              </p>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">customers</span> (
                    <span class="column">customer_id</span> <span class="datatype">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">PRIMARY KEY</span>,
                    <span class="column">customer_name</span> <span class="datatype">NVARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,
                    <span class="column">email</span> <span class="datatype">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">UNIQUE</span>, <span class="comment">-- Áp dụng ràng buộc UNIQUE cho cột email</span>
                    <span class="column">phone_number</span> <span class="datatype">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>, <span class="comment">-- Số điện thoại cũng phải duy nhất</span>
                    <span class="column">address</span> <span class="datatype">NVARCHAR</span>(<span class="number">200</span>),
                    <span class="column">registration_date</span> <span class="datatype">DATE</span> <span class="keyword">DEFAULT</span> <span class="function">GETDATE</span>()
                );
                
                <span class="comment">-- Thêm dữ liệu hợp lệ</span>
                <span class="keyword">INSERT INTO</span> <span class="table">customers</span> (<span class="column">customer_name</span>, <span class="column">email</span>, <span class="column">phone_number</span>) 
                <span class="keyword">VALUES</span> 
                    (<span class="string">N'Nguyễn Văn A'</span>, <span class="string">'a@email.com'</span>, <span class="string">'0123456789'</span>),
                    (<span class="string">N'Trần Thị B'</span>, <span class="string">'b@email.com'</span>, <span class="string">'0987654321'</span>);
              </div>
              <p>
                Nếu bạn cố gắng thêm hai khách hàng có cùng địa chỉ email, hệ
                thống sẽ báo lỗi.
              </p>
            </div>

            <h3>👑 2. PRIMARY KEY (Khóa Chính)</h3>
            <p>
              <b>PRIMARY KEY</b> là một ràng buộc đặc biệt, được sử dụng để xác
              định duy nhất một hàng trong một bảng. Đây là một khái niệm cốt
              lõi trong cơ sở dữ liệu quan hệ.
            </p>

            <div class="info-box">
              <h4>📋 Tính chất của PRIMARY KEY:</h4>
              <ul>
                <li>
                  <b>Không cho phép NULL:</b> Một cột PRIMARY KEY phải chứa giá
                  trị, không thể để trống (NULL)
                </li>
                <li><b>Số lượng:</b> Một bảng chỉ có một PRIMARY KEY</li>
                <li>
                  <b>Tích hợp:</b> PRIMARY KEY về bản chất là sự kết hợp của
                  UNIQUE và NOT NULL
                </li>
                <li>
                  <b>Mục đích:</b> Nhận dạng duy nhất từng bản ghi trong bảng
                </li>
              </ul>
            </div>

            <div class="example">
              <h4>Ví dụ PRIMARY KEY:</h4>
              <p>
                Trong bảng <code>stores</code> (cửa hàng),
                <code>store_id</code> thường được chọn làm khóa chính vì mỗi cửa
                hàng sẽ có một ID duy nhất và không thể để trống.
              </p>
              <div class="code-block">
                <span class="keyword">CREATE TABLE</span> <span class="table">stores</span> (
                    <span class="column">store_id</span> <span class="datatype">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">PRIMARY KEY</span>, <span class="comment">-- store_id là khóa chính</span>
                    <span class="column">store_name</span> <span class="datatype">NVARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT NULL</span>,
                    <span class="column">manager_name</span> <span class="datatype">NVARCHAR</span>(<span class="number">100</span>),
                    <span class="column">location</span> <span class="datatype">NVARCHAR</span>(<span class="number">255</span>),
                    <span class="column">phone</span> <span class="datatype">VARCHAR</span>(<span class="number">20</span>),
                    <span class="column">opening_date</span> <span class="datatype">DATE</span> <span class="keyword">DEFAULT</span> <span class="function">GETDATE</span>()
                );
                
                <span class="comment">-- Thêm dữ liệu</span>
                <span class="keyword">INSERT INTO</span> <span class="table">stores</span> (<span class="column">store_name</span>, <span class="column">manager_name</span>) 
                <span class="keyword">VALUES</span> 
                    (<span class="string">N'Cửa hàng Quận 1'</span>, <span class="string">N'Nguyễn Văn Manager'</span>),
                    (<span class="string">N'Cửa hàng Hà Nội'</span>, <span class="string">N'Trần Thị Director'</span>);
              </div>
              <p>
                Nếu bạn cố gắng chèn hai cửa hàng với cùng
                <code>store_id</code> hoặc để trống <code>store_id</code>, hệ
                thống sẽ báo lỗi.
              </p>
            </div>

            <h3>📊 Tóm tắt sự khác biệt</h3>
            <table class="comparison-table">
              <thead>
                <tr>
                  <th>Đặc điểm</th>
                  <th>UNIQUE</th>
                  <th>PRIMARY KEY</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>Giá trị NULL</b></td>
                  <td>Cho phép giá trị NULL</td>
                  <td>Không cho phép giá trị NULL</td>
                </tr>
                <tr>
                  <td><b>Số lượng</b></td>
                  <td>Có thể có nhiều trong một bảng</td>
                  <td>Chỉ có một trong một bảng</td>
                </tr>
                <tr>
                  <td><b>Mục đích</b></td>
                  <td>
                    Đảm bảo duy nhất dữ liệu trong một cột hoặc một nhóm cột
                  </td>
                  <td>
                    Xác định duy nhất một hàng trong bảng (khóa nhận dạng)
                  </td>
                </tr>
                <tr>
                  <td><b>Tính chất</b></td>
                  <td>Là một ràng buộc duy nhất</td>
                  <td>Là sự kết hợp của UNIQUE và NOT NULL</td>
                </tr>
                <tr>
                  <td><b>Index tự động</b></td>
                  <td>Tạo index unique tự động</td>
                  <td>Tạo clustered index tự động (thường)</td>
                </tr>
                <tr>
                  <td><b>Sử dụng trong quan hệ</b></td>
                  <td>Có thể được tham chiếu bởi Foreign Key</td>
                  <td>Thường được tham chiếu bởi Foreign Key</td>
                </tr>
              </tbody>
            </table>

            <h3>🔧 Ví dụ minh họa cách sử dụng</h3>
            <div class="example">
              <h4>PRIMARY KEY của bảng stores:</h4>
              <p>
                <code>store_id</code> là PRIMARY KEY. Bạn sử dụng
                <code>store_id</code> để tham chiếu đến một cửa hàng cụ thể.
              </p>
              <div class="code-block">
                ALTER TABLE stores ADD CONSTRAINT pk_store_id PRIMARY KEY
                (store_id);
              </div>
            </div>

            <div class="example">
              <h4>UNIQUE của bảng customers:</h4>
              <p>
                <code>email</code> có thể là UNIQUE. Mỗi khách hàng có một email
                duy nhất, nhưng email đó không dùng để xác định toàn bộ hàng (vì
                có thể có nhiều khách hàng chưa có email).
              </p>
              <div class="code-block">
                ALTER TABLE customers ADD CONSTRAINT unique_email UNIQUE
                (email);
              </div>
            </div>

            <div class="example">
              <h4>Ví dụ tổng hợp - Bảng nhân viên:</h4>
              <div class="code-block">
                CREATE TABLE employees ( employee_id INT IDENTITY(1,1) PRIMARY
                KEY, -- Khóa chính để nhận dạng duy nhất employee_code
                VARCHAR(10) UNIQUE NOT NULL, -- Mã nhân viên duy nhất email
                VARCHAR(100) UNIQUE, -- Email duy nhất, có thể NULL
                social_security VARCHAR(12) UNIQUE, -- Số CMT/CCCD duy nhất
                employee_name NVARCHAR(100) NOT NULL, department_id INT,
                hire_date DATE DEFAULT GETDATE() ); -- Ví dụ chèn dữ liệu INSERT
                INTO employees (employee_code, email, social_security,
                employee_name, department_id) VALUES ('EMP001',
                'john.doe@company.com', '123456789012', N'Nguyễn Văn John', 1),
                ('EMP002', 'jane.smith@company.com', '123456789013', N'Trần Thị
                Jane', 2), ('EMP003', NULL, '123456789014', N'Phạm Văn Bob', 1);
                -- Email có thể NULL -- Tạo quan hệ với bảng khác CREATE TABLE
                timesheets ( timesheet_id INT IDENTITY(1,1) PRIMARY KEY,
                employee_id INT, -- Tham chiếu đến PRIMARY KEY của bảng
                employees work_date DATE, hours_worked DECIMAL(4,2), FOREIGN KEY
                (employee_id) REFERENCES employees(employee_id) );
              </div>
            </div>

            <div class="success-box">
              <h4>💡 Hướng dẫn lựa chọn:</h4>
              <ul>
                <li>
                  <b>Sử dụng PRIMARY KEY</b> khi bạn cần một cột để nhận dạng
                  duy nhất mỗi hàng trong bảng
                </li>
                <li>
                  <b>Sử dụng UNIQUE</b> khi bạn chỉ muốn đảm bảo dữ liệu trong
                  một cột không bị trùng lặp, nhưng không cần nó làm khóa nhận
                  dạng chính
                </li>
                <li>
                  <b>Có thể kết hợp:</b> Một bảng có thể có 1 PRIMARY KEY và
                  nhiều UNIQUE constraints
                </li>
                <li>
                  <b>Thiết kế tốt:</b> Mỗi bảng nên có PRIMARY KEY để đảm bảo
                  tính toàn vẹn dữ liệu
                </li>
              </ul>
            </div>

            <div class="highlight-box">
              <h4>⚠️ Lưu ý quan trọng:</h4>
              <ul>
                <li>
                  <b>PRIMARY KEY</b> thường được sử dụng làm Clustered Index,
                  ảnh hưởng đến cách lưu trữ vật lý
                </li>
                <li>
                  <b>UNIQUE</b> có thể có giá trị NULL, nhưng chỉ được phép một
                  giá trị NULL duy nhất trong một số hệ CSDL
                </li>
                <li>
                  <b>Foreign Key</b> có thể tham chiếu đến cột UNIQUE, không chỉ
                  PRIMARY KEY
                </li>
                <li>
                  <b>Hiệu suất:</b> Cả hai đều tạo index tự động, giúp tăng tốc
                  độ truy vấn
                </li>
              </ul>
            </div>
          </section>

          <!-- 9 -->
          <section class="section" id="index">
            <h2>9. Index</h2>

            <h3>📚 Index là gì?</h3>
            <p>
              <b>Index (chỉ mục)</b> là một cấu trúc dữ liệu đặc biệt được tạo
              trên một cột (hoặc nhiều cột) của bảng để tăng tốc độ tìm kiếm và
              truy xuất dữ liệu. Bạn có thể hình dung nó giống như
              <b>mục lục của một cuốn sách</b>: thay vì phải đọc toàn bộ cuốn
              sách (quét toàn bộ bảng) để tìm một từ khóa, bạn chỉ cần tra cứu
              mục lục (index) để biết từ khóa đó ở trang nào, từ đó tiết kiệm
              thời gian đáng kể.
            </p>

            <div class="info-box">
              <h4>⚙️ Cách hoạt động của Index:</h4>
              <p>
                Khi một index được tạo, hệ thống cơ sở dữ liệu sẽ
                <b>sắp xếp các giá trị</b> của cột đó và lưu trữ chúng cùng với
                <b>con trỏ (pointer)</b> đến vị trí của các hàng dữ liệu tương
                ứng.
              </p>
            </div>

            <h3>🗂️ Các loại Index phổ biến</h3>
            <p>
              Có nhiều loại index khác nhau, mỗi loại có cách hoạt động và mục
              đích sử dụng riêng:
            </p>

            <h4>1. Clustered Index</h4>
            <div class="highlight-box">
              <ul>
                <li>
                  <b>Sắp xếp thứ tự vật lý</b> của các hàng dữ liệu trong bảng
                </li>
                <li>Một bảng <b>chỉ có thể có một</b> Clustered Index</li>
                <li>Đây thường là <b>khóa chính (PRIMARY KEY)</b> của bảng</li>
                <li>
                  <b>Ví dụ:</b> Nếu một bảng được tạo với PRIMARY KEY, SQL
                  Server sẽ tự động tạo một Clustered Index trên cột đó
                </li>
              </ul>
            </div>

            <h4>2. Non-clustered Index</h4>
            <div class="highlight-box">
              <ul>
                <li><b>Không sắp xếp thứ tự vật lý</b> của dữ liệu</li>
                <li>
                  Tạo ra một <b>cấu trúc riêng biệt</b> (như cây B-tree) để lưu
                  trữ các giá trị đã sắp xếp
                </li>
                <li>Một bảng có thể có <b>nhiều Non-clustered Index</b></li>
                <li>
                  <b>Ví dụ:</b> Một index trên cột email của bảng customers
                </li>
              </ul>
            </div>

            <h4>3. Single-column Index</h4>
            <div class="highlight-box">
              <ul>
                <li>Chỉ được tạo trên <b>một cột duy nhất</b></li>
                <li>
                  <b>Ví dụ:</b>
                  <code
                    >CREATE INDEX idx_customer_name ON
                    customers(last_name);</code
                  >
                </li>
              </ul>
            </div>

            <h4>4. Composite Index (Multi-column Index)</h4>
            <div class="highlight-box">
              <ul>
                <li>Được tạo trên <b>hai hoặc nhiều cột</b></li>
                <li>
                  Tăng tốc độ tìm kiếm khi các câu lệnh WHERE hoặc ORDER BY sử
                  dụng <b>kết hợp các cột này</b>
                </li>
                <li>
                  <b>Ví dụ:</b>
                  <code
                    >CREATE INDEX idx_emp_name_dept ON employees(first_name,
                    department_id);</code
                  >
                </li>
              </ul>
            </div>

            <div class="info-box">
              <h4>⚠️ Lưu ý về Composite Index:</h4>
              <p>
                <b>Thứ tự các cột</b> trong Composite Index rất quan trọng. Ví
                dụ, index trên <code>(last_name, first_name)</code> có thể giúp
                tìm kiếm theo <code>last_name</code> hoặc
                <code>(last_name, first_name)</code>, nhưng sẽ
                <b>không hiệu quả</b> khi chỉ tìm kiếm theo
                <code>first_name</code>.
              </p>
            </div>

            <h4>5. Unique Index</h4>
            <div class="highlight-box">
              <ul>
                <li>
                  Giống như ràng buộc UNIQUE, nó đảm bảo rằng tất cả các giá trị
                  trong cột được lập chỉ mục là <b>duy nhất</b>
                </li>
                <li>
                  Thường được tạo <b>tự động</b> khi bạn định nghĩa một cột là
                  PRIMARY KEY hoặc UNIQUE
                </li>
              </ul>
            </div>

            <h3>🔧 Cú pháp và ví dụ</h3>
            <div class="example">
              <h4>Cú pháp cơ bản:</h4>
              <div class="code-block">
                <span class="keyword">CREATE INDEX</span> <span class="column">index_name</span> <span class="keyword">ON</span> <span class="table">table_name</span>(<span class="column">column1</span>, <span class="column">column2</span>, ...);
              </div>
            </div>

            <div class="example">
              <h4>Ví dụ 1: Tạo index đơn cột</h4>
              <p>
                Tạo một index đơn cột trên cột <code>last_name</code> của bảng
                <code>customers</code>:
              </p>
              <div class="code-block">
                <span class="keyword">CREATE INDEX</span> <span class="column">idx_customer_name</span> <span class="keyword">ON</span> <span class="table">customers</span>(<span class="column">last_name</span>);
                
                <span class="comment">-- Truy vấn sẽ nhanh hơn:</span>
                <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="table">customers</span> 
                <span class="keyword">WHERE</span> <span class="column">last_name</span> <span class="operator">=</span> <span class="string">N'Nguyễn'</span>;
              </div>
            </div>

            <div class="example">
              <h4>Ví dụ 2: Tạo index kết hợp</h4>
              <p>
                Tạo một index kết hợp trên hai cột <code>first_name</code> và
                <code>department_id</code> của bảng <code>employees</code>:
              </p>
              <div class="code-block">
                <span class="keyword">CREATE INDEX</span> <span class="column">idx_name_department</span> <span class="keyword">ON</span> <span class="table">employees</span>(<span class="column">first_name</span>, <span class="column">department_id</span>);
                
                <span class="comment">-- Index này sẽ giúp tăng tốc các truy vấn như:</span>
                <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="table">employees</span> 
                <span class="keyword">WHERE</span> <span class="column">first_name</span> <span class="operator">=</span> <span class="string">N'Văn'</span> <span class="keyword">AND</span> <span class="column">department_id</span> <span class="operator">=</span> <span class="number">10</span>;
                
                <span class="comment">-- Hoặc chỉ tìm theo first_name (cột đầu tiên của index):</span>
                <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="table">employees</span> 
                <span class="keyword">WHERE</span> <span class="column">first_name</span> <span class="operator">=</span> <span class="string">N'Văn'</span>;
                
                <span class="comment">-- Nhưng KHÔNG hiệu quả cho truy vấn chỉ theo department_id:
                -- SELECT * FROM employees WHERE department_id = 10; -- Không tối ưu</span>
              </div>
            </div>

            <div class="example">
              <h4>Ví dụ 3: Tạo Unique Index</h4>
              <div class="code-block">
                -- Tạo unique index trên cột email CREATE UNIQUE INDEX
                idx_unique_email ON customers(email); -- Hoặc tạo unique index
                kết hợp CREATE UNIQUE INDEX idx_unique_product_code ON
                products(product_code, supplier_id);
              </div>
            </div>

            <div class="example">
              <h4>Ví dụ 4: Xóa Index</h4>
              <div class="code-block">
                -- Xóa index khi không còn cần thiết DROP INDEX
                idx_customer_name ON customers; -- Hoặc trong SQL Server 2016+:
                DROP INDEX customers.idx_customer_name;
              </div>
            </div>

            <h3>🎯 Khi nào nên dùng Index?</h3>
            <div class="success-box">
              <h4>✅ NÊN tạo Index khi:</h4>
              <ul>
                <li>
                  <b>Trên các cột được sử dụng thường xuyên</b> trong các câu
                  lệnh WHERE, JOIN và ORDER BY
                </li>
                <li>
                  <b>Trên các cột có nhiều giá trị khác nhau</b> (tính độc lập
                  cao)
                </li>
                <li><b>Khi tốc độ đọc dữ liệu quan trọng hơn tốc độ ghi</b></li>
                <li>Trên các cột thường xuyên được sắp xếp (ORDER BY)</li>
                <li>Trên các cột tham gia vào JOIN</li>
              </ul>
            </div>

            <div class="info-box">
              <h4>❌ KHÔNG nên tạo Index khi:</h4>
              <ul>
                <li>Bảng có <b>ít dữ liệu</b> (dưới 1000 hàng)</li>
                <li>
                  Cột có <b>ít giá trị khác nhau</b> (ví dụ: cột giới tính chỉ
                  có Nam/Nữ)
                </li>
                <li>
                  Bảng có <b>nhiều thao tác INSERT, UPDATE, DELETE</b> hơn
                  SELECT
                </li>
                <li>Cột <b>ít khi được sử dụng</b> trong WHERE hoặc JOIN</li>
              </ul>
            </div>

            <h3>📊 Ví dụ thực tế: Hiệu quả của Index</h3>
            <div class="example">
              <h4>So sánh hiệu suất với và không có Index:</h4>
              <div class="code-block">
                <span class="comment">-- Tạo bảng mẫu với dữ liệu lớn</span>
                <span class="keyword">CREATE TABLE</span> <span class="table">sales_records</span> (
                    <span class="column">sale_id</span> <span class="datatype">INT</span> <span class="keyword">IDENTITY</span>(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">PRIMARY KEY</span>,
                    <span class="column">customer_id</span> <span class="datatype">INT</span>,
                    <span class="column">product_id</span> <span class="datatype">INT</span>,
                    <span class="column">sale_date</span> <span class="datatype">DATE</span>,
                    <span class="column">amount</span> <span class="datatype">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),
                    <span class="column">region</span> <span class="datatype">NVARCHAR</span>(<span class="number">50</span>)
                );
                
                <span class="comment">-- Chèn 100,000 bản ghi mẫu
                -- INSERT INTO sales_records ... (giả sử có 100k records)</span>
                
                <span class="comment">-- TRƯỚC khi tạo index - chậm (Table Scan)</span>
                <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="table">sales_records</span> 
                <span class="keyword">WHERE</span> <span class="column">customer_id</span> <span class="operator">=</span> <span class="number">12345</span> <span class="keyword">AND</span> <span class="column">sale_date</span> <span class="operator">>=</span> <span class="string">'2025-01-01'</span>;
                
                <span class="comment">-- Tạo index phù hợp</span>
                <span class="keyword">CREATE INDEX</span> <span class="column">idx_customer_date</span> <span class="keyword">ON</span> <span class="table">sales_records</span>(<span class="column">customer_id</span>, <span class="column">sale_date</span>);
                
                <span class="comment">-- SAU khi tạo index - nhanh hơn nhiều (Index Seek)</span>
                <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="table">sales_records</span> 
                <span class="keyword">WHERE</span> <span class="column">customer_id</span> <span class="operator">=</span> <span class="number">12345</span> <span class="keyword">AND</span> <span class="column">sale_date</span> <span class="operator">>=</span> <span class="string">'2025-01-01'</span>;
              </div>
            </div>

            <h3>🔍 Kiểm tra và quản lý Index</h3>
            <div class="example">
              <h4>Xem các index hiện có:</h4>
              <div class="code-block">
                -- Xem tất cả index của một bảng SELECT i.name AS IndexName,
                i.type_desc AS IndexType, c.name AS ColumnName FROM sys.indexes
                i INNER JOIN sys.index_columns ic ON i.object_id = ic.object_id
                AND i.index_id = ic.index_id INNER JOIN sys.columns c ON
                ic.object_id = c.object_id AND ic.column_id = c.column_id WHERE
                i.object_id = OBJECT_ID('customers') ORDER BY i.name,
                ic.key_ordinal;
              </div>
            </div>

            <div class="highlight-box">
              <h4>⚠️ Lưu ý quan trọng về Index:</h4>
              <ul>
                <li>
                  <b>Index làm chậm các thao tác ghi:</b> INSERT, UPDATE và
                  DELETE vì hệ thống phải cập nhật cả bảng dữ liệu và cấu trúc
                  index
                </li>
                <li>
                  <b>Index chiếm dung lượng:</b> Mỗi index tạo thêm sử dụng thêm
                  không gian lưu trữ
                </li>
                <li>
                  <b>Quá nhiều index có thể phản tác dụng:</b> Nên chỉ tạo index
                  trên các cột thực sự cần thiết
                </li>
                <li>
                  <b>Index cần được bảo trì:</b> Định kỳ rebuild hoặc reorganize
                  để duy trì hiệu suất
                </li>
              </ul>
            </div>
          </section>

          <!-- 10 -->
          <section class="section" id="sql-order">
            <h2>10. Thứ tự thực thi SQL</h2>

            <div class="info-box">
              <h4>📋 Thứ tự thực thi SQL:</h4>
              <p>
                Hiểu rõ thứ tự thực thi SQL giúp bạn viết câu lệnh hiệu quả và
                tránh lỗi logic. SQL được thực thi theo thứ tự sau,
                <b>không phải theo thứ tự viết</b>:
              </p>
              <ol>
                <li><b>FROM / JOIN</b> - Xác định và nối các bảng</li>
                <li><b>WHERE</b> - Lọc các hàng</li>
                <li><b>GROUP BY</b> - Nhóm các hàng</li>
                <li><b>HAVING</b> - Lọc các nhóm</li>
                <li><b>SELECT</b> - Chọn cột và tính toán</li>
                <li><b>ORDER BY</b> - Sắp xếp kết quả</li>
              </ol>
            </div>

            <h3>🔍 Chi tiết từng bước thực thi</h3>

            <h4>1️⃣ FROM / JOIN</h4>
            <div class="highlight-box">
              <p>
                <b>FROM</b> là bước đầu tiên. Nó xác định các bảng mà bạn sẽ làm
                việc.
              </p>
              <p>
                <b>JOIN</b> kết hợp các hàng từ hai hoặc nhiều bảng dựa trên một
                cột liên quan giữa chúng.
              </p>
              <div class="code-block">
                FROM customers c JOIN orders o ON c.customer_id = o.customer_id
              </div>
              <p>
                <b>Kết quả:</b> Bước này sẽ tạo ra một tập hợp dữ liệu lớn bằng
                cách nối bảng <code>customers</code> và <code>orders</code> lại
                với nhau.
              </p>
            </div>

            <h4>2️⃣ WHERE</h4>
            <div class="highlight-box">
              <p>
                Lọc các hàng từ tập hợp dữ liệu được tạo ở bước FROM/JOIN. Chỉ
                những hàng thỏa mãn điều kiện WHERE mới được giữ lại.
              </p>
              <div class="code-block">WHERE o.order_date >= '2024-01-01'</div>
              <p>
                <b>Kết quả:</b> Bước này sẽ lọc ra chỉ những đơn hàng được đặt
                từ ngày 01/01/2024 trở đi.
              </p>
            </div>

            <h4>3️⃣ GROUP BY</h4>
            <div class="highlight-box">
              <p>
                Nhóm các hàng có cùng giá trị trong một hoặc nhiều cột thành các
                nhóm tổng hợp.
              </p>
              <div class="code-block">
                <span class="keyword">GROUP BY</span> <span class="column">c.customer_id</span>, <span class="column">c.first_name</span>, <span class="column">c.last_name</span>
              </div>
              <p>
                <b>Kết quả:</b> Bước này sẽ nhóm tất cả các hàng của cùng một
                khách hàng lại với nhau, dựa trên ID, tên và họ của họ.
              </p>
            </div>

            <h4>4️⃣ HAVING</h4>
            <div class="highlight-box">
              <p>
                Lọc các nhóm được tạo ra ở bước GROUP BY dựa trên một điều kiện
                tổng hợp (ví dụ: COUNT, SUM, AVG).
              </p>
              <div class="code-block">
                <span class="keyword">HAVING</span> <span class="function">COUNT</span>(<span class="column">o.order_id</span>) <span class="operator">></span> <span class="number">2</span></div>
              <p>
                <b>Kết quả:</b> Bước này sẽ lọc ra chỉ những nhóm khách hàng đã
                đặt nhiều hơn 2 đơn hàng.
              </p>
              <p>
                <b>Lưu ý:</b> Bạn không thể sử dụng WHERE cho điều kiện này vì
                nó chỉ áp dụng cho từng hàng riêng lẻ, không phải cho các nhóm.
              </p>
            </div>

            <h4>5️⃣ SELECT</h4>
            <div class="highlight-box">
              <p>
                Bước này chọn các cột bạn muốn hiển thị trong kết quả cuối cùng.
                Các hàm tổng hợp (COUNT, SUM, AVG) được tính toán ở đây.
              </p>
              <div class="code-block">
                SELECT c.customer_id, c.first_name, c.last_name,
                COUNT(o.order_id) AS total_orders
              </div>
              <p>
                <b>Kết quả:</b> Bước này sẽ chọn các cột customer_id,
                first_name, last_name và tính tổng số đơn hàng
                (COUNT(o.order_id)) cho mỗi nhóm.
              </p>
            </div>

            <h4>6️⃣ ORDER BY</h4>
            <div class="highlight-box">
              <p>Sắp xếp thứ tự các hàng cuối cùng của kết quả.</p>
              <div class="code-block">ORDER BY total_orders DESC</div>
              <p>
                <b>Kết quả:</b> Bước này sẽ sắp xếp kết quả theo cột
                total_orders theo thứ tự giảm dần, hiển thị khách hàng có nhiều
                đơn hàng nhất lên đầu.
              </p>
            </div>

            <h3>📋 Ví dụ đầy đủ</h3>
            <div class="example">
              <h4>Câu lệnh SQL phức tạp:</h4>
              <div class="code-block">
                <span class="keyword">SELECT</span> <span class="column">c.customer_id</span>, <span class="column">c.first_name</span>, <span class="column">c.last_name</span>,
                       <span class="function">COUNT</span>(<span class="column">o.order_id</span>) <span class="keyword">AS</span> <span class="column">total_orders</span>
                <span class="keyword">FROM</span> <span class="table">customers</span> <span class="column">c</span>
                <span class="keyword">JOIN</span> <span class="table">orders</span> <span class="column">o</span> <span class="keyword">ON</span> <span class="column">c.customer_id</span> <span class="operator">=</span> <span class="column">o.customer_id</span>
                <span class="keyword">WHERE</span> <span class="column">o.order_date</span> <span class="operator">>=</span> <span class="string">'2024-01-01'</span>
                <span class="keyword">GROUP BY</span> <span class="column">c.customer_id</span>, <span class="column">c.first_name</span>, <span class="column">c.last_name</span>
                <span class="keyword">HAVING</span> <span class="function">COUNT</span>(<span class="column">o.order_id</span>) <span class="operator">></span> <span class="number">2</span>
                <span class="keyword">ORDER BY</span> <span class="column">total_orders</span> <span class="keyword">DESC</span>;
              </div>
            </div>

            <h3>🔄 Thứ tự thực thi chi tiết của ví dụ trên</h3>
            <div class="success-box">
              <ol>
                <li>
                  <b>FROM / JOIN:</b> Nối bảng customers (được đặt tên là c) và
                  orders (được đặt tên là o) lại với nhau.
                </li>
                <li>
                  <b>WHERE:</b> Lọc các hàng từ kết quả nối chỉ những đơn hàng
                  có ngày đặt từ 2024-01-01 trở đi.
                </li>
                <li>
                  <b>GROUP BY:</b> Nhóm các hàng còn lại theo từng khách hàng.
                </li>
                <li>
                  <b>HAVING:</b> Lọc các nhóm, chỉ giữ lại những nhóm có số
                  lượng đơn hàng lớn hơn 2.
                </li>
                <li>
                  <b>SELECT:</b> Chọn các cột customer_id, first_name, last_name
                  và tính tổng số đơn hàng cho mỗi nhóm.
                </li>
                <li>
                  <b>ORDER BY:</b> Sắp xếp kết quả cuối cùng theo tổng số đơn
                  hàng giảm dần.
                </li>
              </ol>
            </div>

            <h3>💡 Ví dụ minh họa từng bước</h3>
            <div class="example">
              <h4>Dữ liệu mẫu:</h4>
              <div class="code-block">
                -- Bảng customers customer_id | first_name | last_name 1 |
                Nguyễn | Văn A 2 | Trần | Thị B 3 | Lê | Văn C -- Bảng orders
                order_id | customer_id | order_date 101 | 1 | 2024-02-01 102 | 1
                | 2024-03-01 103 | 1 | 2024-04-01 104 | 2 | 2024-01-15 105 | 2 |
                2024-02-15 106 | 3 | 2023-12-01 -- Trước 2024-01-01
              </div>
            </div>

            <div class="example">
              <h4>Kết quả sau từng bước:</h4>
              <div class="code-block">
                -- Bước 1 (FROM/JOIN): Nối 2 bảng customer_id | first_name |
                last_name | order_id | order_date 1 | Nguyễn | Văn A | 101 |
                2024-02-01 1 | Nguyễn | Văn A | 102 | 2024-03-01 1 | Nguyễn |
                Văn A | 103 | 2024-04-01 2 | Trần | Thị B | 104 | 2024-01-15 2 |
                Trần | Thị B | 105 | 2024-02-15 3 | Lê | Văn C | 106 |
                2023-12-01 -- Bước 2 (WHERE): Lọc order_date >= '2024-01-01'
                customer_id | first_name | last_name | order_id | order_date 1 |
                Nguyễn | Văn A | 101 | 2024-02-01 1 | Nguyễn | Văn A | 102 |
                2024-03-01 1 | Nguyễn | Văn A | 103 | 2024-04-01 2 | Trần | Thị
                B | 104 | 2024-01-15 2 | Trần | Thị B | 105 | 2024-02-15 -- Bước
                3 (GROUP BY): Nhóm theo customer Nhóm 1: customer_id=1,
                first_name=Nguyễn, last_name=Văn A (3 đơn hàng) Nhóm 2:
                customer_id=2, first_name=Trần, last_name=Thị B (2 đơn hàng) --
                Bước 4 (HAVING): Lọc COUNT > 2 Chỉ giữ Nhóm 1 (3 đơn hàng > 2)
                -- Bước 5 (SELECT): Chọn cột và tính COUNT customer_id |
                first_name | last_name | total_orders 1 | Nguyễn | Văn A | 3 --
                Bước 6 (ORDER BY): Sắp xếp (chỉ có 1 hàng nên không thay đổi)
                customer_id | first_name | last_name | total_orders 1 | Nguyễn |
                Văn A | 3
              </div>
            </div>

            <div class="info-box">
              <h4>🎯 Tại sao thứ tự này quan trọng?</h4>
              <ul>
                <li>
                  <b>Hiệu suất:</b> Hiểu thứ tự giúp tối ưu hóa câu lệnh (ví dụ:
                  WHERE trước GROUP BY giúp giảm dữ liệu cần nhóm)
                </li>
                <li>
                  <b>Tránh lỗi:</b> Biết được tại sao không thể dùng alias trong
                  WHERE nhưng có thể dùng trong ORDER BY
                </li>
                <li>
                  <b>Logic đúng:</b> Đảm bảo kết quả chính xác khi viết câu lệnh
                  phức tạp
                </li>
                <li>
                  <b>Debug:</b> Dễ dàng tìm lỗi khi câu lệnh không cho kết quả
                  mong muốn
                </li>
              </ul>
            </div>

            <div class="highlight-box">
              <h4>⚠️ Lưu ý quan trọng:</h4>
              <ul>
                <li>
                  <b>Alias:</b> Không thể sử dụng alias của SELECT trong WHERE,
                  nhưng có thể dùng trong ORDER BY
                </li>
                <li>
                  <b>Aggregate functions:</b> Chỉ có thể dùng trong SELECT và
                  HAVING, không dùng được trong WHERE
                </li>
                <li>
                  <b>Performance:</b> WHERE thực thi trước GROUP BY nên hiệu quả
                  hơn HAVING cho điều kiện không phải aggregate
                </li>
              </ul>
            </div>
          </section>

          <!-- 11 -->
          <section class="section" id="where-having">
            <h2>11. WHERE vs HAVING</h2>

            <div class="info-box">
              <h4>🔍 Khái niệm cơ bản:</h4>
              <p>
                <b>WHERE</b> và <b>HAVING</b> đều là các mệnh đề lọc trong SQL,
                nhưng chúng hoạt động ở các giai đoạn khác nhau trong quá trình
                thực thi câu lệnh và có mục đích sử dụng riêng biệt.
              </p>
            </div>

            <h3>🎯 1. WHERE</h3>
            <div class="highlight-box">
              <p>
                <b>WHERE</b> là mệnh đề được sử dụng để lọc các
                <b>hàng riêng lẻ (individual rows)</b> trước khi chúng được nhóm
                bằng GROUP BY.
              </p>
              <ul>
                <li><b>Vị trí:</b> Đặt sau mệnh đề FROM hoặc JOIN</li>
                <li>
                  <b>Chức năng:</b> Lọc dữ liệu dựa trên các điều kiện về cột
                  thông thường
                </li>
                <li>
                  <b>Hạn chế:</b> Không thể sử dụng các hàm tổng hợp như
                  COUNT(), SUM(), AVG() trực tiếp trong mệnh đề WHERE
                </li>
              </ul>
            </div>

            <div class="example">
              <h4>Ví dụ WHERE:</h4>
              <p>
                Giả sử bạn muốn tìm số lượng sản phẩm trong kho của các cửa
                hàng, nhưng chỉ quan tâm đến những sản phẩm có giá lớn hơn 100.
              </p>
              <div class="code-block">
                <span class="keyword">SELECT</span>
                <span class="column">store_id</span>,
                <span class="function">COUNT</span>(<span class="column"
                  >product_id</span
                >) <span class="keyword">AS</span>
                <span class="column">total_products</span>
                <span class="keyword">FROM</span>
                <span class="table">stocks</span>
                <span class="keyword">WHERE</span>
                <span class="column">price</span>
                <span class="operator">></span> <span class="number">100</span>
                <span class="keyword">GROUP BY</span>
                <span class="column">store_id</span>;
              </div>
              <p>
                <b>Giải thích:</b> Trong ví dụ này, WHERE sẽ loại bỏ các sản
                phẩm có giá nhỏ hơn hoặc bằng 100 khỏi tập dữ liệu ban đầu, sau
                đó GROUP BY mới nhóm các sản phẩm còn lại.
              </p>
            </div>

            <h3>📊 2. HAVING</h3>
            <div class="highlight-box">
              <p>
                <b>HAVING</b> là mệnh đề được sử dụng để lọc các
                <b>nhóm (groups)</b> dữ liệu sau khi chúng đã được tạo ra bởi
                GROUP BY.
              </p>
              <ul>
                <li><b>Vị trí:</b> Đặt sau mệnh đề GROUP BY</li>
                <li>
                  <b>Chức năng:</b> Lọc các nhóm dựa trên các điều kiện của các
                  hàm tổng hợp (COUNT, SUM, AVG, v.v.)
                </li>
                <li>
                  <b>Yêu cầu:</b> Bạn không thể sử dụng HAVING nếu không có
                  GROUP BY
                </li>
              </ul>
            </div>

            <div class="example">
              <h4>Ví dụ HAVING:</h4>
              <p>
                Giả sử bạn muốn tìm các cửa hàng có tổng số sản phẩm trong kho
                lớn hơn 10.
              </p>
              <div class="code-block">
                <span class="keyword">SELECT</span> <span class="column">store_id</span>, <span class="function">COUNT</span>(<span class="column">product_id</span>) <span class="keyword">AS</span> <span class="column">total_products</span> 
                <span class="keyword">FROM</span> <span class="table">stocks</span>
                <span class="keyword">GROUP BY</span> <span class="column">store_id</span> 
                <span class="keyword">HAVING</span> <span class="function">COUNT</span>(<span class="column">product_id</span>) <span class="operator">></span> <span class="number">10</span>; <span class="comment">-- Lọc các nhóm có tổng số sản phẩm > 10</span>
              </div>
              <p>
                <b>Giải thích:</b> Ở đây, GROUP BY sẽ nhóm các sản phẩm theo
                store_id trước, sau đó HAVING sẽ kiểm tra từng nhóm và chỉ giữ
                lại những nhóm có tổng số sản phẩm lớn hơn 10.
              </p>
            </div>

            <h3>📋 Tóm tắt sự khác biệt</h3>
            <table class="comparison-table">
              <thead>
                <tr>
                  <th>Đặc điểm</th>
                  <th>WHERE</th>
                  <th>HAVING</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>Vị trí</b></td>
                  <td>Đặt trước GROUP BY</td>
                  <td>Đặt sau GROUP BY</td>
                </tr>
                <tr>
                  <td><b>Đối tượng lọc</b></td>
                  <td>Lọc hàng riêng lẻ</td>
                  <td>Lọc nhóm dữ liệu</td>
                </tr>
                <tr>
                  <td><b>Sử dụng hàm tổng hợp</b></td>
                  <td>Không thể sử dụng trực tiếp</td>
                  <td>Bắt buộc phải sử dụng</td>
                </tr>
                <tr>
                  <td><b>Mục đích</b></td>
                  <td>Lọc dữ liệu thô trước khi xử lý</td>
                  <td>Lọc kết quả đã được tổng hợp</td>
                </tr>
                <tr>
                  <td><b>Thứ tự thực thi</b></td>
                  <td>Thực thi thứ 2 (sau FROM/JOIN)</td>
                  <td>Thực thi thứ 4 (sau GROUP BY)</td>
                </tr>
                <tr>
                  <td><b>Hiệu suất</b></td>
                  <td>Hiệu quả hơn vì lọc sớm</td>
                  <td>Chậm hơn vì phải tính toán trước</td>
                </tr>
              </tbody>
            </table>

            <h3>🔧 Ví dụ đầy đủ</h3>
            <div class="example">
              <h4>Kịch bản: Tìm cửa hàng có nhiều sản phẩm giá rẻ</h4>
              <p>
                Giả sử bạn muốn tìm các cửa hàng có tổng số sản phẩm tồn kho lớn
                hơn 10 và chỉ tính những sản phẩm có giá dưới 5000:
              </p>
              <div class="code-block">
                <span class="keyword">SELECT</span> <span class="column">store_id</span>, <span class="function">COUNT</span>(<span class="column">product_id</span>) <span class="keyword">AS</span> <span class="column">total_products</span> 
                <span class="keyword">FROM</span> <span class="table">stocks</span>
                <span class="keyword">WHERE</span> <span class="column">price</span> <span class="operator"><</span> <span class="number">5000</span> <span class="comment">-- Bước 1: Lọc các hàng riêng lẻ (sản phẩm)</span>
                <span class="keyword">GROUP BY</span> <span class="column">store_id</span> 
                <span class="keyword">HAVING</span> <span class="function">COUNT</span>(<span class="column">product_id</span>) <span class="operator">></span> <span class="number">10</span>; <span class="comment">-- Bước 2: Lọc các nhóm (cửa hàng)</span>
              </div>
              <p><b>Quá trình thực thi:</b></p>
              <ol>
                <li>
                  <b>WHERE:</b> Loại bỏ các sản phẩm có giá >= 5000 ngay từ đầu
                </li>
                <li>
                  <b>GROUP BY:</b> Nhóm các sản phẩm còn lại theo store_id
                </li>
                <li>
                  <b>HAVING:</b> Chỉ giữ lại những cửa hàng có > 10 sản phẩm
                </li>
              </ol>
            </div>

            <h3>📈 Ví dụ minh họa chi tiết</h3>
            <div class="example">
              <h4>Dữ liệu mẫu bảng stocks:</h4>
              <div class="code-block">
                <span class="column">store_id</span> | <span class="column">product_id</span> | <span class="column">price</span> 
                <span class="number">1</span> | <span class="number">101</span> | <span class="number">3000</span> 
                <span class="number">1</span> | <span class="number">102</span> | <span class="number">7000</span> <span class="comment">-- Bị loại bỏ bởi WHERE</span> 
                <span class="number">1</span> | <span class="number">103</span> | <span class="number">4000</span> 
                <span class="number">1</span> | <span class="number">104</span> | <span class="number">2000</span> 
                <span class="number">2</span> | <span class="number">201</span> | <span class="number">4500</span> 
                <span class="number">2</span> | <span class="number">202</span> | <span class="number">6000</span> <span class="comment">-- Bị loại bỏ bởi WHERE</span> 
                <span class="number">3</span> | <span class="number">301</span> | <span class="number">1000</span> 
                <span class="number">3</span> | <span class="number">302</span> | <span class="number">2000</span>
              </div>
            </div>

            <div class="example">
              <h4>Kết quả từng bước:</h4>
              <div class="code-block">
                <span class="comment">-- Sau WHERE (price < 5000):</span>
                <span class="column">store_id</span> | <span class="column">product_id</span> | <span class="column">price</span> 
                <span class="number">1</span> | <span class="number">101</span> | <span class="number">3000</span> 
                <span class="number">1</span> | <span class="number">103</span> | <span class="number">4000</span> 
                <span class="number">1</span> | <span class="number">104</span> | <span class="number">2000</span> 
                <span class="number">2</span> | <span class="number">201</span> | <span class="number">4500</span> 
                <span class="number">3</span> | <span class="number">301</span> | <span class="number">1000</span> 
                <span class="number">3</span> | <span class="number">302</span> | <span class="number">2000</span>
                
                <span class="comment">-- Sau GROUP BY store_id:</span>
                <span class="column">store_id</span> | <span class="column">total_products</span> 
                <span class="number">1</span> | <span class="number">3</span> 
                <span class="number">2</span> | <span class="number">1</span> 
                <span class="number">3</span> | <span class="number">2</span>
                
                <span class="comment">-- Sau HAVING COUNT(product_id) > 10:</span>
                <span class="comment">(Không có kết quả vì không cửa hàng nào có > 10 sản phẩm)</span>
                
                <span class="comment">-- Nếu thay đổi điều kiện HAVING thành > 2:</span>
                <span class="column">store_id</span> | <span class="column">total_products</span> 
                <span class="number">1</span> | <span class="number">3</span>
              </div>
            </div>

            <h3>🚫 Lỗi thường gặp</h3>
            <div class="info-box">
              <h4>❌ Lỗi sử dụng hàm tổng hợp trong WHERE:</h4>
              <div class="code-block">
                <span class="comment">-- SAI: Không thể dùng COUNT() trong WHERE</span>
                <span class="keyword">SELECT</span> <span class="column">store_id</span>, <span class="function">COUNT</span>(<span class="column">product_id</span>) 
                <span class="keyword">FROM</span> <span class="table">stocks</span> 
                <span class="keyword">WHERE</span> <span class="function">COUNT</span>(<span class="column">product_id</span>) <span class="operator">></span> <span class="number">10</span> <span class="comment">-- LỖI!</span>
                <span class="keyword">GROUP BY</span> <span class="column">store_id</span>;
                
                <span class="comment">-- ĐÚNG: Phải dùng HAVING</span>
                <span class="keyword">SELECT</span> <span class="column">store_id</span>, <span class="function">COUNT</span>(<span class="column">product_id</span>) 
                <span class="keyword">FROM</span> <span class="table">stocks</span> 
                <span class="keyword">GROUP BY</span> <span class="column">store_id</span> 
                <span class="keyword">HAVING</span> <span class="function">COUNT</span>(<span class="column">product_id</span>) <span class="operator">></span> <span class="number">10</span>; <span class="comment">-- ĐÚNG!</span>
              </div>
            </div>

            <div class="info-box">
              <h4>❌ Lỗi sử dụng HAVING không có GROUP BY:</h4>
              <div class="code-block">
                <span class="comment">-- SAI: HAVING cần phải có GROUP BY</span>
                <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="table">stocks</span> 
                <span class="keyword">HAVING</span> <span class="column">price</span> <span class="operator">></span> <span class="number">1000</span>; <span class="comment">-- LỖI!</span>
                
                <span class="comment">-- ĐÚNG: Dùng WHERE cho điều kiện hàng đơn lẻ</span>
                <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="table">stocks</span> 
                <span class="keyword">WHERE</span> <span class="column">price</span> <span class="operator">></span> <span class="number">1000</span>; <span class="comment">-- ĐÚNG!</span>
              </div>
            </div>

            <h3>💡 Lời khuyên sử dụng</h3>
            <div class="success-box">
              <h4>✅ Best Practices:</h4>
              <ul>
                <li>
                  <b>Ưu tiên WHERE:</b> Sử dụng WHERE khi có thể để lọc dữ liệu
                  sớm, giảm tải xử lý
                </li>
                <li>
                  <b>HAVING cho aggregate:</b> Chỉ dùng HAVING khi cần lọc dựa
                  trên kết quả tổng hợp
                </li>
                <li>
                  <b>Kết hợp thông minh:</b> Có thể dùng cả WHERE và HAVING
                  trong cùng một câu lệnh
                </li>
                <li>
                  <b>Hiệu suất:</b> WHERE nhanh hơn HAVING vì lọc trước khi nhóm
                </li>
              </ul>
            </div>

            <div class="example">
              <h4>Ví dụ tối ưu:</h4>
              <div class="code-block">
                <span class="comment">-- Tìm cửa hàng có nhiều sản phẩm điện tử (category_id = 1) đắt tiền</span>
                <span class="keyword">SELECT</span> <span class="column">s.store_id</span>, <span class="column">s.store_name</span>, <span class="function">COUNT</span>(<span class="column">st.product_id</span>) <span class="keyword">AS</span> <span class="column">expensive_electronics</span> 
                <span class="keyword">FROM</span> <span class="table">stores</span> <span class="keyword">s</span> 
                <span class="keyword">JOIN</span> <span class="table">stocks</span> <span class="keyword">st</span> <span class="keyword">ON</span> <span class="column">s.store_id</span> <span class="operator">=</span> <span class="column">st.store_id</span> 
                <span class="keyword">JOIN</span> <span class="table">products</span> <span class="keyword">p</span> <span class="keyword">ON</span> <span class="column">st.product_id</span> <span class="operator">=</span> <span class="column">p.product_id</span> 
                <span class="keyword">WHERE</span> <span class="column">p.category_id</span> <span class="operator">=</span> <span class="number">1</span> <span class="comment">-- Lọc sản phẩm điện tử trước</span>
                  <span class="keyword">AND</span> <span class="column">st.price</span> <span class="operator">></span> <span class="number">10000</span> <span class="comment">-- Lọc sản phẩm đắt tiền trước</span>
                <span class="keyword">GROUP BY</span> <span class="column">s.store_id</span>, <span class="column">s.store_name</span> 
                <span class="keyword">HAVING</span> <span class="function">COUNT</span>(<span class="column">st.product_id</span>) <span class="operator">>=</span> <span class="number">5</span> <span class="comment">-- Lọc cửa hàng có >= 5 sản phẩm</span>
                <span class="keyword">ORDER BY</span> <span class="column">expensive_electronics</span> <span class="keyword">DESC</span>;
              </div>
            </div>
          </section>

          <!-- 12 -->
          <section class="section" id="union-merge">
            <h2>12. UNION, MERGE, PIVOT, INTERSECT</h2>

            <div class="info-box">
              <h4>🔄 Các phép toán tập hợp và xử lý dữ liệu:</h4>
              <p>
                Các lệnh này giúp bạn kết hợp, hợp nhất, xoay và tìm giao của
                các tập dữ liệu một cách hiệu quả. Mỗi lệnh có mục đích sử dụng
                riêng biệt trong xử lý dữ liệu.
              </p>
            </div>

            <h3>🔗 1. UNION (Kết hợp)</h3>
            <div class="highlight-box">
              <p>
                Lệnh <b>UNION</b> được sử dụng để kết hợp kết quả của hai hoặc
                nhiều câu lệnh SELECT thành một tập kết quả duy nhất.
              </p>

              <h4>📋 Đặc điểm:</h4>
              <ul>
                <li>Các câu lệnh SELECT phải có <b>cùng số cột</b></li>
                <li>
                  Các cột tương ứng phải có <b>cùng kiểu dữ liệu</b> hoặc kiểu
                  dữ liệu tương thích
                </li>
                <li><b>UNION</b> sẽ tự động loại bỏ các hàng trùng lặp</li>
                <li>
                  <b>UNION ALL</b> giữ lại tất cả các hàng (kể cả hàng trùng
                  lặp)
                </li>
              </ul>
            </div>

            <div class="example">
              <h4>Ví dụ UNION:</h4>
              <p>
                Giả sử bạn muốn xem danh sách tên sản phẩm từ hai danh mục khác
                nhau:
              </p>
              <div class="code-block">
                <span class="comment">-- UNION - Loại bỏ trùng lặp</span>
                <span class="keyword">SELECT</span> <span class="column">product_name</span> <span class="keyword">FROM</span> <span class="table">products</span>
                <span class="keyword">WHERE</span> <span class="column">category_id</span> <span class="operator">=</span> <span class="number">1</span> 
                <span class="keyword">UNION</span> 
                <span class="keyword">SELECT</span> <span class="column">product_name</span> <span class="keyword">FROM</span> <span class="table">products</span>
                <span class="keyword">WHERE</span> <span class="column">category_id</span> <span class="operator">=</span> <span class="number">2</span>;
                
                <span class="comment">-- UNION ALL - Giữ tất cả hàng</span>
                <span class="keyword">SELECT</span> <span class="column">product_name</span> <span class="keyword">FROM</span> <span class="table">products</span>
                <span class="keyword">WHERE</span> <span class="column">category_id</span> <span class="operator">=</span> <span class="number">1</span> 
                <span class="keyword">UNION ALL</span> 
                <span class="keyword">SELECT</span> <span class="column">product_name</span> <span class="keyword">FROM</span> <span class="table">products</span>
                <span class="keyword">WHERE</span> <span class="column">category_id</span> <span class="operator">=</span> <span class="number">2</span>;
              </div>
              <p>
                <b>Kết quả:</b> Trả về danh sách tất cả các sản phẩm thuộc cả
                hai danh mục 1 và 2. Nếu có sản phẩm nào xuất hiện ở cả hai danh
                mục thì với UNION nó sẽ chỉ được liệt kê một lần, với UNION ALL
                sẽ xuất hiện nhiều lần.
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ thực tế - Danh sách khách hàng VIP:</h4>
              <div class="code-block">
                <span class="comment">-- Kết hợp khách hàng có nhiều đơn hàng và khách hàng chi tiêu cao</span>
                <span class="keyword">SELECT</span> <span class="column">customer_id</span>, <span class="column">customer_name</span>, <span class="string">'Frequent Buyer'</span> <span class="keyword">AS</span> <span class="column">vip_type</span> 
                <span class="keyword">FROM</span> <span class="table">customers</span> <span class="keyword">c</span> 
                <span class="keyword">WHERE</span> (<span class="keyword">SELECT</span> <span class="function">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> <span class="table">orders</span>
                       <span class="keyword">WHERE</span> <span class="column">customer_id</span> <span class="operator">=</span> <span class="column">c.customer_id</span>) <span class="operator">></span> <span class="number">10</span> 
                <span class="keyword">UNION</span> 
                <span class="keyword">SELECT</span> <span class="column">customer_id</span>, <span class="column">customer_name</span>, <span class="string">'High Spender'</span> <span class="keyword">AS</span> <span class="column">vip_type</span> 
                <span class="keyword">FROM</span> <span class="table">customers</span> <span class="keyword">c</span> 
                <span class="keyword">WHERE</span> (<span class="keyword">SELECT</span> <span class="function">SUM</span>(<span class="column">total_amount</span>) <span class="keyword">FROM</span> <span class="table">orders</span> 
                       <span class="keyword">WHERE</span> <span class="column">customer_id</span> <span class="operator">=</span> <span class="column">c.customer_id</span>) <span class="operator">></span> <span class="number">100000</span>;
              </div>
            </div>

            <h3>🔄 2. MERGE (Hợp nhất)</h3>
            <div class="highlight-box">
              <p>
                Lệnh <b>MERGE</b> (còn được gọi là Upsert - Update or Insert)
                được sử dụng để thực hiện nhiều thao tác (INSERT, UPDATE,
                DELETE) trong một câu lệnh duy nhất. Nó so sánh một bảng nguồn
                với một bảng đích và thực hiện các hành động dựa trên sự khớp
                nhau của các hàng.
              </p>

              <h4>📋 Đặc điểm:</h4>
              <ul>
                <li>
                  Rất hữu ích cho việc <b>đồng bộ hóa dữ liệu</b> giữa hai bảng
                </li>
                <li>
                  Giúp giảm thiểu việc phải viết nhiều câu lệnh INSERT, UPDATE,
                  DELETE riêng lẻ
                </li>
                <li>
                  Chỉ có trong một số hệ quản trị cơ sở dữ liệu như
                  <b>SQL Server, Oracle</b>
                </li>
                <li>
                  Thực hiện nguyên tử (atomic) - tất cả thay đổi được commit
                  hoặc rollback cùng nhau
                </li>
              </ul>
            </div>

            <div class="example">
              <h4>Ví dụ MERGE cơ bản:</h4>
              <p>
                Giả sử bạn có một bảng stocks hiện tại và một bảng tạm
                new_stocks với các cập nhật:
              </p>
              <div class="code-block">
                <span class="keyword">MERGE INTO</span> <span class="table">stocks</span> <span class="keyword">AS</span> <span class="keyword">target</span> <span class="comment">-- Bảng đích</span>
                <span class="keyword">USING</span> <span class="table">new_stocks</span> <span class="keyword">AS</span> <span class="keyword">source</span> <span class="comment">-- Bảng nguồn</span>
                <span class="keyword">ON</span> <span class="column">target.product_id</span> <span class="operator">=</span> <span class="column">source.product_id</span> <span class="comment">-- Điều kiện khớp</span>
                <span class="keyword">WHEN MATCHED THEN</span> 
                  <span class="keyword">UPDATE SET</span> 
                    <span class="column">target.quantity</span> <span class="operator">=</span> <span class="column">source.quantity</span>,
                    <span class="column">target.last_updated</span> <span class="operator">=</span> <span class="function">GETDATE</span>()
                <span class="keyword">WHEN NOT MATCHED BY TARGET THEN</span> 
                  <span class="keyword">INSERT</span> (<span class="column">product_id</span>, <span class="column">quantity</span>, <span class="column">last_updated</span>)
                  <span class="keyword">VALUES</span> (<span class="column">source.product_id</span>, <span class="column">source.quantity</span>, <span class="function">GETDATE</span>())
                <span class="keyword">WHEN NOT MATCHED BY SOURCE THEN</span> 
                  <span class="keyword">DELETE</span>; <span class="comment">-- Xóa sản phẩm không còn trong nguồn</span>
              </div>
              <p>
                <b>Giải thích:</b> Lệnh này sẽ kiểm tra từng sản phẩm trong
                new_stocks: nếu tìm thấy sản phẩm đó trong stocks thì cập nhật
                số lượng, nếu không thì thêm mới, và xóa những sản phẩm không
                còn trong bảng nguồn.
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ thực tế - Đồng bộ thông tin nhân viên:</h4>
              <div class="code-block">
                <span class="keyword">MERGE</span> <span class="table">employees</span> <span class="keyword">AS</span> <span class="keyword">target</span> 
                <span class="keyword">USING</span> <span class="table">employee_updates</span> <span class="keyword">AS</span> <span class="keyword">source</span> 
                <span class="keyword">ON</span> <span class="column">target.employee_id</span> <span class="operator">=</span> <span class="column">source.employee_id</span> 
                <span class="keyword">WHEN MATCHED AND</span> <span class="column">source.action</span> <span class="operator">=</span> <span class="string">'UPDATE'</span> <span class="keyword">THEN</span> 
                  <span class="keyword">UPDATE SET</span> 
                    <span class="column">target.salary</span> <span class="operator">=</span> <span class="column">source.salary</span>,
                    <span class="column">target.department_id</span> <span class="operator">=</span> <span class="column">source.department_id</span>,
                    <span class="column">target.updated_date</span> <span class="operator">=</span> <span class="function">GETDATE</span>()
                <span class="keyword">WHEN MATCHED AND</span> <span class="column">source.action</span> <span class="operator">=</span> <span class="string">'DELETE'</span> <span class="keyword">THEN</span> 
                  <span class="keyword">DELETE</span> 
                <span class="keyword">WHEN NOT MATCHED AND</span> <span class="column">source.action</span> <span class="operator">=</span> <span class="string">'INSERT'</span> <span class="keyword">THEN</span> 
                  <span class="keyword">INSERT</span> (<span class="column">employee_id</span>, <span class="column">employee_name</span>, <span class="column">salary</span>, <span class="column">department_id</span>, <span class="column">hire_date</span>)
                  <span class="keyword">VALUES</span> (<span class="column">source.employee_id</span>, <span class="column">source.employee_name</span>, <span class="column">source.salary</span>, 
                          <span class="column">source.department_id</span>, <span class="function">GETDATE</span>());
              </div>
            </div>

            <h3>🔄 3. PIVOT (Xoay bảng)</h3>
            <div class="highlight-box">
              <p>
                Lệnh <b>PIVOT</b> xoay các giá trị duy nhất từ một cột thành các
                tiêu đề cột (column headings) và thực hiện các phép tính tổng
                hợp trên chúng.
              </p>

              <h4>📋 Đặc điểm:</h4>
              <ul>
                <li>
                  <b>Chuyển đổi hàng thành cột</b> - biến dữ liệu dọc thành dữ
                  liệu ngang
                </li>
                <li>Rất hữu ích cho việc <b>tạo báo cáo tóm tắt</b></li>
                <li>
                  PIVOT là một hàm riêng trong <b>SQL Server và Oracle</b>
                </li>
                <li>Cần xác định trước các giá trị sẽ thành cột</li>
              </ul>
            </div>

            <div class="example">
              <h4>Ví dụ PIVOT cơ bản:</h4>
              <p>
                Giả sử bạn muốn xem tổng giá sản phẩm theo từng năm sản xuất,
                với mỗi năm là một cột:
              </p>
              <div class="code-block">
                <span class="keyword">SELECT</span> <span class="column">store_id</span>, [<span class="number">2022</span>], [<span class="number">2023</span>], [<span class="number">2024</span>] 
                <span class="keyword">FROM</span> (
                  <span class="keyword">SELECT</span> <span class="column">store_id</span>, <span class="column">model_year</span>, <span class="column">list_price</span> 
                  <span class="keyword">FROM</span> <span class="table">products</span>
                ) <span class="keyword">AS</span> <span class="keyword">src</span> <span class="comment">-- Bảng nguồn tạm</span>
                <span class="keyword">PIVOT</span> (
                  <span class="function">SUM</span>(<span class="column">list_price</span>) <span class="comment">-- Hàm tổng hợp</span>
                  <span class="keyword">FOR</span> <span class="column">model_year</span> <span class="keyword">IN</span> ([<span class="number">2022</span>], [<span class="number">2023</span>], [<span class="number">2024</span>]) <span class="comment">-- Cột sẽ được xoay thành tiêu đề</span>
                ) <span class="keyword">AS</span> <span class="keyword">pvt</span>;
              </div>
              <p>
                <b>Kết quả:</b> Tạo ra các cột mới có tên là [2022], [2023],
                [2024], với giá trị là tổng giá sản phẩm của năm đó cho từng cửa
                hàng.
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ thực tế - Báo cáo doanh thu theo tháng:</h4>
              <div class="code-block">
                <span class="comment">-- Dữ liệu gốc dạng hàng</span>
                <span class="keyword">SELECT</span> <span class="column">employee_name</span>, [<span class="column">January</span>], [<span class="column">February</span>], [<span class="column">March</span>], [<span class="column">April</span>], [<span class="column">May</span>], [<span class="column">June</span>] 
                <span class="keyword">FROM</span> (
                  <span class="keyword">SELECT</span> <span class="column">e.employee_name</span>, <span class="function">DATENAME</span>(<span class="datatype">month</span>, <span class="column">o.order_date</span>) <span class="keyword">AS</span> <span class="column">month_name</span>, <span class="column">o.total_amount</span> 
                  <span class="keyword">FROM</span> <span class="table">employees</span> <span class="keyword">e</span> 
                  <span class="keyword">JOIN</span> <span class="table">orders</span> <span class="keyword">o</span> <span class="keyword">ON</span> <span class="column">e.employee_id</span> <span class="operator">=</span> <span class="column">o.sales_rep_id</span> 
                  <span class="keyword">WHERE</span> <span class="function">YEAR</span>(<span class="column">o.order_date</span>) <span class="operator">=</span> <span class="number">2024</span>
                ) <span class="keyword">AS</span> <span class="keyword">source_data</span> 
                <span class="keyword">PIVOT</span> (
                  <span class="function">SUM</span>(<span class="column">total_amount</span>) 
                  <span class="keyword">FOR</span> <span class="column">month_name</span> <span class="keyword">IN</span> ([<span class="column">January</span>], [<span class="column">February</span>], [<span class="column">March</span>], [<span class="column">April</span>], [<span class="column">May</span>], [<span class="column">June</span>])
                ) <span class="keyword">AS</span> <span class="keyword">monthly_sales</span>;
              </div>
            </div>

            <h3>🔍 4. INTERSECT (Giao nhau)</h3>
            <div class="highlight-box">
              <p>
                Lệnh <b>INTERSECT</b> được sử dụng để trả về các hàng cùng tồn
                tại trong cả hai câu lệnh SELECT.
              </p>

              <h4>📋 Đặc điểm:</h4>
              <ul>
                <li>
                  Các câu lệnh SELECT phải có
                  <b>cùng số cột và kiểu dữ liệu</b> tương thích
                </li>
                <li>Chỉ trả về các <b>hàng chung</b> của hai tập kết quả</li>
                <li><b>Loại bỏ các giá trị trùng lặp</b></li>
                <li>Tương đương với phép giao (∩) trong lý thuyết tập hợp</li>
              </ul>
            </div>

            <div class="example">
              <h4>Ví dụ INTERSECT cơ bản:</h4>
              <p>
                Giả sử bạn muốn tìm các sản phẩm vừa thuộc thương hiệu 1 vừa
                thuộc danh mục 3:
              </p>
              <div class="code-block">
                <span class="keyword">SELECT</span> <span class="column">product_name</span> <span class="keyword">FROM</span> <span class="table">products</span> <span class="keyword">WHERE</span> <span class="column">brand_id</span> <span class="operator">=</span> <span class="number">1</span> 
                <span class="keyword">INTERSECT</span> 
                <span class="keyword">SELECT</span> <span class="column">product_name</span> <span class="keyword">FROM</span> <span class="table">products</span> <span class="keyword">WHERE</span> <span class="column">category_id</span> <span class="operator">=</span> <span class="number">3</span>;
              </div>
              <p>
                <b>Kết quả:</b> Trả về danh sách các sản phẩm có tên xuất hiện
                trong cả hai tập kết quả, tức là những sản phẩm thỏa mãn cả hai
                điều kiện.
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ thực tế - Tìm khách hàng chung:</h4>
              <div class="code-block">
                <span class="comment">-- Tìm khách hàng vừa mua online vừa mua tại cửa hàng</span>
                <span class="keyword">SELECT</span> <span class="column">customer_id</span>, <span class="column">customer_name</span> 
                <span class="keyword">FROM</span> <span class="table">customers</span> <span class="keyword">c</span> 
                <span class="keyword">JOIN</span> <span class="table">orders</span> <span class="keyword">o</span> <span class="keyword">ON</span> <span class="column">c.customer_id</span> <span class="operator">=</span> <span class="column">o.customer_id</span> 
                <span class="keyword">WHERE</span> <span class="column">o.order_type</span> <span class="operator">=</span> <span class="string">'Online'</span> 
                <span class="keyword">INTERSECT</span> 
                <span class="keyword">SELECT</span> <span class="column">customer_id</span>, <span class="column">customer_name</span> 
                <span class="keyword">FROM</span> <span class="table">customers</span> <span class="keyword">c</span> 
                <span class="keyword">JOIN</span> <span class="table">orders</span> <span class="keyword">o</span> <span class="keyword">ON</span> <span class="column">c.customer_id</span> <span class="operator">=</span> <span class="column">o.customer_id</span> 
                <span class="keyword">WHERE</span> <span class="column">o.order_type</span> <span class="operator">=</span> <span class="string">'In-Store'</span>;
              </div>
            </div>

            <h3>📊 So sánh các phép toán</h3>
            <table class="comparison-table">
              <thead>
                <tr>
                  <th>Phép toán</th>
                  <th>Mục đích</th>
                  <th>Kết quả</th>
                  <th>Ứng dụng</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>UNION</b></td>
                  <td>Kết hợp tập hợp</td>
                  <td>Tất cả hàng từ cả hai bảng (loại trùng)</td>
                  <td>Gộp danh sách, báo cáo tổng hợp</td>
                </tr>
                <tr>
                  <td><b>UNION ALL</b></td>
                  <td>Kết hợp tập hợp</td>
                  <td>Tất cả hàng từ cả hai bảng (giữ trùng)</td>
                  <td>Gộp dữ liệu lịch sử</td>
                </tr>
                <tr>
                  <td><b>MERGE</b></td>
                  <td>Đồng bộ dữ liệu</td>
                  <td>Cập nhật bảng đích</td>
                  <td>ETL, đồng bộ master data</td>
                </tr>
                <tr>
                  <td><b>PIVOT</b></td>
                  <td>Chuyển đổi dữ liệu</td>
                  <td>Hàng thành cột</td>
                  <td>Báo cáo cross-tab, dashboard</td>
                </tr>
                <tr>
                  <td><b>INTERSECT</b></td>
                  <td>Tìm giao nhau</td>
                  <td>Hàng chung của hai tập</td>
                  <td>Phân tích overlap, validation</td>
                </tr>
              </tbody>
            </table>

            <h3>💡 Ví dụ tổng hợp</h3>
            <div class="example">
              <h4>Kịch bản: Phân tích khách hàng đa kênh</h4>
              <div class="code-block">
                -- 1. UNION: Tất cả khách hàng từ các kênh SELECT customer_id,
                'Online' AS channel FROM online_customers UNION SELECT
                customer_id, 'Store' AS channel FROM store_customers; -- 2.
                INTERSECT: Khách hàng mua ở cả hai kênh SELECT customer_id FROM
                online_customers INTERSECT SELECT customer_id FROM
                store_customers; -- 3. PIVOT: Doanh thu theo kênh và tháng
                SELECT customer_id, [Online], [Store], [Phone] FROM ( SELECT
                customer_id, channel, total_amount FROM all_orders ) AS src
                PIVOT ( SUM(total_amount) FOR channel IN ([Online], [Store],
                [Phone]) ) AS channel_pivot; -- 4. MERGE: Cập nhật thông tin
                khách hàng MERGE customer_master AS target USING
                customer_updates AS source ON target.customer_id =
                source.customer_id WHEN MATCHED THEN UPDATE SET target.email =
                source.email, target.phone = source.phone WHEN NOT MATCHED THEN
                INSERT VALUES (source.customer_id, source.name, source.email,
                source.phone);
              </div>
            </div>

            <div class="success-box">
              <h4>💡 Best Practices:</h4>
              <ul>
                <li>
                  <b>UNION vs UNION ALL:</b> Sử dụng UNION ALL khi biết chắc
                  không có trùng lặp để tăng hiệu suất
                </li>
                <li>
                  <b>MERGE:</b> Luôn test với dữ liệu nhỏ trước khi chạy
                  production
                </li>
                <li>
                  <b>PIVOT:</b> Cân nhắc sử dụng dynamic PIVOT cho số lượng cột
                  không cố định
                </li>
                <li>
                  <b>INTERSECT:</b> Có thể thay thế bằng EXISTS hoặc INNER JOIN
                  trong một số trường hợp
                </li>
              </ul>
            </div>
          </section>

          <!-- 13 -->
          <section class="section" id="relationship">
            <h2>13. Relationship & Chuẩn hóa (1NF, 2NF, 3NF)</h2>

            <div class="info-box">
              <h4>🔗 Tổng quan:</h4>
              <p>
                Phần này bao gồm hai khái niệm cốt lõi trong thiết kế cơ sở dữ
                liệu: <b>Quan hệ (Relationships)</b> giữa các bảng và
                <b>Chuẩn hóa (Normalization)</b> để tối ưu cấu trúc dữ liệu.
              </p>
            </div>

            <h3>🔗 Các loại Quan hệ (Relationship)</h3>
            <p>
              Trong mô hình cơ sở dữ liệu quan hệ, các bảng được liên kết với
              nhau thông qua <b>khóa ngoại (Foreign Key)</b>. Có ba loại quan hệ
              chính:
            </p>

            <h4>1️⃣ Quan hệ 1-1 (Một-Một)</h4>
            <div class="highlight-box">
              <p>
                <b>Định nghĩa:</b> Một bản ghi trong bảng này chỉ liên kết với
                duy nhất một bản ghi trong bảng kia.
              </p>
              <p>
                <b>Ví dụ:</b> Trong một cơ sở dữ liệu của một trường học, mỗi
                học sinh chỉ có một hồ sơ học bạ duy nhất. Quan hệ giữa bảng
                <code>Students</code> và bảng <code>StudentRecords</code> là
                1-1.
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ thực tế - Quan hệ 1-1:</h4>
              <div class="code-block">
                -- Bảng Students CREATE TABLE students ( student_id INT PRIMARY
                KEY, student_name NVARCHAR(100), birth_date DATE ); -- Bảng
                StudentRecords (quan hệ 1-1) CREATE TABLE student_records (
                record_id INT PRIMARY KEY, student_id INT UNIQUE, -- UNIQUE đảm
                bảo quan hệ 1-1 gpa DECIMAL(3,2), total_credits INT, FOREIGN KEY
                (student_id) REFERENCES students(student_id) );
              </div>
            </div>

            <h4>2️⃣ Quan hệ 1-n (Một-Nhiều)</h4>
            <div class="highlight-box">
              <p>
                <b>Định nghĩa:</b> Một bản ghi trong bảng này có thể liên kết
                với nhiều bản ghi trong bảng kia, nhưng một bản ghi trong bảng
                kia chỉ liên kết với một bản ghi trong bảng này.
              </p>
              <p>
                <b>Ví dụ:</b> Một khách hàng có thể đặt nhiều đơn hàng, nhưng
                mỗi đơn hàng chỉ thuộc về một khách hàng. Quan hệ giữa bảng
                <code>Customers</code> và bảng <code>Orders</code> là 1-n.
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ thực tế - Quan hệ 1-n:</h4>
              <div class="code-block">
                -- Bảng Customers (1) CREATE TABLE customers ( customer_id INT
                PRIMARY KEY, customer_name NVARCHAR(100), email VARCHAR(255) );
                -- Bảng Orders (nhiều) CREATE TABLE orders ( order_id INT
                PRIMARY KEY, customer_id INT, -- Khóa ngoại order_date DATE,
                total_amount DECIMAL(10,2), FOREIGN KEY (customer_id) REFERENCES
                customers(customer_id) );
              </div>
            </div>

            <h4>3️⃣ Quan hệ n-n (Nhiều-Nhiều)</h4>
            <div class="highlight-box">
              <p>
                <b>Định nghĩa:</b> Một bản ghi trong bảng này có thể liên kết
                với nhiều bản ghi trong bảng kia, và ngược lại.
              </p>
              <p>
                <b>Ví dụ:</b> Một sinh viên có thể đăng ký nhiều khóa học, và
                một khóa học có thể có nhiều sinh viên đăng ký. Quan hệ giữa
                bảng <code>Students</code> và bảng <code>Courses</code> là n-n.
              </p>
              <p>
                <b>Giải pháp:</b> Để xử lý loại quan hệ này, bạn cần một
                <b>bảng trung gian (linking table)</b> như
                <code>Enrollments</code> để lưu trữ các liên kết.
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ thực tế - Quan hệ n-n:</h4>
              <div class="code-block">
                -- Bảng Students (nhiều) CREATE TABLE students ( student_id INT
                PRIMARY KEY, student_name NVARCHAR(100) ); -- Bảng Courses
                (nhiều) CREATE TABLE courses ( course_id INT PRIMARY KEY,
                course_name NVARCHAR(100), credits INT ); -- Bảng trung gian
                Enrollments CREATE TABLE enrollments ( enrollment_id INT PRIMARY
                KEY, student_id INT, course_id INT, enrollment_date DATE, grade
                CHAR(2), FOREIGN KEY (student_id) REFERENCES
                students(student_id), FOREIGN KEY (course_id) REFERENCES
                courses(course_id), UNIQUE(student_id, course_id) -- Đảm bảo một
                sinh viên không đăng ký trùng khóa học );
              </div>
            </div>

            <h3>📐 Chuẩn hóa (Normalization)</h3>
            <div class="info-box">
              <p>
                <b>Chuẩn hóa</b> là quá trình tổ chức cơ sở dữ liệu để
                <b>loại bỏ dư thừa dữ liệu</b> và
                <b>cải thiện tính toàn vẹn</b> của dữ liệu. Dưới đây là ba dạng
                chuẩn hóa phổ biến nhất:
              </p>
            </div>

            <h4>📋 1NF (Dạng chuẩn thứ nhất)</h4>
            <div class="highlight-box">
              <p>
                Để một bảng được gọi là ở dạng <b>1NF</b>, nó phải thỏa mãn hai
                điều kiện:
              </p>
              <ul>
                <li>
                  <b>Mỗi ô</b> (giao điểm của hàng và cột) phải chứa một
                  <b>giá trị duy nhất và nguyên tố (atomic)</b>. Tức là không có
                  các giá trị lặp lại trong một ô.
                </li>
                <li>
                  <b>Mỗi hàng phải là duy nhất</b>. Điều này thường được đảm bảo
                  bằng việc có một khóa chính (Primary Key).
                </li>
              </ul>
            </div>

            <div class="example">
              <h4>Ví dụ vi phạm và chuẩn hóa 1NF:</h4>
              <p><b>❌ Bảng không 1NF:</b></p>
              <table style="margin: 10px 0">
                <thead>
                  <tr>
                    <th>ID</th>
                    <th>Tên</th>
                    <th>Số điện thoại</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>1</td>
                    <td>An</td>
                    <td>091234, 098765</td>
                  </tr>
                  <tr>
                    <td>2</td>
                    <td>Bình</td>
                    <td>097777, 096666, 095555</td>
                  </tr>
                </tbody>
              </table>

              <p><b>✅ Bảng đã chuẩn hóa 1NF:</b></p>
              <div class="code-block">
                -- Giải pháp 1: Tách thành nhiều hàng CREATE TABLE contacts_1nf
                ( contact_id INT IDENTITY(1,1) PRIMARY KEY, person_id INT,
                person_name NVARCHAR(50), phone_number VARCHAR(20) ); INSERT
                INTO contacts_1nf VALUES (1, N'An', '091234'), (1, N'An',
                '098765'), (2, N'Bình', '097777'), (2, N'Bình', '096666'), (2,
                N'Bình', '095555');
              </div>
            </div>

            <h4>📋 2NF (Dạng chuẩn thứ hai)</h4>
            <div class="highlight-box">
              <p>
                Để một bảng được gọi là ở dạng <b>2NF</b>, nó phải thỏa mãn các
                điều kiện sau:
              </p>
              <ul>
                <li><b>Đã ở 1NF</b></li>
                <li>
                  <b>Không có phụ thuộc hàm bộ phận</b> (no partial functional
                  dependencies). Điều này chỉ áp dụng cho các bảng có khóa chính
                  kết hợp (Composite Key). Tất cả các thuộc tính không khóa phải
                  phụ thuộc hoàn toàn vào toàn bộ khóa chính.
                </li>
              </ul>
            </div>

            <div class="example">
              <h4>Ví dụ vi phạm và chuẩn hóa 2NF:</h4>
              <p><b>❌ Bảng không 2NF:</b></p>
              <p>
                Giả sử bạn có bảng <code>OrderDetails</code> với khóa chính kết
                hợp là <code>(OrderID, ProductID)</code>. Thuộc tính
                <code>ProductName</code> chỉ phụ thuộc vào
                <code>ProductID</code> chứ không phụ thuộc vào
                <code>OrderID</code>.
              </p>
              <table style="margin: 10px 0">
                <thead>
                  <tr>
                    <th>OrderID</th>
                    <th>ProductID</th>
                    <th>ProductName</th>
                    <th>Quantity</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>101</td>
                    <td>P01</td>
                    <td>T-shirt</td>
                    <td>2</td>
                  </tr>
                  <tr>
                    <td>102</td>
                    <td>P01</td>
                    <td>T-shirt</td>
                    <td>1</td>
                  </tr>
                  <tr>
                    <td>101</td>
                    <td>P02</td>
                    <td>Jeans</td>
                    <td>1</td>
                  </tr>
                </tbody>
              </table>

              <p><b>✅ Bảng đã chuẩn hóa 2NF:</b></p>
              <div class="code-block">
                -- Tách ProductID và ProductName ra bảng riêng CREATE TABLE
                order_details_2nf ( order_id INT, product_id INT, quantity INT,
                PRIMARY KEY (order_id, product_id), FOREIGN KEY (product_id)
                REFERENCES products(product_id) ); CREATE TABLE products (
                product_id INT PRIMARY KEY, product_name NVARCHAR(100), price
                DECIMAL(10,2) );
              </div>
            </div>

            <h4>📋 3NF (Dạng chuẩn thứ ba)</h4>
            <div class="highlight-box">
              <p>
                Để một bảng được gọi là ở dạng <b>3NF</b>, nó phải thỏa mãn các
                điều kiện sau:
              </p>
              <ul>
                <li><b>Đã ở 2NF</b></li>
                <li>
                  <b>Không có phụ thuộc hàm bắc cầu</b> (no transitive
                  functional dependencies). Tức là không có thuộc tính không
                  khóa nào phụ thuộc vào một thuộc tính không khóa khác.
                </li>
              </ul>
            </div>

            <div class="example">
              <h4>Ví dụ vi phạm và chuẩn hóa 3NF:</h4>
              <p><b>❌ Bảng không 3NF:</b></p>
              <p>
                Giả sử bạn có bảng <code>Employees</code>.
                <code>DepartmentName</code> phụ thuộc vào
                <code>DepartmentID</code>, và <code>DepartmentID</code> lại phụ
                thuộc vào <code>EmployeeID</code> (khóa chính). Điều này vi phạm
                3NF vì có sự phụ thuộc bắc cầu:
                <code>EmployeeID → DepartmentID → DepartmentName</code>.
              </p>
              <table style="margin: 10px 0">
                <thead>
                  <tr>
                    <th>EmployeeID</th>
                    <th>EmployeeName</th>
                    <th>DepartmentID</th>
                    <th>DepartmentName</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>1</td>
                    <td>Nguyễn Văn A</td>
                    <td>10</td>
                    <td>IT</td>
                  </tr>
                  <tr>
                    <td>2</td>
                    <td>Trần Thị B</td>
                    <td>10</td>
                    <td>IT</td>
                  </tr>
                  <tr>
                    <td>3</td>
                    <td>Lê Văn C</td>
                    <td>20</td>
                    <td>Marketing</td>
                  </tr>
                </tbody>
              </table>

              <p><b>✅ Bảng đã chuẩn hóa 3NF:</b></p>
              <div class="code-block">
                -- Tách DepartmentID và DepartmentName ra bảng riêng CREATE
                TABLE employees_3nf ( employee_id INT PRIMARY KEY, employee_name
                NVARCHAR(100), department_id INT, salary DECIMAL(10,2), FOREIGN
                KEY (department_id) REFERENCES departments(department_id) );
                CREATE TABLE departments ( department_id INT PRIMARY KEY,
                department_name NVARCHAR(100), manager_id INT, budget
                DECIMAL(12,2) );
              </div>
            </div>

            <h3>📊 Tóm tắt Chuẩn hóa</h3>
            <table class="comparison-table">
              <thead>
                <tr>
                  <th>Dạng chuẩn</th>
                  <th>Điều kiện</th>
                  <th>Vấn đề giải quyết</th>
                  <th>Ví dụ</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>1NF</b></td>
                  <td>Giá trị nguyên tố, hàng duy nhất</td>
                  <td>Giá trị đa trị trong một ô</td>
                  <td>Tách "091234, 098765" thành 2 hàng</td>
                </tr>
                <tr>
                  <td><b>2NF</b></td>
                  <td>1NF + không phụ thuộc bộ phận</td>
                  <td>Thuộc tính phụ thuộc một phần khóa</td>
                  <td>Tách ProductName khỏi OrderDetails</td>
                </tr>
                <tr>
                  <td><b>3NF</b></td>
                  <td>2NF + không phụ thuộc bắc cầu</td>
                  <td>Thuộc tính phụ thuộc thuộc tính khác</td>
                  <td>Tách DepartmentName khỏi Employees</td>
                </tr>
              </tbody>
            </table>

            <h3>💡 Ví dụ tổng hợp: Hệ thống quản lý bán hàng</h3>
            <div class="example">
              <h4>Thiết kế cơ sở dữ liệu chuẩn hóa đầy đủ:</h4>
              <div class="code-block">
                -- 1. Bảng Customers (1 trong quan hệ 1-n với Orders) CREATE
                TABLE customers ( customer_id INT PRIMARY KEY, customer_name
                NVARCHAR(100) NOT NULL, email VARCHAR(255) UNIQUE, phone
                VARCHAR(20), address NVARCHAR(255) ); -- 2. Bảng Categories
                CREATE TABLE categories ( category_id INT PRIMARY KEY,
                category_name NVARCHAR(100) NOT NULL ); -- 3. Bảng Products
                (tuân thủ 3NF - tách category thành bảng riêng) CREATE TABLE
                products ( product_id INT PRIMARY KEY, product_name
                NVARCHAR(100) NOT NULL, category_id INT, price DECIMAL(10,2),
                stock_quantity INT, FOREIGN KEY (category_id) REFERENCES
                categories(category_id) ); -- 4. Bảng Orders (n trong quan hệ
                1-n với Customers) CREATE TABLE orders ( order_id INT PRIMARY
                KEY, customer_id INT, order_date DATE DEFAULT GETDATE(),
                total_amount DECIMAL(10,2), FOREIGN KEY (customer_id) REFERENCES
                customers(customer_id) ); -- 5. Bảng OrderDetails (bảng trung
                gian cho quan hệ n-n giữa Orders và Products) CREATE TABLE
                order_details ( order_detail_id INT PRIMARY KEY, order_id INT,
                product_id INT, quantity INT, unit_price DECIMAL(10,2), FOREIGN
                KEY (order_id) REFERENCES orders(order_id), FOREIGN KEY
                (product_id) REFERENCES products(product_id) );
              </div>
            </div>

            <h3>✅ Lợi ích của Chuẩn hóa</h3>
            <div class="success-box">
              <ul>
                <li>
                  <b>Giảm dư thừa dữ liệu:</b> Thông tin không bị lặp lại không
                  cần thiết
                </li>
                <li>
                  <b>Tăng tính nhất quán:</b> Cập nhật dữ liệu ở một nơi sẽ áp
                  dụng toàn bộ hệ thống
                </li>
                <li>
                  <b>Tiết kiệm dung lượng:</b> Giảm kích thước cơ sở dữ liệu
                </li>
                <li>
                  <b>Dễ bảo trì:</b> Thay đổi cấu trúc ít ảnh hưởng đến toàn hệ
                  thống
                </li>
                <li>
                  <b>Tăng tính toàn vẹn:</b> Giảm thiểu lỗi và mâu thuẫn dữ liệu
                </li>
              </ul>
            </div>

            <div class="info-box">
              <h4>⚠️ Lưu ý:</h4>
              <p>
                Việc chuẩn hóa giúp cơ sở dữ liệu của bạn trở nên hiệu quả hơn
                bằng cách giảm thiểu các vấn đề như <b>dư thừa dữ liệu</b>,
                <b>bất thường khi cập nhật</b>, và <b>bất thường khi xóa</b>.
                Tuy nhiên, đôi khi cần phải
                <b>phi chuẩn hóa (denormalization)</b> để tối ưu hiệu suất truy
                vấn trong các hệ thống có lượng đọc lớn.
              </p>
            </div>
          </section>

          <!-- 14 -->
          <section class="section" id="group-by">
            <h2>14. GROUP BY</h2>

            <div class="info-box">
              <h4>📊 GROUP BY là gì?</h4>
              <p>
                Mệnh đề <b>GROUP BY</b> được sử dụng để nhóm các hàng có cùng
                giá trị trong một hoặc nhiều cột thành các nhóm tóm tắt. Sau khi
                các hàng được nhóm, bạn có thể áp dụng các
                <b>hàm tổng hợp</b> (như COUNT, SUM, AVG, MAX, MIN) lên mỗi nhóm
                để tính toán các giá trị tổng hợp.
              </p>
            </div>

            <h3>🎯 Khái niệm cơ bản</h3>
            <div class="highlight-box">
              <p>
                Bạn có thể hình dung GROUP BY như một cách để
                <b>"tổng kết"</b> dữ liệu. Thay vì xem xét từng hàng riêng lẻ,
                bạn gom chúng lại thành các nhóm dựa trên một đặc điểm chung,
                sau đó tính toán một giá trị tổng kết cho mỗi nhóm đó.
              </p>

              <ul>
                <li>
                  <b>Vị trí:</b> GROUP BY luôn được đặt sau mệnh đề FROM (và
                  WHERE, nếu có)
                </li>
                <li>
                  <b>Mục đích:</b> Để tạo ra các báo cáo tóm tắt, thống kê, hoặc
                  phân tích dữ liệu theo từng nhóm
                </li>
              </ul>
            </div>

            <h3>📋 Ví dụ cụ thể</h3>
            <div class="example">
              <h4>Bài toán: Đếm sản phẩm theo cửa hàng</h4>
              <p>
                Giả sử bạn có một bảng <code>stocks</code> (tồn kho) lưu trữ
                thông tin về sản phẩm trong các cửa hàng, với các cột
                <code>store_id</code> (mã cửa hàng) và
                <code>product_id</code> (mã sản phẩm).
              </p>

              <p>
                <b>Vấn đề:</b> Nếu bạn muốn biết mỗi cửa hàng có bao nhiêu sản
                phẩm, bạn không thể chỉ dùng SELECT và COUNT thông thường, vì nó
                sẽ chỉ trả về tổng số sản phẩm trong toàn bộ bảng. Bạn cần nhóm
                dữ liệu theo <code>store_id</code> để đếm số sản phẩm cho từng
                cửa hàng.
              </p>

              <div class="code-block">
                SELECT store_id, COUNT(product_id) AS total_products FROM stocks
                GROUP BY store_id;
              </div>

              <h4>Giải thích từng phần:</h4>
              <ul>
                <li>
                  <b>SELECT store_id, COUNT(product_id) AS total_products:</b>
                  Chọn cột store_id và sử dụng hàm COUNT() để đếm số product_id
                  trong mỗi nhóm. Kết quả của hàm COUNT() sẽ được đặt tên là
                  total_products.
                </li>
                <li><b>FROM stocks:</b> Chỉ định bảng dữ liệu là stocks.</li>
                <li>
                  <b>GROUP BY store_id:</b> Đây là phần quan trọng nhất. Nó sẽ
                  gom tất cả các hàng có cùng store_id lại thành một nhóm. Ví
                  dụ, tất cả sản phẩm của cửa hàng có store_id = 1 sẽ được nhóm
                  lại với nhau, và COUNT() sẽ được áp dụng cho nhóm đó.
                </li>
              </ul>

              <h4>Kết quả có thể là:</h4>
              <table style="margin: 10px 0">
                <thead>
                  <tr>
                    <th>store_id</th>
                    <th>total_products</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>1</td>
                    <td>50</td>
                  </tr>
                  <tr>
                    <td>2</td>
                    <td>35</td>
                  </tr>
                  <tr>
                    <td>3</td>
                    <td>70</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <h3>💡 Các ví dụ khác</h3>

            <div class="example">
              <h4>1. Tổng doanh thu theo từng danh mục sản phẩm:</h4>
              <div class="code-block">
                SELECT category_id, SUM(price) AS total_revenue FROM products
                GROUP BY category_id;
              </div>
              <p>
                <b>Kết quả:</b> Hiển thị tổng giá trị của tất cả sản phẩm trong
                mỗi danh mục.
              </p>
            </div>

            <div class="example">
              <h4>2. Giá trị trung bình của đơn hàng theo từng khách hàng:</h4>
              <div class="code-block">
                SELECT customer_id, AVG(total_amount) AS average_order_value
                FROM orders GROUP BY customer_id;
              </div>
              <p>
                <b>Kết quả:</b> Hiển thị giá trị đơn hàng trung bình của mỗi
                khách hàng.
              </p>
            </div>

            <div class="example">
              <h4>3. Số lượng nhân viên theo từng phòng ban:</h4>
              <div class="code-block">
                SELECT department_id, COUNT(*) AS employee_count FROM employees
                GROUP BY department_id;
              </div>
              <p><b>Kết quả:</b> Đếm số nhân viên trong mỗi phòng ban.</p>
            </div>

            <div class="example">
              <h4>4. Sản phẩm đắt nhất và rẻ nhất theo từng thương hiệu:</h4>
              <div class="code-block">
                SELECT brand_id, MIN(price) AS cheapest_product, MAX(price) AS
                most_expensive_product, AVG(price) AS average_price FROM
                products GROUP BY brand_id;
              </div>
              <p>
                <b>Kết quả:</b> Thống kê giá sản phẩm chi tiết cho từng thương
                hiệu.
              </p>
            </div>

            <h3>🔄 GROUP BY với nhiều cột</h3>
            <div class="example">
              <h4>Ví dụ: Thống kê doanh thu theo cửa hàng và năm</h4>
              <div class="code-block">
                SELECT store_id, YEAR(order_date) AS order_year,
                SUM(total_amount) AS annual_revenue, COUNT(order_id) AS
                total_orders FROM orders GROUP BY store_id, YEAR(order_date)
                ORDER BY store_id, order_year;
              </div>
              <p>
                <b>Kết quả:</b> Mỗi nhóm sẽ là kết hợp của
                <code>store_id</code> và <code>year</code>. Ví dụ: (store_id=1,
                year=2024), (store_id=1, year=2025), (store_id=2, year=2024),
                v.v.
              </p>
            </div>

            <h3>🎯 GROUP BY kết hợp với WHERE</h3>
            <div class="example">
              <h4>
                Ví dụ: Đếm đơn hàng của khách hàng VIP (tổng chi tiêu > 10,000)
              </h4>
              <div class="code-block">
                SELECT customer_id, COUNT(order_id) AS total_orders,
                SUM(total_amount) AS total_spent FROM orders WHERE order_date >=
                '2024-01-01' -- Lọc trước khi nhóm GROUP BY customer_id HAVING
                SUM(total_amount) > 10000 -- Lọc sau khi nhóm ORDER BY
                total_spent DESC;
              </div>
              <p>
                <b>Thứ tự thực thi:</b> WHERE → GROUP BY → HAVING → ORDER BY
              </p>
            </div>

            <h3>📊 Các hàm tổng hợp thường dùng với GROUP BY</h3>
            <table class="comparison-table">
              <thead>
                <tr>
                  <th>Hàm</th>
                  <th>Mô tả</th>
                  <th>Ví dụ</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>COUNT()</b></td>
                  <td>Đếm số hàng trong nhóm</td>
                  <td>COUNT(product_id), COUNT(*)</td>
                </tr>
                <tr>
                  <td><b>SUM()</b></td>
                  <td>Tính tổng giá trị</td>
                  <td>SUM(price), SUM(quantity)</td>
                </tr>
                <tr>
                  <td><b>AVG()</b></td>
                  <td>Tính giá trị trung bình</td>
                  <td>AVG(salary), AVG(rating)</td>
                </tr>
                <tr>
                  <td><b>MIN()</b></td>
                  <td>Tìm giá trị nhỏ nhất</td>
                  <td>MIN(price), MIN(hire_date)</td>
                </tr>
                <tr>
                  <td><b>MAX()</b></td>
                  <td>Tìm giá trị lớn nhất</td>
                  <td>MAX(price), MAX(order_date)</td>
                </tr>
              </tbody>
            </table>

            <h3>⚠️ Lưu ý quan trọng</h3>
            <div class="info-box">
              <h4>Quy tắc về SELECT với GROUP BY:</h4>
              <p>
                Khi sử dụng GROUP BY, các cột trong mệnh đề SELECT chỉ có thể
                là:
              </p>
              <ul>
                <li><b>Các cột bạn đã nhóm</b> (xuất hiện trong GROUP BY)</li>
                <li>
                  <b>Các cột được sử dụng trong các hàm tổng hợp</b> (COUNT,
                  SUM, AVG, etc.)
                </li>
              </ul>
              <p>
                Nếu bạn muốn hiển thị một cột không nằm trong GROUP BY, bạn phải
                bao nó trong một hàm tổng hợp.
              </p>
            </div>

            <div class="example">
              <h4>❌ Lỗi thường gặp:</h4>
              <div class="code-block">
                -- SAI: product_name không có trong GROUP BY và không có trong
                hàm tổng hợp SELECT category_id, product_name, COUNT(*) FROM
                products GROUP BY category_id; -- LỖI!
              </div>

              <h4>✅ Cách sửa:</h4>
              <div class="code-block">
                -- ĐÚNG: Chỉ hiển thị các cột đã nhóm và hàm tổng hợp SELECT
                category_id, COUNT(*) AS product_count FROM products GROUP BY
                category_id; -- Hoặc nếu muốn thấy tên sản phẩm, có thể dùng
                STRING_AGG (SQL Server) SELECT category_id, COUNT(*) AS
                product_count, STRING_AGG(product_name, ', ') AS product_list
                FROM products GROUP BY category_id;
              </div>
            </div>

            <h3>🔧 Ví dụ thực tế: Báo cáo bán hàng tổng hợp</h3>
            <div class="example">
              <h4>Kịch bản: Tạo báo cáo tổng hợp cho quản lý</h4>
              <div class="code-block">
                -- Báo cáo doanh thu tổng hợp theo tháng và cửa hàng SELECT
                s.store_name, YEAR(o.order_date) AS order_year,
                MONTH(o.order_date) AS order_month, COUNT(o.order_id) AS
                total_orders, SUM(o.total_amount) AS total_revenue,
                AVG(o.total_amount) AS average_order_value, MIN(o.total_amount)
                AS smallest_order, MAX(o.total_amount) AS largest_order FROM
                stores s JOIN orders o ON s.store_id = o.store_id WHERE
                o.order_date >= '2024-01-01' GROUP BY s.store_name,
                YEAR(o.order_date), MONTH(o.order_date) HAVING
                SUM(o.total_amount) > 50000 -- Chỉ hiển thị tháng có doanh thu >
                50K ORDER BY order_year, order_month, total_revenue DESC;
              </div>
            </div>

            <div class="success-box">
              <h4>💡 Best Practices:</h4>
              <ul>
                <li>
                  <b>Sử dụng alias:</b> Đặt tên dễ hiểu cho các cột tính toán
                  (AS total_products)
                </li>
                <li><b>Kết hợp với ORDER BY:</b> Sắp xếp kết quả để dễ đọc</li>
                <li>
                  <b>Sử dụng HAVING:</b> Lọc các nhóm dựa trên kết quả tổng hợp
                </li>
                <li>
                  <b>Nhóm thông minh:</b> Nhóm theo các cột có ý nghĩa kinh
                  doanh
                </li>
                <li>
                  <b>Test với dữ liệu nhỏ:</b> Kiểm tra logic trước khi chạy với
                  dữ liệu lớn
                </li>
              </ul>
            </div>
          </section>

          <!-- 15 -->
          <section class="section" id="functions">
            <h2>15. Function thường dùng</h2>

            <div class="info-box">
              <h4>⚙️ Tổng quan về Functions:</h4>
              <p>
                SQL cung cấp nhiều loại hàm để xử lý và tính toán dữ liệu. Các
                hàm này được chia thành ba nhóm chính: <b>Hàm Tổng Hợp</b>,
                <b>Hàm Chuỗi</b>, và <b>Hàm Ngày Giờ</b>.
              </p>
            </div>

            <h3>📊 Hàm Tổng Hợp (Aggregate Functions)</h3>
            <div class="highlight-box">
              <p>
                Các hàm này được sử dụng để thực hiện phép tính trên
                <b>một tập hợp các giá trị</b> và trả về
                <b>một giá trị duy nhất</b>. Chúng thường đi kèm với mệnh đề
                GROUP BY.
              </p>
            </div>

            <h4>🔢 COUNT() - Đếm số hàng</h4>
            <div class="example">
              <p><b>Chức năng:</b> Đếm số hàng thỏa mãn điều kiện.</p>
              <div class="code-block">
                -- Đếm tổng số sản phẩm trong bảng products SELECT
                COUNT(product_id) AS total_products FROM products; -- Đếm số
                khách hàng có email (không NULL) SELECT COUNT(email) AS
                customers_with_email FROM customers; -- Đếm tất cả hàng (bao gồm
                NULL) SELECT COUNT(*) AS total_customers FROM customers; -- Đếm
                số sản phẩm theo từng danh mục SELECT category_id,
                COUNT(product_id) AS products_count FROM products GROUP BY
                category_id;
              </div>
              <p>
                <b>Lưu ý:</b> COUNT(column) bỏ qua giá trị NULL, COUNT(*) đếm
                tất cả hàng.
              </p>
            </div>

            <h4>➕ SUM() - Tính tổng</h4>
            <div class="example">
              <p><b>Chức năng:</b> Tính tổng của một cột số.</p>
              <div class="code-block">
                -- Tính tổng doanh thu từ tất cả các đơn hàng SELECT
                SUM(total_amount) AS total_revenue FROM orders; -- Tổng số lượng
                sản phẩm trong kho SELECT SUM(stock_quantity) AS total_inventory
                FROM products; -- Tổng doanh thu theo từng cửa hàng SELECT
                store_id, SUM(total_amount) AS store_revenue FROM orders GROUP
                BY store_id; -- Tổng lương theo phòng ban SELECT department_id,
                SUM(salary) AS total_department_salary FROM employees GROUP BY
                department_id;
              </div>
            </div>

            <h4>📈 AVG() - Tính giá trị trung bình</h4>
            <div class="example">
              <p><b>Chức năng:</b> Tính giá trị trung bình của một cột số.</p>
              <div class="code-block">
                -- Tính giá bán trung bình của các sản phẩm SELECT
                AVG(list_price) AS avg_price FROM products; -- Giá trị đơn hàng
                trung bình của từng khách hàng SELECT customer_id,
                AVG(total_amount) AS avg_order_value FROM orders GROUP BY
                customer_id; -- Mức lương trung bình theo từng phòng ban SELECT
                department_id, AVG(salary) AS avg_salary FROM employees GROUP BY
                department_id; -- Điểm trung bình của sinh viên SELECT
                student_id, AVG(grade) AS gpa FROM student_grades GROUP BY
                student_id;
              </div>
            </div>

            <h4>⬇️ MIN() - Tìm giá trị nhỏ nhất</h4>
            <div class="example">
              <p><b>Chức năng:</b> Tìm giá trị nhỏ nhất của một cột.</p>
              <div class="code-block">
                -- Tìm ngày thuê nhân viên sớm nhất SELECT MIN(hire_date) AS
                earliest_hire_date FROM employees; -- Giá sản phẩm rẻ nhất trong
                mỗi danh mục SELECT category_id, MIN(list_price) AS
                cheapest_price FROM products GROUP BY category_id; -- Tuổi nhỏ
                nhất của nhân viên trong mỗi phòng ban SELECT department_id,
                MIN(DATEDIFF(YEAR, birth_date, GETDATE())) AS youngest_age FROM
                employees GROUP BY department_id; -- Đơn hàng có giá trị thấp
                nhất của từng khách hàng SELECT customer_id, MIN(total_amount)
                AS smallest_order FROM orders GROUP BY customer_id;
              </div>
            </div>

            <h4>⬆️ MAX() - Tìm giá trị lớn nhất</h4>
            <div class="example">
              <p><b>Chức năng:</b> Tìm giá trị lớn nhất của một cột.</p>
              <div class="code-block">
                -- Tìm mức lương cao nhất SELECT MAX(salary) AS highest_salary
                FROM employees; -- Giá sản phẩm đắt nhất trong mỗi danh mục
                SELECT category_id, MAX(list_price) AS most_expensive_price FROM
                products GROUP BY category_id; -- Đơn hàng có giá trị cao nhất
                của từng khách hàng SELECT customer_id, MAX(total_amount) AS
                largest_order FROM orders GROUP BY customer_id; -- Ngày đặt hàng
                gần nhất SELECT MAX(order_date) AS latest_order_date FROM
                orders;
              </div>
            </div>

            <h3>🔤 Hàm Chuỗi (String Functions)</h3>
            <div class="highlight-box">
              <p>
                Các hàm này được sử dụng để
                <b>thao tác trên dữ liệu chuỗi</b> như nối chuỗi, tìm độ dài,
                trích xuất chuỗi con, v.v.
              </p>
            </div>

            <h4>🔗 CONCAT() - Nối chuỗi</h4>
            <div class="example">
              <p><b>Chức năng:</b> Nối hai hoặc nhiều chuỗi lại với nhau.</p>
              <div class="code-block">
                -- Ghép tên và họ thành một cột tên đầy đủ SELECT
                CONCAT(first_name, ' ', last_name) AS full_name FROM customers;
                -- Tạo mã sản phẩm đầy đủ SELECT CONCAT('PRD-', category_id,
                '-', product_id) AS full_product_code FROM products; -- Tạo địa
                chỉ đầy đủ SELECT customer_id, CONCAT(street_address, ', ',
                city, ', ', state, ' ', zip_code) AS full_address FROM
                customers; -- Tạo thông tin nhân viên SELECT
                CONCAT(employee_name, ' (', department_name, ')') AS
                employee_info FROM employees e JOIN departments d ON
                e.department_id = d.department_id;
              </div>
            </div>

            <h4>📏 LENGTH() / LEN() - Độ dài chuỗi</h4>
            <div class="example">
              <p><b>Chức năng:</b> Trả về độ dài của một chuỗi (số ký tự).</p>
              <div class="code-block">
                -- Trả về tên sản phẩm và độ dài của tên đó SELECT product_name,
                LEN(product_name) AS name_length FROM products; -- Tìm khách
                hàng có tên dài nhất SELECT TOP 1 customer_name,
                LEN(customer_name) AS name_length FROM customers ORDER BY
                LEN(customer_name) DESC; -- Lọc sản phẩm có tên ngắn (dưới 10 ký
                tự) SELECT product_name FROM products WHERE LEN(product_name) <
                10; -- Thống kê độ dài email SELECT AVG(LEN(email)) AS
                avg_email_length, MIN(LEN(email)) AS shortest_email,
                MAX(LEN(email)) AS longest_email FROM customers WHERE email IS
                NOT NULL;
              </div>
            </div>

            <h4>✂️ SUBSTRING() / SUBSTR() - Trích xuất chuỗi con</h4>
            <div class="example">
              <p><b>Chức năng:</b> Trích xuất một chuỗi con từ một chuỗi.</p>
              <div class="code-block">
                -- Trích xuất 7 ký tự đầu tiên từ vị trí 1 SELECT
                SUBSTRING('Welcome to SQL', 1, 7) AS result; -- Kết quả:
                'Welcome' -- Lấy 3 ký tự đầu của mã sản phẩm SELECT product_id,
                SUBSTRING(product_code, 1, 3) AS category_code FROM products; --
                Lấy năm từ mã đơn hàng (giả sử format: ORD-2024-001) SELECT
                order_id, SUBSTRING(order_code, 5, 4) AS order_year FROM orders;
                -- Tạo tên viết tắt từ họ tên SELECT customer_name,
                SUBSTRING(first_name, 1, 1) + '.' + SUBSTRING(last_name, 1, 1) +
                '.' AS initials FROM customers; -- Lấy domain từ email SELECT
                email, SUBSTRING(email, CHARINDEX('@', email) + 1, LEN(email))
                AS email_domain FROM customers WHERE email IS NOT NULL;
              </div>
            </div>

            <h3>📅 Hàm Ngày Giờ (Date and Time Functions)</h3>
            <div class="highlight-box">
              <p>
                Các hàm này được sử dụng để
                <b>làm việc với dữ liệu ngày và giờ</b>. Tên hàm có thể thay đổi
                tùy thuộc vào hệ quản trị cơ sở dữ liệu (MySQL, SQL Server,
                PostgreSQL, v.v.).
              </p>
            </div>

            <h4>📆 CURRENT_DATE() / GETDATE() - Ngày hiện tại</h4>
            <div class="example">
              <p><b>Chức năng:</b> Trả về ngày hiện tại của hệ thống.</p>
              <div class="code-block">
                -- SQL Server SELECT GETDATE() AS current_datetime; -- MySQL /
                PostgreSQL SELECT CURRENT_DATE() AS current_date; SELECT NOW()
                AS current_datetime; -- Tính tuổi nhân viên SELECT
                employee_name, birth_date, DATEDIFF(YEAR, birth_date, GETDATE())
                AS age FROM employees; -- Tạo bản ghi với timestamp INSERT INTO
                audit_log (action, created_date) VALUES ('User Login',
                GETDATE()); -- Lọc đơn hàng trong 30 ngày qua SELECT * FROM
                orders WHERE order_date >= DATEADD(DAY, -30, GETDATE());
              </div>
            </div>

            <h4>➕ DATEADD() / DATE_ADD() - Cộng thời gian</h4>
            <div class="example">
              <p>
                <b>Chức năng:</b> Cộng thêm một khoảng thời gian vào một ngày.
              </p>
              <div class="code-block">
                -- SQL Server: Trả về ngày sau 30 ngày kể từ ngày hiện tại
                SELECT DATEADD(DAY, 30, GETDATE()) AS date_after_30_days; --
                Tính ngày hết hạn hợp đồng (2 năm sau ngày ký) SELECT
                employee_name, hire_date, DATEADD(YEAR, 2, hire_date) AS
                contract_expiry FROM employees; -- MySQL: Cộng thêm 1 tháng
                SELECT DATE_ADD(order_date, INTERVAL 1 MONTH) AS follow_up_date
                FROM orders; -- Tính ngày giao hàng dự kiến (7 ngày sau đặt
                hàng) SELECT order_id, order_date, DATEADD(DAY, 7, order_date)
                AS expected_delivery_date FROM orders; -- Lọc nhân viên sắp nghỉ
                hưu (trong 1 năm tới, giả sử 65 tuổi) SELECT employee_name,
                birth_date FROM employees WHERE DATEADD(YEAR, 65, birth_date) <=
                DATEADD(YEAR, 1, GETDATE());
              </div>
            </div>

            <h4>📊 DATEDIFF() - Tính khoảng cách thời gian</h4>
            <div class="example">
              <p><b>Chức năng:</b> Tính khoảng thời gian giữa hai ngày.</p>
              <div class="code-block">
                -- Trả về số ngày đã trôi qua kể từ ngày 01/01/2025 đến nay
                SELECT DATEDIFF(DAY, '2025-01-01', GETDATE()) AS days_passed; --
                Tính số năm làm việc của nhân viên SELECT employee_name,
                hire_date, DATEDIFF(YEAR, hire_date, GETDATE()) AS
                years_of_service FROM employees; -- Tính thời gian xử lý đơn
                hàng (giờ) SELECT order_id, order_date, shipped_date,
                DATEDIFF(HOUR, order_date, shipped_date) AS processing_hours
                FROM orders WHERE shipped_date IS NOT NULL; -- Tìm khách hàng
                lâu không mua hàng SELECT customer_id, customer_name,
                MAX(order_date) AS last_order_date, DATEDIFF(DAY,
                MAX(order_date), GETDATE()) AS days_since_last_order FROM
                customers c LEFT JOIN orders o ON c.customer_id = o.customer_id
                GROUP BY customer_id, customer_name HAVING DATEDIFF(DAY,
                MAX(order_date), GETDATE()) > 365;
              </div>
            </div>

            <h4>🗓️ DATEPART() / EXTRACT() - Trích xuất phần ngày</h4>
            <div class="example">
              <p>
                <b>Chức năng:</b> Trích xuất một phần của ngày (ví dụ: năm,
                tháng, ngày).
              </p>
              <div class="code-block">
                -- SQL Server: Trả về năm của mỗi đơn hàng SELECT order_id,
                order_date, DATEPART(YEAR, order_date) AS order_year,
                DATEPART(MONTH, order_date) AS order_month, DATEPART(DAY,
                order_date) AS order_day FROM orders; -- PostgreSQL: Sử dụng
                EXTRACT SELECT order_id, EXTRACT(YEAR FROM order_date) AS
                order_year, EXTRACT(MONTH FROM order_date) AS order_month FROM
                orders; -- Phân tích doanh thu theo tháng SELECT DATEPART(YEAR,
                order_date) AS year, DATEPART(MONTH, order_date) AS month,
                SUM(total_amount) AS monthly_revenue FROM orders GROUP BY
                DATEPART(YEAR, order_date), DATEPART(MONTH, order_date) ORDER BY
                year, month; -- Tìm ngày trong tuần bán chạy nhất SELECT
                DATEPART(WEEKDAY, order_date) AS day_of_week, COUNT(*) AS
                order_count FROM orders GROUP BY DATEPART(WEEKDAY, order_date)
                ORDER BY order_count DESC;
              </div>
            </div>

            <h4>🎨 FORMAT() - Định dạng ngày</h4>
            <div class="example">
              <p>
                <b>Chức năng:</b> Định dạng ngày thành một chuỗi theo format
                mong muốn.
              </p>
              <div class="code-block">
                -- Trả về ngày hiện tại dưới dạng chuỗi '21-09-2025' SELECT
                FORMAT(GETDATE(), 'dd-MM-yyyy') AS formatted_date; -- Các format
                khác nhau SELECT GETDATE() AS original_date, FORMAT(GETDATE(),
                'dd/MM/yyyy') AS format1, FORMAT(GETDATE(), 'yyyy-MM-dd') AS
                format2, FORMAT(GETDATE(), 'MMMM dd, yyyy') AS format3,
                FORMAT(GETDATE(), 'dddd, MMMM dd, yyyy') AS format4; -- Format
                trong báo cáo SELECT order_id, customer_name, FORMAT(order_date,
                'dd/MM/yyyy') AS order_date_formatted, FORMAT(total_amount, 'C',
                'vi-VN') AS amount_formatted FROM orders o JOIN customers c ON
                o.customer_id = c.customer_id; -- Tạo tên file backup theo ngày
                SELECT CONCAT('backup_', FORMAT(GETDATE(), 'yyyyMMdd'), '.sql')
                AS backup_filename;
              </div>
            </div>

            <h3>🔧 Ví dụ tổng hợp: Báo cáo bán hàng đa chức năng</h3>
            <div class="example">
              <h4>Kịch bản: Báo cáo chi tiết với tất cả loại functions</h4>
              <div class="code-block">
                SELECT -- String functions CONCAT(c.first_name, ' ',
                c.last_name) AS customer_full_name, LEFT(c.email, CHARINDEX('@',
                c.email) - 1) AS email_username, -- Date functions
                FORMAT(o.order_date, 'MMMM yyyy') AS order_month_year,
                DATEDIFF(DAY, o.order_date, GETDATE()) AS days_since_order, --
                Aggregate functions COUNT(od.product_id) AS total_items,
                SUM(od.quantity * od.unit_price) AS order_total,
                AVG(od.unit_price) AS avg_item_price, MIN(od.unit_price) AS
                cheapest_item, MAX(od.unit_price) AS most_expensive_item FROM
                customers c JOIN orders o ON c.customer_id = o.customer_id JOIN
                order_details od ON o.order_id = od.order_id WHERE o.order_date
                >= DATEADD(MONTH, -6, GETDATE()) -- 6 tháng gần đây GROUP BY
                c.customer_id, c.first_name, c.last_name, c.email, o.order_id,
                o.order_date HAVING SUM(od.quantity * od.unit_price) > 1000 --
                Đơn hàng > 1000 ORDER BY order_total DESC;
              </div>
            </div>

            <div class="success-box">
              <h4>💡 Best Practices cho Functions:</h4>
              <ul>
                <li>
                  <b>Hiệu suất:</b> Tránh sử dụng functions trong WHERE clause
                  với cột được index
                </li>
                <li>
                  <b>NULL handling:</b> Luôn kiểm tra NULL trước khi sử dụng
                  string/date functions
                </li>
                <li>
                  <b>Database specific:</b> Chú ý sự khác biệt giữa các hệ CSDL
                  (MySQL, SQL Server, PostgreSQL)
                </li>
                <li>
                  <b>Alias:</b> Sử dụng alias có ý nghĩa cho kết quả functions
                </li>
                <li>
                  <b>Testing:</b> Test functions với dữ liệu edge cases (NULL,
                  empty string, extreme dates)
                </li>
              </ul>
            </div>

            <div class="info-box">
              <h4>⚠️ Lưu ý về tương thích:</h4>
              <p>Một số functions có tên khác nhau giữa các hệ CSDL:</p>
              <ul>
                <li>
                  <b>SQL Server:</b> LEN(), GETDATE(), DATEPART(), FORMAT()
                </li>
                <li><b>MySQL:</b> LENGTH(), NOW(), EXTRACT(), DATE_FORMAT()</li>
                <li>
                  <b>PostgreSQL:</b> LENGTH(), NOW(), EXTRACT(), TO_CHAR()
                </li>
                <li><b>Oracle:</b> LENGTH(), SYSDATE, EXTRACT(), TO_CHAR()</li>
              </ul>
            </div>
          </section>

          <!-- 16 -->
          <section class="section" id="join">
            <h2>16. JOIN</h2>

            <div class="info-box">
              <h4>🔗 JOIN là gì?</h4>
              <p>
                <b>JOIN</b> được sử dụng để kết hợp các hàng từ hai hoặc nhiều
                bảng dựa trên một cột liên quan giữa chúng. Mục đích của JOIN là
                lấy dữ liệu từ nhiều bảng và hiển thị chúng trong một tập hợp
                kết quả duy nhất.
              </p>
            </div>

            <div class="highlight-box">
              <h4>📋 Các loại JOIN chính:</h4>
              <p>
                Có <b>bốn loại JOIN chính</b>: INNER JOIN, LEFT JOIN, RIGHT
                JOIN, và FULL JOIN. Ngoài ra, còn có <b>CROSS JOIN</b>.
              </p>
            </div>

            <h3>🔄 1. INNER JOIN</h3>
            <div class="highlight-box">
              <p>
                <b>INNER JOIN</b> trả về tất cả các hàng khi có sự khớp nhau
                trong cả hai bảng. Nó là loại JOIN phổ biến nhất và thường được
                sử dụng mặc định nếu bạn không chỉ định loại JOIN nào.
              </p>
              <p>
                <b>Hoạt động:</b> Lấy các hàng từ bảng A và bảng B chỉ khi có
                giá trị tương ứng trong cả hai bảng dựa trên điều kiện ON.
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ INNER JOIN:</h4>
              <p>
                <b>Bài toán:</b> Tìm tất cả các đơn hàng và thông tin khách hàng
                tương ứng.
              </p>
              <div class="code-block">
                <span class="keyword">SELECT</span> <span class="column">o.order_id</span>, <span class="column">c.first_name</span>, <span class="column">c.last_name</span>, <span class="column">o.order_date</span>, <span class="column">o.total_amount</span>
                <span class="keyword">FROM</span> <span class="table">orders</span> <span class="column">o</span>
                <span class="keyword">INNER JOIN</span> <span class="table">customers</span> <span class="column">c</span> <span class="keyword">ON</span> <span class="column">o.customer_id</span> <span class="operator">=</span> <span class="column">c.customer_id</span>;
              </div>
              <p>
                <b>Kết quả:</b> Lệnh này sẽ chỉ trả về các đơn hàng có
                customer_id tồn tại trong bảng customers. Nếu có đơn hàng không
                có khách hàng (hoặc ngược lại), nó sẽ không xuất hiện trong kết
                quả.
              </p>
            </div>

            <div class="example">
              <h4>INNER JOIN với nhiều bảng:</h4>
              <div class="code-block">
                <span class="comment">-- Lấy thông tin đơn hàng, khách hàng và chi tiết sản phẩm</span>
                <span class="keyword">SELECT</span> <span class="column">o.order_id</span>, <span class="column">c.customer_name</span>, <span class="column">p.product_name</span>, 
                       <span class="column">od.quantity</span>, <span class="column">od.unit_price</span>, 
                       (<span class="column">od.quantity</span> <span class="operator">*</span> <span class="column">od.unit_price</span>) <span class="keyword">AS</span> <span class="column">line_total</span>
                <span class="keyword">FROM</span> <span class="table">orders</span> <span class="column">o</span>
                <span class="keyword">INNER JOIN</span> <span class="table">customers</span> <span class="column">c</span> <span class="keyword">ON</span> <span class="column">o.customer_id</span> <span class="operator">=</span> <span class="column">c.customer_id</span>
                <span class="keyword">INNER JOIN</span> <span class="table">order_details</span> <span class="column">od</span> <span class="keyword">ON</span> <span class="column">o.order_id</span> <span class="operator">=</span> <span class="column">od.order_id</span>
                <span class="keyword">INNER JOIN</span> <span class="table">products</span> <span class="column">p</span> <span class="keyword">ON</span> <span class="column">od.product_id</span> <span class="operator">=</span> <span class="column">p.product_id</span>
                <span class="keyword">WHERE</span> <span class="column">o.order_date</span> <span class="operator">>=</span> <span class="string">'2024-01-01'</span>;
              </div>
            </div>

            <h3>⬅️ 2. LEFT JOIN (LEFT OUTER JOIN)</h3>
            <div class="highlight-box">
              <p>
                <b>LEFT JOIN</b> trả về tất cả các hàng từ bảng bên trái (bảng
                đầu tiên trong FROM) và các hàng khớp từ bảng bên phải. Nếu
                không có sự khớp nào, các cột từ bảng bên phải sẽ có giá trị
                NULL.
              </p>
              <p>
                <b>Hoạt động:</b> Giữ lại tất cả các hàng từ bảng bên trái và
                tìm các hàng khớp từ bảng bên phải.
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ LEFT JOIN:</h4>
              <p>
                <b>Bài toán:</b> Lấy tất cả khách hàng và các đơn hàng của họ
                (nếu có).
              </p>
              <div class="code-block">
                <span class="keyword">SELECT</span> <span class="column">c.customer_id</span>, <span class="column">c.first_name</span>, <span class="column">c.last_name</span>, 
                       <span class="column">o.order_id</span>, <span class="column">o.order_date</span>, <span class="column">o.total_amount</span>
                <span class="keyword">FROM</span> <span class="table">customers</span> <span class="column">c</span>
                <span class="keyword">LEFT JOIN</span> <span class="table">orders</span> <span class="column">o</span> <span class="keyword">ON</span> <span class="column">c.customer_id</span> <span class="operator">=</span> <span class="column">o.customer_id</span>
                <span class="keyword">ORDER BY</span> <span class="column">c.customer_id</span>;
              </div>
              <p>
                <b>Kết quả:</b> Lệnh này sẽ trả về tất cả khách hàng. Những
                khách hàng đã có đơn hàng sẽ hiển thị order_id tương ứng, còn
                những khách hàng chưa có đơn hàng thì các cột đơn hàng sẽ là
                NULL.
              </p>
            </div>

            <div class="example">
              <h4>Tìm khách hàng chưa có đơn hàng:</h4>
              <div class="code-block">
                <span class="comment">-- Sử dụng LEFT JOIN để tìm khách hàng chưa mua hàng</span>
                <span class="keyword">SELECT</span> <span class="column">c.customer_id</span>, <span class="column">c.customer_name</span>, <span class="column">c.email</span>
                <span class="keyword">FROM</span> <span class="table">customers</span> <span class="column">c</span>
                <span class="keyword">LEFT JOIN</span> <span class="table">orders</span> <span class="column">o</span> <span class="keyword">ON</span> <span class="column">c.customer_id</span> <span class="operator">=</span> <span class="column">o.customer_id</span>
                <span class="keyword">WHERE</span> <span class="column">o.customer_id</span> <span class="keyword">IS NULL</span>; <span class="comment">-- Điều kiện để tìm khách hàng chưa có đơn hàng</span>
              </div>
            </div>

            <h3>➡️ 3. RIGHT JOIN (RIGHT OUTER JOIN)</h3>
            <div class="highlight-box">
              <p>
                <b>RIGHT JOIN</b> hoạt động tương tự như LEFT JOIN, nhưng nó giữ
                lại tất cả các hàng từ bảng bên phải. Nếu không có sự khớp nào,
                các cột từ bảng bên trái sẽ có giá trị NULL.
              </p>
              <p>
                <b>Hoạt động:</b> Giữ lại tất cả các hàng từ bảng bên phải và
                tìm các hàng khớp từ bảng bên trái.
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ RIGHT JOIN:</h4>
              <p>
                <b>Bài toán:</b> Lấy tất cả các đơn hàng và thông tin khách hàng
                của họ.
              </p>
              <div class="code-block">
                <span class="keyword">SELECT</span> <span class="column">o.order_id</span>, <span class="column">o.order_date</span>, <span class="column">c.first_name</span>, <span class="column">c.last_name</span>, <span class="column">c.email</span>
                <span class="keyword">FROM</span> <span class="table">customers</span> <span class="column">c</span>
                <span class="keyword">RIGHT JOIN</span> <span class="table">orders</span> <span class="column">o</span> <span class="keyword">ON</span> <span class="column">c.customer_id</span> <span class="operator">=</span> <span class="column">o.customer_id</span>
                <span class="keyword">ORDER BY</span> <span class="column">o.order_id</span>;
              </div>
              <p>
                <b>Kết quả:</b> Lệnh này sẽ trả về tất cả các đơn hàng. Nếu có
                đơn hàng nào không có khách hàng tương ứng (ví dụ: customer_id
                là NULL), thì các cột của khách hàng sẽ là NULL.
              </p>
            </div>

            <div class="example">
              <h4>Tìm đơn hàng không có khách hàng:</h4>
              <div class="code-block">
                -- Tìm đơn hàng có dữ liệu bất thường (không có customer_id hợp
                lệ) SELECT o.order_id, o.order_date, o.total_amount FROM
                customers c RIGHT JOIN orders o ON c.customer_id = o.customer_id
                WHERE c.customer_id IS NULL;
              </div>
            </div>

            <h3>🔄 4. FULL JOIN (FULL OUTER JOIN)</h3>
            <div class="highlight-box">
              <p>
                <b>FULL JOIN</b> trả về tất cả các hàng khi có sự khớp trong bất
                kỳ bảng nào. Các hàng không khớp sẽ hiển thị giá trị NULL ở các
                cột tương ứng.
              </p>
              <p><b>Hoạt động:</b> Kết hợp cả LEFT JOIN và RIGHT JOIN.</p>
            </div>

            <div class="example">
              <h4>Ví dụ FULL JOIN:</h4>
              <p>
                <b>Bài toán:</b> Lấy tất cả khách hàng và tất cả đơn hàng, hiển
                thị cả những khách hàng chưa có đơn hàng và những đơn hàng chưa
                có khách hàng.
              </p>
              <div class="code-block">
                <span class="keyword">SELECT</span> <span class="column">c.customer_id</span>, <span class="column">c.first_name</span>, <span class="column">c.last_name</span>, 
                       <span class="column">o.order_id</span>, <span class="column">o.order_date</span>, <span class="column">o.total_amount</span>
                <span class="keyword">FROM</span> <span class="table">customers</span> <span class="column">c</span>
                <span class="keyword">FULL JOIN</span> <span class="table">orders</span> <span class="column">o</span> <span class="keyword">ON</span> <span class="column">c.customer_id</span> <span class="operator">=</span> <span class="column">o.customer_id</span>
                <span class="keyword">ORDER BY</span> <span class="column">c.customer_id</span>, <span class="column">o.order_id</span>;
              </div>
              <p>
                <b>Kết quả:</b> Hiển thị tất cả khách hàng (kể cả chưa có đơn
                hàng) và tất cả đơn hàng (kể cả không có khách hàng).
              </p>
            </div>

            <div class="example">
              <h4>Phân tích dữ liệu với FULL JOIN:</h4>
              <div class="code-block">
                <span class="comment">-- Tìm tất cả các trường hợp bất thường</span>
                <span class="keyword">SELECT</span> 
                    <span class="keyword">CASE</span> 
                        <span class="keyword">WHEN</span> <span class="column">c.customer_id</span> <span class="keyword">IS NULL</span> <span class="keyword">THEN</span> <span class="string">'Đơn hàng không có khách hàng'</span>
                        <span class="keyword">WHEN</span> <span class="column">o.order_id</span> <span class="keyword">IS NULL</span> <span class="keyword">THEN</span> <span class="string">'Khách hàng chưa có đơn hàng'</span>
                        <span class="keyword">ELSE</span> <span class="string">'Dữ liệu bình thường'</span>
                    <span class="keyword">END</span> <span class="keyword">AS</span> <span class="column">data_status</span>,
                    <span class="column">c.customer_name</span>, <span class="column">o.order_id</span>, <span class="column">o.total_amount</span>
                <span class="keyword">FROM</span> <span class="table">customers</span> <span class="column">c</span>
                <span class="keyword">FULL JOIN</span> <span class="table">orders</span> <span class="column">o</span> <span class="keyword">ON</span> <span class="column">c.customer_id</span> <span class="operator">=</span> <span class="column">o.customer_id</span>
                <span class="keyword">WHERE</span> <span class="column">c.customer_id</span> <span class="keyword">IS NULL</span> <span class="keyword">OR</span> <span class="column">o.order_id</span> <span class="keyword">IS NULL</span>;
              </div>
            </div>

            <h3>❌ 5. CROSS JOIN</h3>
            <div class="highlight-box">
              <p>
                <b>CROSS JOIN</b> tạo ra một tích Đề-các (Cartesian product) của
                hai bảng. Nó kết hợp mọi hàng của bảng thứ nhất với mọi hàng của
                bảng thứ hai.
              </p>
              <p>
                <b>Hoạt động:</b> Không cần điều kiện ON. Nó tạo ra một tập hợp
                kết quả rất lớn.
              </p>
            </div>

            <div class="example">
              <h4>Ví dụ CROSS JOIN:</h4>
              <p>
                <b>Bài toán:</b> Lấy tất cả các sản phẩm và kết hợp với tất cả
                các thương hiệu.
              </p>
              <div class="code-block">
                <span class="keyword">SELECT</span> <span class="column">p.product_name</span>, <span class="column">b.brand_name</span>, 
                       <span class="function">CONCAT</span>(<span class="column">b.brand_name</span>, <span class="string">' - '</span>, <span class="column">p.product_name</span>) <span class="keyword">AS</span> <span class="column">full_product_name</span>
                <span class="keyword">FROM</span> <span class="table">products</span> <span class="column">p</span>
                <span class="keyword">CROSS JOIN</span> <span class="table">brands</span> <span class="column">b</span>;
              </div>
              <p>
                <b>Kết quả:</b> Nếu bảng products có 100 sản phẩm và bảng brands
                có 10 thương hiệu, kết quả sẽ có 1000 hàng. Loại JOIN này ít khi
                được sử dụng, thường dùng để kiểm tra hoặc tạo dữ liệu mẫu.
              </p>
            </div>

            <div class="example">
              <h4>Ứng dụng thực tế của CROSS JOIN:</h4>
              <div class="code-block">
                <span class="comment">-- Tạo lịch làm việc cho tất cả nhân viên trong tháng</span>
                <span class="keyword">SELECT</span> <span class="column">e.employee_name</span>, <span class="column">d.work_date</span>, <span class="string">'Available'</span> <span class="keyword">AS</span> <span class="column">status</span>
                <span class="keyword">FROM</span> <span class="table">employees</span> <span class="column">e</span>
                <span class="keyword">CROSS JOIN</span> (
                    <span class="keyword">SELECT</span> <span class="function">DATEADD</span>(<span class="keyword">DAY</span>, <span class="column">number</span>, <span class="string">'2025-01-01'</span>) <span class="keyword">AS</span> <span class="column">work_date</span>
                    <span class="keyword">FROM</span> <span class="table">master.dbo.spt_values</span> 
                    <span class="keyword">WHERE</span> <span class="column">type</span> <span class="operator">=</span> <span class="string">'P'</span> <span class="keyword">AND</span> <span class="column">number</span> <span class="operator"><</span> <span class="number">31</span>
                ) <span class="column">d</span>
                <span class="keyword">WHERE</span> <span class="function">DATEPART</span>(<span class="keyword">WEEKDAY</span>, <span class="column">d.work_date</span>) <span class="keyword">NOT IN</span> (<span class="number">1</span>, <span class="number">7</span>); <span class="comment">-- Loại bỏ chủ nhật và thứ 7</span>
              </div>
            </div>

            <h3>📊 So sánh các loại JOIN</h3>
            <table class="comparison-table">
              <thead>
                <tr>
                  <th>Loại JOIN</th>
                  <th>Kết quả</th>
                  <th>Khi nào sử dụng</th>
                  <th>NULL xuất hiện</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>INNER JOIN</b></td>
                  <td>Chỉ hàng khớp ở cả 2 bảng</td>
                  <td>Lấy dữ liệu có liên kết chắc chắn</td>
                  <td>Không</td>
                </tr>
                <tr>
                  <td><b>LEFT JOIN</b></td>
                  <td>Tất cả hàng bảng trái + khớp bảng phải</td>
                  <td>Giữ tất cả dữ liệu chính, tìm liên kết</td>
                  <td>Bảng phải</td>
                </tr>
                <tr>
                  <td><b>RIGHT JOIN</b></td>
                  <td>Tất cả hàng bảng phải + khớp bảng trái</td>
                  <td>Ít dùng, thường thay bằng LEFT JOIN</td>
                  <td>Bảng trái</td>
                </tr>
                <tr>
                  <td><b>FULL JOIN</b></td>
                  <td>Tất cả hàng từ cả 2 bảng</td>
                  <td>Phân tích đầy đủ, tìm dữ liệu thiếu</td>
                  <td>Cả 2 bảng</td>
                </tr>
                <tr>
                  <td><b>CROSS JOIN</b></td>
                  <td>Tích Đề-các của 2 bảng</td>
                  <td>Tạo dữ liệu mẫu, lịch làm việc</td>
                  <td>Không</td>
                </tr>
              </tbody>
            </table>

            <h3>🔧 Ví dụ thực tế: Hệ thống quản lý bán hàng</h3>
            <div class="example">
              <h4>Báo cáo doanh thu tổng hợp:</h4>
              <div class="code-block">
                -- Sử dụng nhiều loại JOIN trong một truy vấn SELECT
                s.store_name, c.customer_name, p.product_name,
                cat.category_name, o.order_date, od.quantity, od.unit_price,
                (od.quantity * od.unit_price) AS line_total, o.total_amount FROM
                stores s LEFT JOIN orders o ON s.store_id = o.store_id -- Giữ
                tất cả cửa hàng LEFT JOIN customers c ON o.customer_id =
                c.customer_id -- Thông tin khách hàng LEFT JOIN order_details od
                ON o.order_id = od.order_id -- Chi tiết đơn hàng LEFT JOIN
                products p ON od.product_id = p.product_id -- Thông tin sản phẩm
                LEFT JOIN categories cat ON p.category_id = cat.category_id --
                Danh mục WHERE o.order_date >= DATEADD(MONTH, -3, GETDATE()) --
                3 tháng gần đây ORDER BY s.store_name, o.order_date DESC;
              </div>
            </div>

            <div class="example">
              <h4>Phân tích khách hàng và đơn hàng:</h4>
              <div class="code-block">
                -- Tìm thông tin khách hàng và thống kê đơn hàng SELECT
                c.customer_id, c.customer_name, c.email, COUNT(o.order_id) AS
                total_orders, COALESCE(SUM(o.total_amount), 0) AS total_spent,
                COALESCE(AVG(o.total_amount), 0) AS avg_order_value,
                MAX(o.order_date) AS last_order_date, CASE WHEN
                COUNT(o.order_id) = 0 THEN 'Chưa mua hàng' WHEN
                COUNT(o.order_id) >= 10 THEN 'VIP' WHEN COUNT(o.order_id) >= 5
                THEN 'Thân thiết' ELSE 'Thường' END AS customer_tier FROM
                customers c LEFT JOIN orders o ON c.customer_id = o.customer_id
                GROUP BY c.customer_id, c.customer_name, c.email ORDER BY
                total_spent DESC;
              </div>
            </div>

            <h3>🔍 Self JOIN</h3>
            <div class="example">
              <h4>JOIN bảng với chính nó:</h4>
              <p><b>Bài toán:</b> Tìm nhân viên và người quản lý của họ.</p>
              <div class="code-block">
                -- Self JOIN để tìm quan hệ cấp bậc SELECT e.employee_name AS
                employee, m.employee_name AS manager, e.salary AS
                employee_salary, m.salary AS manager_salary FROM employees e
                LEFT JOIN employees m ON e.manager_id = m.employee_id ORDER BY
                m.employee_name, e.employee_name;
              </div>
            </div>

            <div class="success-box">
              <h4>💡 Best Practices cho JOIN:</h4>
              <ul>
                <li>
                  <b>Sử dụng alias:</b> Đặt tên ngắn gọn cho bảng (customers c,
                  orders o)
                </li>
                <li>
                  <b>Chỉ định cột rõ ràng:</b> Dùng table.column để tránh nhầm
                  lẫn
                </li>
                <li>
                  <b>Index:</b> Đảm bảo có index trên các cột JOIN để tăng hiệu
                  suất
                </li>
                <li>
                  <b>Điều kiện WHERE:</b> Đặt điều kiện lọc sau JOIN để tối ưu
                </li>
                <li><b>LEFT JOIN thay RIGHT JOIN:</b> Dễ đọc và hiểu hơn</li>
                <li>
                  <b>COALESCE/ISNULL:</b> Xử lý giá trị NULL từ OUTER JOIN
                </li>
              </ul>
            </div>

            <div class="info-box">
              <h4>⚠️ Lưu ý quan trọng:</h4>
              <ul>
                <li>
                  <b>Hiệu suất:</b> CROSS JOIN có thể tạo ra kết quả rất lớn,
                  cẩn thận khi sử dụng
                </li>
                <li>
                  <b>NULL values:</b> Luôn kiểm tra và xử lý NULL từ OUTER JOIN
                </li>
                <li>
                  <b>Duplicate keys:</b> Chú ý khi JOIN với bảng có khóa trùng
                  lặp
                </li>
                <li>
                  <b>Order of JOINs:</b> Thứ tự JOIN có thể ảnh hưởng đến hiệu
                  suất
                </li>
              </ul>
            </div>
          </section>

          <!-- 17 -->
          <section class="section" id="view">
            <h2>17. VIEW</h2>

            <div class="info-box">
              <h4>👁️ VIEW là gì?</h4>
              <p>
                <b>VIEW</b> có thể được xem như một
                <b>bảng ảo (virtual table)</b> dựa trên kết quả của một câu lệnh
                truy vấn SQL. Nó không chứa dữ liệu thực tế của chính nó mà chỉ
                là một <b>"cửa sổ"</b> để xem dữ liệu từ một hoặc nhiều bảng cơ
                sở. Mỗi khi bạn truy vấn một VIEW, hệ thống sẽ chạy lại câu lệnh
                SELECT đã định nghĩa để trả về kết quả mới nhất.
              </p>
            </div>

            <h3>🔧 Cú pháp tạo VIEW</h3>
            <div class="highlight-box">
              <div class="code-block">
                <span class="keyword">CREATE VIEW</span> <span class="table">view_name</span> <span class="keyword">AS</span>
                <span class="keyword">SELECT</span> <span class="column">column1</span>, <span class="column">column2</span>, ...
                <span class="keyword">FROM</span> <span class="table">table_name</span>
                <span class="keyword">WHERE</span> <span class="column">condition</span>;
              </div>
            </div>

            <h3>✅ Ưu điểm của VIEW</h3>
            <div class="success-box">
              <p>
                Sử dụng VIEW mang lại nhiều lợi ích quan trọng trong quản lý cơ
                sở dữ liệu:
              </p>

              <h4>1️⃣ Đơn giản hóa truy vấn</h4>
              <p>
                VIEW giúp bạn lưu trữ các truy vấn phức tạp (chứa JOIN, GROUP
                BY, v.v.) dưới một tên duy nhất. Thay vì phải viết lại toàn bộ
                câu lệnh phức tạp đó, bạn chỉ cần SELECT từ VIEW như thể nó là
                một bảng bình thường.
              </p>

              <h4>2️⃣ Tăng cường bảo mật</h4>
              <p>
                Bạn có thể giới hạn quyền truy cập của người dùng bằng cách cấp
                quyền cho họ truy vấn một VIEW thay vì toàn bộ các bảng cơ sở.
                VIEW có thể che giấu các cột hoặc hàng nhạy cảm mà người dùng
                không nên xem.
              </p>

              <h4>3️⃣ Đơn giản hóa cấu trúc</h4>
              <p>
                VIEW có thể được sử dụng để trình bày dữ liệu theo một cách dễ
                hiểu hơn cho người dùng cuối, mà không làm thay đổi cấu trúc của
                các bảng gốc.
              </p>

              <h4>4️⃣ Tính độc lập dữ liệu</h4>
              <p>
                Nếu cấu trúc của các bảng cơ sở thay đổi (ví dụ: một cột được
                đổi tên), bạn chỉ cần sửa đổi định nghĩa của VIEW chứ không cần
                phải cập nhật tất cả các ứng dụng đang sử dụng dữ liệu đó.
              </p>
            </div>

            <h3>📋 Ví dụ cơ bản</h3>
            <div class="example">
              <h4>Tạo VIEW cho thông tin đơn hàng khách hàng:</h4>
              <p>
                Giả sử bạn thường xuyên cần truy cập thông tin về các đơn hàng
                cùng với tên của khách hàng đã đặt. Thay vì phải viết một câu
                lệnh JOIN mỗi lần, bạn có thể tạo một VIEW để đơn giản hóa quá
                trình này.
              </p>
              <div class="code-block">
                <span class="keyword">CREATE VIEW</span> <span class="table">customer_orders</span> <span class="keyword">AS</span>
                <span class="keyword">SELECT</span> <span class="column">c.customer_id</span>, <span class="column">c.first_name</span>, <span class="column">c.last_name</span>, <span class="column">c.email</span>,
                       <span class="column">o.order_id</span>, <span class="column">o.order_date</span>, <span class="column">o.total_amount</span>
                <span class="keyword">FROM</span> <span class="table">customers</span> <span class="column">c</span>
                <span class="keyword">JOIN</span> <span class="table">orders</span> <span class="column">o</span> <span class="keyword">ON</span> <span class="column">c.customer_id</span> <span class="operator">=</span> <span class="column">o.customer_id</span>;
              </div>

              <h4>Giải thích:</h4>
              <ul>
                <li>
                  <b>CREATE VIEW customer_orders AS:</b> Tạo một VIEW có tên là
                  customer_orders
                </li>
                <li>
                  <b>SELECT ...:</b> Định nghĩa câu truy vấn để lấy dữ liệu từ
                  hai bảng customers và orders
                </li>
                <li>
                  <b>JOIN ...:</b> Nối hai bảng lại với nhau để lấy thông tin
                  khách hàng và đơn hàng tương ứng
                </li>
              </ul>
            </div>

            <div class="example">
              <h4>Sử dụng VIEW đã tạo:</h4>
              <p>
                Sau khi VIEW này được tạo, bạn có thể truy vấn nó một cách đơn
                giản như sau:
              </p>
              <div class="code-block">
                -- Truy vấn đơn giản như bảng thông thường SELECT * FROM
                customer_orders WHERE order_date >= '2024-01-01'; -- Lọc theo
                khách hàng cụ thể SELECT * FROM customer_orders WHERE
                customer_id = 123; -- Sắp xếp theo ngày đặt hàng SELECT * FROM
                customer_orders ORDER BY order_date DESC; -- Kết hợp với các
                điều kiện khác SELECT first_name, last_name, COUNT(*) AS
                total_orders, SUM(total_amount) AS total_spent FROM
                customer_orders WHERE order_date >= '2024-01-01' GROUP BY
                customer_id, first_name, last_name ORDER BY total_spent DESC;
              </div>
            </div>

            <h3>💼 Ví dụ thực tế nâng cao</h3>

            <div class="example">
              <h4>1. VIEW cho báo cáo doanh thu:</h4>
              <div class="code-block">
                CREATE VIEW monthly_sales_report AS SELECT YEAR(o.order_date) AS
                sales_year, MONTH(o.order_date) AS sales_month, DATENAME(MONTH,
                o.order_date) AS month_name, COUNT(o.order_id) AS total_orders,
                SUM(o.total_amount) AS total_revenue, AVG(o.total_amount) AS
                avg_order_value, COUNT(DISTINCT o.customer_id) AS
                unique_customers FROM orders o GROUP BY YEAR(o.order_date),
                MONTH(o.order_date), DATENAME(MONTH, o.order_date); -- Sử dụng
                VIEW SELECT * FROM monthly_sales_report WHERE sales_year = 2024
                ORDER BY sales_month;
              </div>
            </div>

            <div class="example">
              <h4>2. VIEW cho thông tin sản phẩm đầy đủ:</h4>
              <div class="code-block">
                CREATE VIEW product_details AS SELECT p.product_id,
                p.product_name, c.category_name, b.brand_name, p.list_price,
                p.stock_quantity, CASE WHEN p.stock_quantity = 0 THEN 'Hết hàng'
                WHEN p.stock_quantity < 10 THEN 'Sắp hết' ELSE 'Còn hàng' END AS
                stock_status, CONCAT(b.brand_name, ' - ', p.product_name) AS
                full_product_name FROM products p LEFT JOIN categories c ON
                p.category_id = c.category_id LEFT JOIN brands b ON p.brand_id =
                b.brand_id; -- Sử dụng để tìm sản phẩm sắp hết hàng SELECT *
                FROM product_details WHERE stock_status = 'Sắp hết' ORDER BY
                stock_quantity;
              </div>
            </div>

            <div class="example">
              <h4>3. VIEW cho thông tin nhân viên và hiệu suất:</h4>
              <div class="code-block">
                CREATE VIEW employee_performance AS SELECT e.employee_id,
                e.employee_name, d.department_name, e.hire_date, DATEDIFF(YEAR,
                e.hire_date, GETDATE()) AS years_of_service, COUNT(o.order_id)
                AS orders_handled, COALESCE(SUM(o.total_amount), 0) AS
                total_sales, COALESCE(AVG(o.total_amount), 0) AS avg_sale_amount
                FROM employees e LEFT JOIN departments d ON e.department_id =
                d.department_id LEFT JOIN orders o ON e.employee_id =
                o.sales_rep_id GROUP BY e.employee_id, e.employee_name,
                d.department_name, e.hire_date; -- Tìm nhân viên có hiệu suất
                tốt nhất SELECT TOP 5 * FROM employee_performance ORDER BY
                total_sales DESC;
              </div>
            </div>

            <h3>🛡️ VIEW cho bảo mật</h3>
            <div class="example">
              <h4>Tạo VIEW để ẩn thông tin nhạy cảm:</h4>
              <div class="code-block">
                -- VIEW cho phép khách hàng xem thông tin cá nhân (không có
                thông tin tài chính) CREATE VIEW customer_public_info AS SELECT
                customer_id, first_name, last_name, email, phone, city, state
                FROM customers; -- Không bao gồm: credit_card_number,
                bank_account, salary, etc. -- VIEW cho nhân viên sales (chỉ xem
                đơn hàng trong khu vực của họ) CREATE VIEW sales_rep_orders AS
                SELECT o.order_id, o.order_date, o.total_amount,
                c.customer_name, c.city FROM orders o JOIN customers c ON
                o.customer_id = c.customer_id JOIN employees e ON o.sales_rep_id
                = e.employee_id WHERE e.employee_id = USER_ID(); -- Chỉ hiển thị
                đơn hàng của nhân viên hiện tại
              </div>
            </div>

            <h3>🔧 Quản lý VIEW</h3>
            <div class="example">
              <h4>Các thao tác với VIEW:</h4>
              <div class="code-block">
                -- Xem định nghĩa của VIEW SELECT
                OBJECT_DEFINITION(OBJECT_ID('customer_orders')) AS
                view_definition; -- Sửa đổi VIEW ALTER VIEW customer_orders AS
                SELECT c.customer_id, CONCAT(c.first_name, ' ', c.last_name) AS
                full_name, c.email, o.order_id, o.order_date, o.total_amount,
                o.status FROM customers c JOIN orders o ON c.customer_id =
                o.customer_id WHERE o.status != 'Cancelled'; -- Thêm điều kiện
                lọc -- Xóa VIEW DROP VIEW customer_orders; -- Kiểm tra VIEW có
                tồn tại không IF OBJECT_ID('customer_orders', 'V') IS NOT NULL
                DROP VIEW customer_orders;
              </div>
            </div>

            <h3>📊 VIEW với tham số (SQL Server)</h3>
            <div class="example">
              <h4>Sử dụng Table-Valued Functions thay cho VIEW có tham số:</h4>
              <div class="code-block">
                <span class="comment"></span>-- Tạo function trả về table thay vì VIEW</span>
                <span class="keyword">CREATE FUNCTION</span> <span class="function">get_orders_by_date</span>(<span class="column">@start_date</span> <span class="datatype">DATE</span>, <span class="column">@end_date</span> <span class="datatype">DATE</span>) 
                <span class="keyword">RETURNS TABLE</span> 
                <span class="keyword">AS</span> 
                <span class="keyword">RETURN</span> (
                  <span class="keyword">SELECT</span> <span class="column">c.customer_name</span>, <span class="column">o.order_id</span>, <span class="column">o.order_date</span>, <span class="column">o.total_amount</span> 
                  <span class="keyword">FROM</span> <span class="table">customers</span> <span class="keyword">c</span> 
                  <span class="keyword">JOIN</span> <span class="table">orders</span> <span class="keyword">o</span> <span class="keyword">ON</span> <span class="column">c.customer_id</span> <span class="operator">=</span> <span class="column">o.customer_id</span> 
                  <span class="keyword">WHERE</span> <span class="column">o.order_date</span> <span class="keyword">BETWEEN</span> <span class="column">@start_date</span> <span class="keyword">AND</span> <span class="column">@end_date</span>
                );
                
                <span class="comment">-- Sử dụng function</span>
                <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="function">get_orders_by_date</span>(<span class="string">'2024-01-01'</span>, <span class="string">'2024-12-31'</span>);
              </div>
            </div>

            <h3>⚖️ VIEW vs Bảng thật</h3>
            <table class="comparison-table">
              <thead>
                <tr>
                  <th>Đặc điểm</th>
                  <th>VIEW</th>
                  <th>Bảng thật</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>Lưu trữ dữ liệu</b></td>
                  <td>Không lưu trữ, chỉ lưu định nghĩa</td>
                  <td>Lưu trữ dữ liệu thực tế</td>
                </tr>
                <tr>
                  <td><b>Hiệu suất</b></td>
                  <td>Chậm hơn (phải thực thi query mỗi lần)</td>
                  <td>Nhanh hơn (dữ liệu đã có sẵn)</td>
                </tr>
                <tr>
                  <td><b>Dung lượng</b></td>
                  <td>Không chiếm dung lượng dữ liệu</td>
                  <td>Chiếm dung lượng lưu trữ</td>
                </tr>
                <tr>
                  <td><b>Cập nhật dữ liệu</b></td>
                  <td>Luôn mới nhất (real-time)</td>
                  <td>Cần cập nhật thủ công</td>
                </tr>
                <tr>
                  <td><b>Bảo mật</b></td>
                  <td>Có thể ẩn dữ liệu nhạy cảm</td>
                  <td>Phải cấp quyền toàn bộ bảng</td>
                </tr>
                <tr>
                  <td><b>Indexing</b></td>
                  <td>Không thể tạo index trực tiếp</td>
                  <td>Có thể tạo index</td>
                </tr>
              </tbody>
            </table>

            <h3>🎯 Khi nào nên sử dụng VIEW</h3>
            <div class="success-box">
              <h4>✅ NÊN sử dụng VIEW khi:</h4>
              <ul>
                <li>
                  <b>Truy vấn phức tạp thường xuyên:</b> JOIN nhiều bảng, GROUP
                  BY phức tạp
                </li>
                <li>
                  <b>Bảo mật dữ liệu:</b> Cần ẩn một số cột hoặc hàng nhạy cảm
                </li>
                <li>
                  <b>Đơn giản hóa cho người dùng:</b> Tạo giao diện dễ sử dụng
                </li>
                <li>
                  <b>Tính độc lập:</b> Tách biệt ứng dụng khỏi cấu trúc bảng
                </li>
                <li><b>Báo cáo:</b> Tạo các view cho từng loại báo cáo</li>
              </ul>
            </div>

            <div class="info-box">
              <h4>❌ KHÔNG nên sử dụng VIEW khi:</h4>
              <ul>
                <li>
                  <b>Hiệu suất quan trọng:</b> Truy vấn cần tốc độ cao, dữ liệu
                  lớn
                </li>
                <li>
                  <b>Cập nhật thường xuyên:</b> Cần INSERT, UPDATE, DELETE phức
                  tạp
                </li>
                <li>
                  <b>Tính toán nặng:</b> Các phép tính phức tạp nên dùng Stored
                  Procedure
                </li>
                <li><b>Dữ liệu tạm:</b> Dữ liệu chỉ sử dụng một lần</li>
              </ul>
            </div>

            <div class="highlight-box">
              <h4>💡 Best Practices cho VIEW:</h4>
              <ul>
                <li>
                  <b>Đặt tên có ý nghĩa:</b> Sử dụng prefix như v_ hoặc view_
                </li>
                <li><b>Document VIEW:</b> Ghi chú mục đích và cách sử dụng</li>
                <li>
                  <b>Tối ưu truy vấn:</b> Đảm bảo các bảng cơ sở có index phù
                  hợp
                </li>
                <li><b>Kiểm tra hiệu suất:</b> Test với dữ liệu thực tế</li>
                <li>
                  <b>Phân quyền đúng:</b> Chỉ cấp quyền cần thiết cho từng user
                </li>
                <li>
                  <b>Review định kỳ:</b> Kiểm tra và cập nhật VIEW khi cần
                </li>
              </ul>
            </div>
          </section>

          <!-- 18 -->
          <section class="section" id="subquery">
            <h2>18. SUBQUERY</h2>

            <div class="info-box">
              <h4>🔍 Subquery là gì?</h4>
              <p>
                <b>Subquery (truy vấn con)</b> là một câu lệnh SELECT nằm bên
                trong một câu lệnh SQL khác. Nó còn được gọi là
                <b>truy vấn lồng nhau (nested query)</b> hoặc
                <b>truy vấn bên trong (inner query)</b>. Kết quả của truy vấn
                con được sử dụng bởi truy vấn bên ngoài (outer query).
              </p>
              <p>
                Subquery thường được đặt trong dấu ngoặc đơn <code>()</code> và
                có thể xuất hiện trong nhiều mệnh đề khác nhau của câu lệnh SQL,
                như <b>WHERE</b>, <b>FROM</b>, hoặc <b>SELECT</b>.
              </p>
            </div>

            <h3>⚙️ Cách hoạt động và các loại Subquery</h3>
            <div class="highlight-box">
              <h4>🔄 Hoạt động:</h4>
              <p>
                Hệ thống sẽ <b>thực thi truy vấn con trước</b>. Sau đó, kết quả
                từ truy vấn con sẽ được đưa vào truy vấn chính để thực thi.
              </p>

              <h4>📋 Các loại phổ biến:</h4>
              <ul>
                <li>
                  <b>Subquery trong mệnh đề WHERE:</b> Đây là cách sử dụng phổ
                  biến nhất, dùng để lọc dữ liệu của truy vấn chính
                </li>
                <li>
                  <b>Subquery trong mệnh đề FROM:</b> Kết quả của truy vấn con
                  được coi như một bảng tạm thời
                </li>
                <li>
                  <b>Subquery trong mệnh đề SELECT:</b> Trả về một giá trị duy
                  nhất cho mỗi hàng của truy vấn chính
                </li>
              </ul>
            </div>

            <h3>🔍 1. Subquery trong mệnh đề WHERE</h3>
            <div class="example">
              <h4>Ví dụ cơ bản:</h4>
              <p>
                <b>Bài toán:</b> Tìm tên của tất cả những khách hàng đã đặt đơn
                hàng sau ngày 01/01/2025.
              </p>

              <p><b>Cách tiếp cận truyền thống (2 bước):</b></p>
              <div class="code-block">
                -- Bước 1: Tìm customer_id của các đơn hàng thỏa mãn điều kiện
                SELECT customer_id FROM orders WHERE order_date > '2025-01-01';
                -- Bước 2: Sử dụng kết quả để tìm tên khách hàng -- (Phải
                copy-paste kết quả từ bước 1)
              </div>

              <p><b>Cách sử dụng Subquery (1 bước):</b></p>
              <div class="code-block">
                SELECT first_name, last_name FROM customers WHERE customer_id IN
                ( SELECT customer_id FROM orders WHERE order_date > '2025-01-01'
                );
              </div>

              <h4>Giải thích:</h4>
              <ul>
                <li>
                  <b>Truy vấn con:</b>
                  <code
                    >(SELECT customer_id FROM orders WHERE order_date >
                    '2025-01-01')</code
                  >
                  sẽ được thực thi trước. Nó trả về một danh sách các ID khách
                  hàng (ví dụ: 101, 105, 110)
                </li>
                <li>
                  <b>Truy vấn chính:</b> Sau đó, truy vấn chính sẽ sử dụng kết
                  quả này và lọc bảng customers để chỉ lấy những khách hàng có
                  customer_id nằm trong danh sách đó
                </li>
              </ul>
            </div>

            <div class="example">
              <h4>Các toán tử với Subquery trong WHERE:</h4>
              <div class="code-block">
                -- 1. IN - Kiểm tra giá trị có trong danh sách không SELECT
                product_name FROM products WHERE category_id IN ( SELECT
                category_id FROM categories WHERE category_name IN
                ('Electronics', 'Clothing') ); -- 2. NOT IN - Kiểm tra giá trị
                không có trong danh sách SELECT customer_name FROM customers
                WHERE customer_id NOT IN ( SELECT DISTINCT customer_id FROM
                orders WHERE order_date >= '2024-01-01' ); -- 3. EXISTS - Kiểm
                tra subquery có trả về kết quả không SELECT c.customer_name FROM
                customers c WHERE EXISTS ( SELECT 1 FROM orders o WHERE
                o.customer_id = c.customer_id AND o.total_amount > 1000 ); -- 4.
                NOT EXISTS - Kiểm tra subquery không trả về kết quả SELECT
                c.customer_name FROM customers c WHERE NOT EXISTS ( SELECT 1
                FROM orders o WHERE o.customer_id = c.customer_id ); -- 5. So
                sánh với giá trị đơn (=, >, <, >=, <=) SELECT employee_name,
                salary FROM employees WHERE salary > ( SELECT AVG(salary) FROM
                employees );
              </div>
            </div>

            <h3>📊 2. Subquery trong mệnh đề FROM</h3>
            <div class="example">
              <h4>Subquery như bảng tạm:</h4>
              <p>
                <b>Bài toán:</b> Tìm thông tin khách hàng và tổng số đơn hàng
                của họ, chỉ hiển thị những khách hàng có từ 3 đơn hàng trở lên.
              </p>
              <div class="code-block">
                SELECT c.customer_name, c.email, customer_stats.total_orders,
                customer_stats.total_spent FROM customers c JOIN ( SELECT
                customer_id, COUNT(*) AS total_orders, SUM(total_amount) AS
                total_spent FROM orders GROUP BY customer_id HAVING COUNT(*) >=
                3 ) AS customer_stats ON c.customer_id =
                customer_stats.customer_id ORDER BY customer_stats.total_spent
                DESC;
              </div>
              <p>
                <b>Giải thích:</b> Subquery trong FROM tạo ra một "bảng tạm"
                chứa thống kê của khách hàng, sau đó JOIN với bảng customers để
                lấy thông tin đầy đủ.
              </p>
            </div>

            <div class="example">
              <h4>Subquery phức tạp trong FROM:</h4>
              <div class="code-block">
                -- Báo cáo doanh thu theo tháng với so sánh tháng trước SELECT
                current_month.month_year, current_month.monthly_revenue,
                COALESCE(previous_month.monthly_revenue, 0) AS
                previous_month_revenue, current_month.monthly_revenue -
                COALESCE(previous_month.monthly_revenue, 0) AS
                revenue_difference FROM ( SELECT FORMAT(order_date, 'yyyy-MM')
                AS month_year, SUM(total_amount) AS monthly_revenue FROM orders
                GROUP BY FORMAT(order_date, 'yyyy-MM') ) AS current_month LEFT
                JOIN ( SELECT FORMAT(DATEADD(MONTH, 1, order_date), 'yyyy-MM')
                AS next_month, SUM(total_amount) AS monthly_revenue FROM orders
                GROUP BY FORMAT(DATEADD(MONTH, 1, order_date), 'yyyy-MM') ) AS
                previous_month ON current_month.month_year =
                previous_month.next_month ORDER BY current_month.month_year;
              </div>
            </div>

            <h3>📈 3. Subquery trong mệnh đề SELECT</h3>
            <div class="example">
              <h4>Subquery trả về giá trị đơn:</h4>
              <div class="code-block">
                -- Hiển thị thông tin sản phẩm kèm theo tổng số lượng đã bán
                SELECT p.product_id, p.product_name, p.list_price,
                p.stock_quantity, (SELECT COUNT(*) FROM order_details od WHERE
                od.product_id = p.product_id) AS times_sold, (SELECT
                COALESCE(SUM(od.quantity), 0) FROM order_details od WHERE
                od.product_id = p.product_id) AS total_quantity_sold, (SELECT
                AVG(od.unit_price) FROM order_details od WHERE od.product_id =
                p.product_id) AS avg_selling_price FROM products p ORDER BY
                times_sold DESC;
              </div>
            </div>

            <div class="example">
              <h4>Subquery với điều kiện phức tạp trong SELECT:</h4>
              <div class="code-block">
                -- Thông tin khách hàng với thống kê chi tiết SELECT
                c.customer_id, c.customer_name, c.email, (SELECT COUNT(*) FROM
                orders o WHERE o.customer_id = c.customer_id) AS total_orders,
                (SELECT COALESCE(MAX(o.order_date), 'Chưa có đơn hàng') FROM
                orders o WHERE o.customer_id = c.customer_id) AS
                last_order_date, (SELECT COALESCE(SUM(o.total_amount), 0) FROM
                orders o WHERE o.customer_id = c.customer_id) AS total_spent,
                CASE WHEN (SELECT COUNT(*) FROM orders o WHERE o.customer_id =
                c.customer_id) = 0 THEN 'Chưa mua hàng' WHEN (SELECT
                SUM(o.total_amount) FROM orders o WHERE o.customer_id =
                c.customer_id) > 10000 THEN 'VIP' WHEN (SELECT COUNT(*) FROM
                orders o WHERE o.customer_id = c.customer_id) >= 5 THEN 'Thân
                thiết' ELSE 'Thường' END AS customer_tier FROM customers c ORDER
                BY total_spent DESC;
              </div>
            </div>

            <h3>🔄 4. Correlated Subquery (Subquery có tương quan)</h3>
            <div class="example">
              <h4>Subquery tham chiếu đến bảng bên ngoài:</h4>
              <div class="code-block">
                -- Tìm nhân viên có lương cao nhất trong mỗi phòng ban SELECT
                e1.employee_name, e1.department_id, e1.salary FROM employees e1
                WHERE e1.salary = ( SELECT MAX(e2.salary) FROM employees e2
                WHERE e2.department_id = e1.department_id -- Tương quan với bảng
                ngoài ); -- Tìm sản phẩm có giá cao hơn giá trung bình trong
                cùng danh mục SELECT p1.product_name, p1.category_id,
                p1.list_price, (SELECT AVG(p2.list_price) FROM products p2 WHERE
                p2.category_id = p1.category_id) AS avg_category_price FROM
                products p1 WHERE p1.list_price > ( SELECT AVG(p2.list_price)
                FROM products p2 WHERE p2.category_id = p1.category_id );
              </div>
            </div>

            <h3>🎯 5. Subquery với ANY, ALL, SOME</h3>
            <div class="example">
              <h4>So sánh với nhiều giá trị:</h4>
              <div class="code-block">
                -- ANY/SOME: Thỏa mãn ít nhất một giá trị trong subquery SELECT
                product_name, list_price FROM products WHERE list_price > ANY (
                SELECT AVG(list_price) FROM products GROUP BY category_id ); --
                ALL: Thỏa mãn tất cả giá trị trong subquery SELECT product_name,
                list_price FROM products WHERE list_price > ALL ( SELECT
                AVG(list_price) FROM products GROUP BY category_id ); -- Ví dụ
                thực tế: Tìm khách hàng có đơn hàng lớn hơn bất kỳ đơn hàng nào
                của khách hàng VIP SELECT DISTINCT c.customer_name FROM
                customers c JOIN orders o ON c.customer_id = o.customer_id WHERE
                o.total_amount > ANY ( SELECT o2.total_amount FROM orders o2
                JOIN customers c2 ON o2.customer_id = c2.customer_id WHERE
                c2.customer_tier = 'VIP' );
              </div>
            </div>

            <h3>✅ Ưu điểm của Subquery</h3>
            <div class="success-box">
              <h4>🎯 Lợi ích chính:</h4>
              <ul>
                <li>
                  <b>Dễ đọc và dễ hiểu hơn:</b> Trong một số trường hợp, việc sử
                  dụng subquery có thể làm cho câu lệnh SQL trở nên dễ đọc và
                  diễn giải logic hơn so với việc sử dụng JOIN
                </li>
                <li>
                  <b>Linh hoạt:</b> Subquery có thể giải quyết các vấn đề phức
                  tạp mà JOIN không thể làm được một cách trực tiếp
                </li>
                <li>
                  <b>Thực hiện các phép tính phức tạp:</b> Chúng cho phép bạn
                  lọc dữ liệu dựa trên các kết quả tổng hợp của một bảng khác
                </li>
                <li>
                  <b>Modular:</b> Có thể test và debug từng phần riêng biệt
                </li>
              </ul>
            </div>

            <h3>⚖️ Subquery vs JOIN</h3>
            <table class="comparison-table">
              <thead>
                <tr>
                  <th>Tiêu chí</th>
                  <th>Subquery</th>
                  <th>JOIN</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>Hiệu suất</b></td>
                  <td>Chậm hơn (đặc biệt correlated)</td>
                  <td>Nhanh hơn với index phù hợp</td>
                </tr>
                <tr>
                  <td><b>Dễ đọc</b></td>
                  <td>Dễ hiểu logic, rõ ràng</td>
                  <td>Có thể phức tạp với nhiều bảng</td>
                </tr>
                <tr>
                  <td><b>Linh hoạt</b></td>
                  <td>Có thể dùng trong SELECT, WHERE, FROM</td>
                  <td>Chỉ trong FROM clause</td>
                </tr>
                <tr>
                  <td><b>Kết quả</b></td>
                  <td>Có thể trả về giá trị đơn</td>
                  <td>Luôn trả về tập hợp</td>
                </tr>
                <tr>
                  <td><b>Correlated</b></td>
                  <td>Hỗ trợ tham chiếu bảng ngoài</td>
                  <td>Không tham chiếu được</td>
                </tr>
              </tbody>
            </table>

            <h3>🔧 Ví dụ thực tế: Phân tích bán hàng</h3>
            <div class="example">
              <h4>Query phức tạp kết hợp nhiều loại Subquery:</h4>
              <div class="code-block">
                -- Báo cáo toàn diện về hiệu suất bán hàng SELECT
                monthly_sales.month_year, monthly_sales.total_revenue,
                monthly_sales.total_orders, monthly_sales.avg_order_value, --
                Subquery trong SELECT: So sánh với tháng trước (SELECT
                ms2.total_revenue FROM ( SELECT FORMAT(order_date, 'yyyy-MM') AS
                month_year, SUM(total_amount) AS total_revenue FROM orders GROUP
                BY FORMAT(order_date, 'yyyy-MM') ) ms2 WHERE ms2.month_year =
                FORMAT(DATEADD(MONTH, -1, monthly_sales.month_year + '-01'),
                'yyyy-MM') ) AS previous_month_revenue, -- Tính phần trăm tăng
                trưởng CASE WHEN (SELECT ms2.total_revenue FROM (SELECT
                FORMAT(order_date, 'yyyy-MM') AS month_year, SUM(total_amount)
                AS total_revenue FROM orders GROUP BY FORMAT(order_date,
                'yyyy-MM')) ms2 WHERE ms2.month_year = FORMAT(DATEADD(MONTH, -1,
                monthly_sales.month_year + '-01'), 'yyyy-MM')) > 0 THEN ROUND(
                (monthly_sales.total_revenue - (SELECT ms2.total_revenue FROM
                (SELECT FORMAT(order_date, 'yyyy-MM') AS month_year,
                SUM(total_amount) AS total_revenue FROM orders GROUP BY
                FORMAT(order_date, 'yyyy-MM')) ms2 WHERE ms2.month_year =
                FORMAT(DATEADD(MONTH, -1, monthly_sales.month_year + '-01'),
                'yyyy-MM')) ) * 100.0 / (SELECT ms2.total_revenue FROM (SELECT
                FORMAT(order_date, 'yyyy-MM') AS month_year, SUM(total_amount)
                AS total_revenue FROM orders GROUP BY FORMAT(order_date,
                'yyyy-MM')) ms2 WHERE ms2.month_year = FORMAT(DATEADD(MONTH, -1,
                monthly_sales.month_year + '-01'), 'yyyy-MM')), 2) ELSE NULL END
                AS growth_percentage FROM ( -- Subquery trong FROM: Thống kê
                theo tháng SELECT FORMAT(order_date, 'yyyy-MM') AS month_year,
                SUM(total_amount) AS total_revenue, COUNT(*) AS total_orders,
                AVG(total_amount) AS avg_order_value FROM orders WHERE
                order_date >= DATEADD(YEAR, -1, GETDATE()) -- 12 tháng gần đây
                GROUP BY FORMAT(order_date, 'yyyy-MM') ) AS monthly_sales --
                Subquery trong WHERE: Chỉ hiển thị tháng có doanh thu > trung
                bình WHERE monthly_sales.total_revenue > ( SELECT
                AVG(monthly_revenue) FROM ( SELECT SUM(total_amount) AS
                monthly_revenue FROM orders WHERE order_date >= DATEADD(YEAR,
                -1, GETDATE()) GROUP BY FORMAT(order_date, 'yyyy-MM') ) AS
                avg_calc ) ORDER BY monthly_sales.month_year DESC;
              </div>
            </div>

            <div class="info-box">
              <h4>💡 Best Practices cho Subquery:</h4>
              <ul>
                <li>
                  <b>Tối ưu hiệu suất:</b> Tránh correlated subquery nếu có thể,
                  sử dụng JOIN thay thế
                </li>
                <li>
                  <b>Index:</b> Đảm bảo có index trên các cột được sử dụng trong
                  subquery
                </li>
                <li>
                  <b>NULL handling:</b> Chú ý với NOT IN khi có giá trị NULL
                </li>
                <li>
                  <b>Test riêng biệt:</b> Chạy thử subquery độc lập để kiểm tra
                  kết quả
                </li>
                <li><b>Comment:</b> Ghi chú rõ ràng cho subquery phức tạp</li>
                <li>
                  <b>Giới hạn depth:</b> Tránh lồng quá nhiều tầng subquery
                </li>
              </ul>
            </div>

            <div class="highlight-box">
              <h4>⚠️ Lưu ý quan trọng:</h4>
              <p>
                Mặc dù <b>JOIN thường hiệu quả hơn về mặt hiệu suất</b>, nhưng
                subquery vẫn là một công cụ mạnh mẽ và không thể thiếu đối với
                các nhà phát triển cơ sở dữ liệu. Chọn phương pháp phù hợp dựa
                trên độ phức tạp của logic và yêu cầu hiệu suất.
              </p>
            </div>
          </section>

          <!-- 19 -->
          <section class="section" id="ranking">
            <h2>19. Ranking & Window</h2>

            <div class="info-box">
              <h4>🪟 Window Functions là gì?</h4>
              <p>
                <b>Window Functions (hàm cửa sổ)</b> thực hiện một phép tính
                trên một tập hợp các hàng liên quan đến hàng hiện tại. Không
                giống như các hàm tổng hợp thông thường (GROUP BY), hàm cửa sổ
                <b>không gom các hàng lại</b> mà thay vào đó, nó
                <b>thêm một cột mới</b> vào kết quả của truy vấn với giá trị
                được tính toán.
              </p>
              <p>
                Các hàm này rất hữu ích để
                <b>xếp hạng, phân tích và so sánh dữ liệu</b> trong các phân
                đoạn hoặc "cửa sổ" của dữ liệu.
              </p>
            </div>

            <h3>🏆 Các hàm Ranking phổ biến</h3>
            <div class="highlight-box">
              <p>
                Các hàm xếp hạng được dùng để gán một <b>thứ hạng</b> cho mỗi
                hàng trong một tập kết quả.
              </p>
            </div>

            <h4>1️⃣ ROW_NUMBER()</h4>
            <div class="example">
              <p><b>Chức năng:</b></p>
              <ul>
                <li>
                  Gán một số thứ tự <b>duy nhất và liên tiếp</b> cho mỗi hàng
                  trong một phân vùng
                </li>
                <li>Thứ tự này bắt đầu từ <b>1</b></li>
                <li><b>Không có hai hàng nào có cùng ROW_NUMBER()</b></li>
              </ul>

              <div class="code-block">
                -- Ví dụ cơ bản: Đánh số thứ tự sản phẩm theo giá giảm dần
                SELECT product_id, product_name, list_price, ROW_NUMBER() OVER
                (ORDER BY list_price DESC) AS row_num FROM products;
              </div>
              <p>
                <b>Kết quả:</b> Lệnh này sẽ đánh số thứ tự cho tất cả các sản
                phẩm, từ 1 đến N, dựa trên giá sản phẩm (list_price) theo thứ tự
                giảm dần.
              </p>
            </div>

            <div class="example">
              <h4>ROW_NUMBER() với PARTITION BY:</h4>
              <div class="code-block">
                -- Đánh số thứ tự sản phẩm trong từng danh mục SELECT
                product_id, product_name, category_id, list_price, ROW_NUMBER()
                OVER (PARTITION BY category_id ORDER BY list_price DESC) AS
                row_num_in_category FROM products ORDER BY category_id,
                row_num_in_category;
              </div>
              <p>
                <b>Giải thích:</b> Việc đánh số sẽ được reset lại cho mỗi
                category_id. Sản phẩm đắt nhất trong danh mục 1 sẽ có row_num =
                1, và sản phẩm đắt nhất trong danh mục 2 cũng sẽ có row_num = 1.
              </p>
            </div>

            <h4>2️⃣ RANK()</h4>
            <div class="example">
              <p><b>Chức năng:</b></p>
              <ul>
                <li>
                  Gán một <b>thứ hạng</b> cho mỗi hàng trong một phân vùng
                </li>
                <li>
                  Nếu hai hoặc nhiều hàng có cùng giá trị, chúng sẽ nhận
                  <b>cùng một thứ hạng</b>
                </li>
                <li>
                  Thứ hạng tiếp theo sẽ <b>bị bỏ qua (có "khoảng trống")</b>
                </li>
              </ul>

              <div class="code-block">
                -- Xếp hạng nhân viên theo lương SELECT employee_id,
                employee_name, salary, RANK() OVER (ORDER BY salary DESC) AS
                salary_rank FROM employees;
              </div>
              <p>
                <b>Ví dụ kết quả:</b> Nếu hai nhân viên có cùng lương cao nhất
                (100,000), cả hai sẽ nhận hạng 1, và nhân viên tiếp theo sẽ có
                hạng 3 (bỏ qua hạng 2).
              </p>

              <table style="margin: 10px 0">
                <thead>
                  <tr>
                    <th>employee_name</th>
                    <th>salary</th>
                    <th>salary_rank</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>John</td>
                    <td>100,000</td>
                    <td>1</td>
                  </tr>
                  <tr>
                    <td>Jane</td>
                    <td>100,000</td>
                    <td>1</td>
                  </tr>
                  <tr>
                    <td>Bob</td>
                    <td>95,000</td>
                    <td>3</td>
                  </tr>
                  <tr>
                    <td>Alice</td>
                    <td>90,000</td>
                    <td>4</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <h4>3️⃣ DENSE_RANK()</h4>
            <div class="example">
              <p><b>Chức năng:</b></p>
              <ul>
                <li>
                  Giống như RANK(), nhưng <b>không bỏ qua thứ hạng</b> sau khi
                  có giá trị trùng lặp
                </li>
                <li><b>Không có "khoảng trống"</b> trong thứ hạng</li>
              </ul>

              <div class="code-block">
                -- Xếp hạng sản phẩm theo giá với DENSE_RANK SELECT product_id,
                product_name, list_price, DENSE_RANK() OVER (ORDER BY list_price
                DESC) AS price_dense_rank FROM products;
              </div>
              <p>
                <b>Ví dụ kết quả:</b> Nếu hai sản phẩm có cùng giá cao nhất, cả
                hai sẽ nhận hạng 1, và sản phẩm tiếp theo sẽ có hạng 2 (không bỏ
                qua).
              </p>

              <table style="margin: 10px 0">
                <thead>
                  <tr>
                    <th>product_name</th>
                    <th>list_price</th>
                    <th>price_dense_rank</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>Product A</td>
                    <td>500</td>
                    <td>1</td>
                  </tr>
                  <tr>
                    <td>Product B</td>
                    <td>500</td>
                    <td>1</td>
                  </tr>
                  <tr>
                    <td>Product C</td>
                    <td>450</td>
                    <td>2</td>
                  </tr>
                  <tr>
                    <td>Product D</td>
                    <td>400</td>
                    <td>3</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <h3>📊 So sánh 3 hàm Ranking</h3>
            <table>
              <thead>
                <tr>
                  <th>Hàm</th>
                  <th>Xử lý giá trị trùng</th>
                  <th>Thứ hạng tiếp theo</th>
                  <th>Khi nào sử dụng</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>ROW_NUMBER()</b></td>
                  <td>Gán số khác nhau (tùy ý)</td>
                  <td>Liên tiếp (1,2,3,4...)</td>
                  <td>Cần số thứ tự duy nhất</td>
                </tr>
                <tr>
                  <td><b>RANK()</b></td>
                  <td>Gán cùng hạng</td>
                  <td>Bỏ qua (1,1,3,4...)</td>
                  <td>Xếp hạng thi đấu thể thao</td>
                </tr>
                <tr>
                  <td><b>DENSE_RANK()</b></td>
                  <td>Gán cùng hạng</td>
                  <td>Liên tiếp (1,1,2,3...)</td>
                  <td>Phân loại, nhóm mức độ</td>
                </tr>
              </tbody>
            </table>

            <h3>🔧 Mệnh đề OVER và PARTITION BY</h3>
            <div class="highlight-box">
              <h4>📋 OVER():</h4>
              <ul>
                <li>Đây là một phần <b>bắt buộc</b> của hàm cửa sổ</li>
                <li>
                  Nó xác định <b>"cửa sổ"</b> hoặc tập hợp các hàng mà hàm sẽ
                  hoạt động trên đó
                </li>
                <li>
                  <b>ORDER BY bên trong OVER():</b> Xác định thứ tự sắp xếp của
                  các hàng trong "cửa sổ"
                </li>
              </ul>

              <h4>📋 PARTITION BY:</h4>
              <ul>
                <li>Là một mệnh đề <b>tùy chọn</b> bên trong OVER()</li>
                <li>
                  Nó chia tập kết quả thành các <b>phân vùng hoặc nhóm</b>
                </li>
                <li>
                  Mỗi hàm xếp hạng sẽ được <b>tính toán lại từ đầu</b> cho mỗi
                  phân vùng
                </li>
              </ul>
            </div>

            <div class="example">
              <h4>Ví dụ tổng hợp với PARTITION BY:</h4>
              <div class="code-block">
                SELECT product_id, product_name, category_id, list_price, -- Xếp
                hạng trong toàn bộ bảng ROW_NUMBER() OVER (ORDER BY list_price
                DESC) AS overall_row_num, RANK() OVER (ORDER BY list_price DESC)
                AS overall_rank, DENSE_RANK() OVER (ORDER BY list_price DESC) AS
                overall_dense_rank, -- Xếp hạng trong từng danh mục ROW_NUMBER()
                OVER (PARTITION BY category_id ORDER BY list_price DESC) AS
                category_row_num, RANK() OVER (PARTITION BY category_id ORDER BY
                list_price DESC) AS category_rank, DENSE_RANK() OVER (PARTITION
                BY category_id ORDER BY list_price DESC) AS category_dense_rank
                FROM products ORDER BY category_id, list_price DESC;
              </div>
            </div>

            <h3>📈 Các Window Functions khác</h3>

            <h4>🔢 NTILE() - Chia thành nhóm</h4>
            <div class="example">
              <p>
                <b>Chức năng:</b> Chia tập kết quả thành N nhóm (tiles) có kích
                thước gần bằng nhau.
              </p>
              <div class="code-block">
                -- Chia khách hàng thành 4 nhóm theo tổng chi tiêu SELECT
                customer_id, customer_name, total_spent, NTILE(4) OVER (ORDER BY
                total_spent DESC) AS spending_quartile FROM ( SELECT
                c.customer_id, c.customer_name, COALESCE(SUM(o.total_amount), 0)
                AS total_spent FROM customers c LEFT JOIN orders o ON
                c.customer_id = o.customer_id GROUP BY c.customer_id,
                c.customer_name ) customer_spending ORDER BY total_spent DESC;
              </div>
              <p>
                <b>Ứng dụng:</b> Phân khúc khách hàng (quartile 1 = VIP,
                quartile 4 = ít chi tiêu)
              </p>
            </div>

            <h4>⬆️⬇️ LAG() và LEAD() - Truy cập hàng trước/sau</h4>
            <div class="example">
              <p>
                <b>Chức năng:</b> LAG() lấy giá trị từ hàng trước, LEAD() lấy
                giá trị từ hàng sau.
              </p>
              <div class="code-block">
                -- So sánh doanh thu tháng hiện tại với tháng trước SELECT
                sales_month, monthly_revenue, LAG(monthly_revenue, 1) OVER
                (ORDER BY sales_month) AS previous_month_revenue,
                LEAD(monthly_revenue, 1) OVER (ORDER BY sales_month) AS
                next_month_revenue, -- Tính phần trăm tăng trưởng CASE WHEN
                LAG(monthly_revenue, 1) OVER (ORDER BY sales_month) > 0 THEN
                ROUND( (monthly_revenue - LAG(monthly_revenue, 1) OVER (ORDER BY
                sales_month)) * 100.0 / LAG(monthly_revenue, 1) OVER (ORDER BY
                sales_month), 2 ) ELSE NULL END AS growth_percentage FROM (
                SELECT FORMAT(order_date, 'yyyy-MM') AS sales_month,
                SUM(total_amount) AS monthly_revenue FROM orders GROUP BY
                FORMAT(order_date, 'yyyy-MM') ) monthly_sales ORDER BY
                sales_month;
              </div>
            </div>

            <h4>🎯 FIRST_VALUE() và LAST_VALUE()</h4>
            <div class="example">
              <p>
                <b>Chức năng:</b> Lấy giá trị đầu tiên và cuối cùng trong
                window.
              </p>
              <div class="code-block">
                -- So sánh giá sản phẩm với giá cao nhất và thấp nhất trong danh
                mục SELECT product_id, product_name, category_id, list_price,
                FIRST_VALUE(list_price) OVER ( PARTITION BY category_id ORDER BY
                list_price DESC ROWS UNBOUNDED PRECEDING ) AS
                highest_price_in_category, LAST_VALUE(list_price) OVER (
                PARTITION BY category_id ORDER BY list_price DESC ROWS BETWEEN
                UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ) AS
                lowest_price_in_category, -- Tính phần trăm so với giá cao nhất
                ROUND( list_price * 100.0 / FIRST_VALUE(list_price) OVER (
                PARTITION BY category_id ORDER BY list_price DESC ROWS UNBOUNDED
                PRECEDING ), 2 ) AS percentage_of_max_price FROM products ORDER
                BY category_id, list_price DESC;
              </div>
            </div>

            <h3>📊 Window Frame Specification</h3>
            <div class="example">
              <h4>Tính tổng lũy kế và trung bình động:</h4>
              <div class="code-block">
                -- Phân tích doanh thu với các frame khác nhau SELECT
                order_date, daily_revenue, -- Tổng lũy kế từ đầu đến hiện tại
                SUM(daily_revenue) OVER ( ORDER BY order_date ROWS UNBOUNDED
                PRECEDING ) AS cumulative_revenue, -- Trung bình động 7 ngày
                AVG(daily_revenue) OVER ( ORDER BY order_date ROWS BETWEEN 6
                PRECEDING AND CURRENT ROW ) AS moving_avg_7_days, -- Tổng 3 ngày
                (trước, hiện tại, sau) SUM(daily_revenue) OVER ( ORDER BY
                order_date ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING ) AS
                sum_3_days FROM ( SELECT CAST(order_date AS DATE) AS order_date,
                SUM(total_amount) AS daily_revenue FROM orders GROUP BY
                CAST(order_date AS DATE) ) daily_sales ORDER BY order_date;
              </div>
            </div>

            <h3>🎯 Ví dụ thực tế: Phân tích hiệu suất bán hàng</h3>
            <div class="example">
              <h4>Báo cáo toàn diện với Window Functions:</h4>
              <div class="code-block">
                -- Phân tích hiệu suất nhân viên bán hàng WITH sales_performance
                AS ( SELECT e.employee_id, e.employee_name, e.department_id,
                COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS
                total_sales, AVG(o.total_amount) AS avg_order_value FROM
                employees e LEFT JOIN orders o ON e.employee_id = o.sales_rep_id
                WHERE e.department_id = 1 -- Sales department GROUP BY
                e.employee_id, e.employee_name, e.department_id ) SELECT
                employee_id, employee_name, total_orders, total_sales,
                avg_order_value, -- Xếp hạng theo doanh thu RANK() OVER (ORDER
                BY total_sales DESC) AS sales_rank, DENSE_RANK() OVER (ORDER BY
                total_sales DESC) AS sales_dense_rank, -- Phân nhóm hiệu suất
                (top 25%, 50%, 75%, bottom 25%) NTILE(4) OVER (ORDER BY
                total_sales DESC) AS performance_quartile, -- So sánh với nhân
                viên tốt nhất và kém nhất FIRST_VALUE(total_sales) OVER (ORDER
                BY total_sales DESC) AS top_performer_sales,
                LAST_VALUE(total_sales) OVER ( ORDER BY total_sales DESC ROWS
                BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING ) AS
                bottom_performer_sales, -- Phần trăm so với top performer ROUND(
                total_sales * 100.0 / FIRST_VALUE(total_sales) OVER (ORDER BY
                total_sales DESC), 2 ) AS percentage_of_top_performer, -- So
                sánh với nhân viên trước và sau LAG(total_sales) OVER (ORDER BY
                total_sales DESC) AS higher_performer_sales, LEAD(total_sales)
                OVER (ORDER BY total_sales DESC) AS lower_performer_sales, --
                Phân loại hiệu suất CASE WHEN NTILE(4) OVER (ORDER BY
                total_sales DESC) = 1 THEN 'Xuất sắc' WHEN NTILE(4) OVER (ORDER
                BY total_sales DESC) = 2 THEN 'Tốt' WHEN NTILE(4) OVER (ORDER BY
                total_sales DESC) = 3 THEN 'Trung bình' ELSE 'Cần cải thiện' END
                AS performance_category FROM sales_performance ORDER BY
                total_sales DESC;
              </div>
            </div>

            <h3>💡 Best Practices cho Window Functions</h3>
            <div class="success-box">
              <h4>✅ Nên làm:</h4>
              <ul>
                <li>
                  <b>Sử dụng alias:</b> Đặt tên rõ ràng cho window functions
                </li>
                <li>
                  <b>PARTITION BY hiệu quả:</b> Chia nhỏ dataset để tăng hiệu
                  suất
                </li>
                <li><b>ORDER BY phù hợp:</b> Chọn cột sắp xếp có ý nghĩa</li>
                <li>
                  <b>Index:</b> Tạo index trên cột ORDER BY và PARTITION BY
                </li>
                <li>
                  <b>Frame specification:</b> Xác định rõ frame khi cần thiết
                </li>
              </ul>
            </div>

            <div class="info-box">
              <h4>❌ Tránh:</h4>
              <ul>
                <li>
                  <b>Quá nhiều window functions:</b> Có thể làm chậm query
                </li>
                <li><b>Frame không cần thiết:</b> Chỉ dùng khi thực sự cần</li>
                <li><b>PARTITION BY quá nhiều cột:</b> Có thể giảm hiệu quả</li>
                <li>
                  <b>Window functions trong WHERE:</b> Không được phép, dùng
                  subquery
                </li>
              </ul>
            </div>

            <div class="highlight-box">
              <h4>🎯 Kết luận:</h4>
              <p>
                Việc sử dụng các <b>hàm cửa sổ</b> giúp bạn thực hiện các phép
                phân tích phức tạp mà không cần dùng đến JOIN hoặc GROUP BY lồng
                nhau. Chúng đặc biệt hữu ích cho:
              </p>
              <ul>
                <li><b>Xếp hạng và so sánh</b></li>
                <li><b>Phân tích xu hướng</b> (LAG/LEAD)</li>
                <li><b>Tính toán lũy kế</b> (Running totals)</li>
                <li><b>Phân nhóm hiệu suất</b> (NTILE)</li>
                <li><b>So sánh với giá trị cực đại/cực tiểu</b></li>
              </ul>
            </div>
          </section>

          <!-- 20 -->
          <section class="section" id="cte">
            <h2>20. CTE</h2>

            <div class="info-box">
              <h4>🎯 CTE là gì?</h4>
              <p>
                <b>CTE (Common Table Expression)</b> là một tập hợp kết quả tạm
                thời, được đặt tên, được định nghĩa trong phạm vi của một câu
                lệnh SQL duy nhất. Bạn có thể coi CTE như một
                <b>biến bảng (table variable)</b> chỉ tồn tại trong suốt quá
                trình thực thi của câu lệnh truy vấn.
              </p>
              <p>
                CTE giúp bạn <b>tổ chức các truy vấn phức tạp</b> một cách gọn
                gàng và dễ đọc hơn, đặc biệt khi cần truy vấn lồng nhau hoặc sử
                dụng lại một phần của truy vấn nhiều lần.
              </p>
            </div>

            <h3>📝 Cú pháp của CTE</h3>
            <div class="highlight-box">
              <p>
                Một CTE được định nghĩa bằng mệnh đề <b>WITH</b>, theo sau là
                tên của CTE và câu lệnh SELECT của nó.
              </p>
            </div>

            <div class="example">
              <h4>Cú pháp chung:</h4>
              <div class="code-block">
                WITH cte_name AS ( SELECT column1, column2 FROM table_name WHERE
                condition ) SELECT * FROM cte_name WHERE another_condition;
              </div>

              <p><b>Các thành phần:</b></p>
              <ul>
                <li><b>WITH:</b> Mệnh đề bắt đầu của CTE</li>
                <li><b>cte_name:</b> Tên bạn đặt cho tập kết quả tạm thời</li>
                <li>
                  <b>AS ( ... ):</b> Khai báo truy vấn SELECT tạo ra tập kết quả
                  của CTE
                </li>
                <li>
                  <b>SELECT * FROM cte_name:</b> Sau khi CTE được định nghĩa,
                  bạn có thể sử dụng tên của nó như một bảng thông thường trong
                  câu lệnh chính
                </li>
              </ul>
            </div>

            <h3>🔄 So sánh: Trước và sau khi sử dụng CTE</h3>

            <div class="example">
              <h4>❌ Không sử dụng CTE (Subquery):</h4>
              <p>
                Giả sử bạn muốn tìm các sản phẩm có tổng số lượng bán được lớn
                hơn 10:
              </p>
              <div class="code-block">
                -- Cách cũ: Sử dụng subquery lồng nhau SELECT * FROM ( SELECT
                product_id, SUM(quantity) AS total_quantity FROM order_items
                GROUP BY product_id ) AS ProductSales WHERE total_quantity > 10;
              </div>
              <p>
                <b>Vấn đề:</b> Khó đọc, khó hiểu, khó bảo trì khi truy vấn phức
                tạp hơn.
              </p>
            </div>

            <div class="example">
              <h4>✅ Sử dụng CTE:</h4>
              <div class="code-block">
                -- Cách mới: Sử dụng CTE WITH ProductSales AS ( SELECT
                product_id, SUM(quantity) AS total_quantity FROM order_items
                GROUP BY product_id ) SELECT * FROM ProductSales WHERE
                total_quantity > 10;
              </div>

              <p><b>Giải thích từng bước:</b></p>
              <ol>
                <li>
                  <b>Bước 1 (WITH):</b>
                  <code>WITH ProductSales AS (...)</code> định nghĩa một CTE có
                  tên là <code>ProductSales</code>. CTE này chứa một truy vấn
                  tính tổng số lượng bán được của mỗi sản phẩm từ bảng
                  <code>order_items</code>.
                </li>
                <li>
                  <b>Bước 2 (SELECT):</b> Sau đó, bạn có thể dễ dàng truy vấn từ
                  CTE <code>ProductSales</code> như một bảng thông thường. Câu
                  lệnh chính
                  <code
                    >SELECT * FROM ProductSales WHERE total_quantity > 10;</code
                  >
                  sẽ trả về tất cả các cột từ CTE, nhưng chỉ những hàng có
                  <code>total_quantity</code> lớn hơn 10.
                </li>
              </ol>
            </div>

            <h3>🌟 Ưu điểm của CTE</h3>
            <div class="success-box">
              <h4>✅ Những lợi ích chính:</h4>
              <ul>
                <li>
                  <b>Dễ đọc và bảo trì:</b> CTE giúp chia nhỏ các truy vấn phức
                  tạp thành các khối nhỏ hơn, dễ hiểu hơn
                </li>
                <li>
                  <b>Có thể tái sử dụng:</b> Bạn có thể tham chiếu đến một CTE
                  nhiều lần trong cùng một câu lệnh SELECT, giúp tránh lặp lại
                  mã
                </li>
                <li>
                  <b>Có khả năng đệ quy:</b> CTE có thể tự tham chiếu đến chính
                  nó, cho phép bạn thực hiện các truy vấn đệ quy
                </li>
                <li>
                  <b>Giải quyết bài toán phức tạp:</b> CTE thường là giải pháp
                  tốt hơn và dễ hiểu hơn cho các bài toán mà subquery trở nên
                  quá phức tạp
                </li>
              </ul>
            </div>

            <h3>📚 Các loại CTE</h3>

            <h4>1️⃣ CTE đơn giản (Simple CTE)</h4>
            <div class="example">
              <p>
                Được sử dụng để làm cho truy vấn dễ đọc hơn và tách biệt logic.
              </p>
              <div class="code-block">
                -- Tìm khách hàng có đơn hàng trên 1 triệu WITH
                HighValueCustomers AS ( SELECT customer_id, customer_name,
                SUM(total_amount) AS total_spent FROM customers c INNER JOIN
                orders o ON c.customer_id = o.customer_id GROUP BY customer_id,
                customer_name HAVING SUM(total_amount) > 1000000 ) SELECT
                customer_name, total_spent, total_spent - 1000000 AS
                over_threshold FROM HighValueCustomers ORDER BY total_spent
                DESC;
              </div>
            </div>

            <h4>2️⃣ CTE với nhiều định nghĩa (Multiple CTEs)</h4>
            <div class="example">
              <p>
                Bạn có thể định nghĩa nhiều CTE trong một câu lệnh, phân cách
                bằng dấu phẩy.
              </p>
              <div class="code-block">
                -- Phân tích doanh thu theo tháng và so sánh với khách hàng VIP
                WITH MonthlySales AS ( SELECT YEAR(order_date) AS year,
                MONTH(order_date) AS month, SUM(total_amount) AS
                monthly_revenue, COUNT(order_id) AS total_orders FROM orders
                GROUP BY YEAR(order_date), MONTH(order_date) ), VipCustomers AS
                ( SELECT customer_id, customer_name, SUM(total_amount) AS
                lifetime_value FROM customers c INNER JOIN orders o ON
                c.customer_id = o.customer_id GROUP BY customer_id,
                customer_name HAVING SUM(total_amount) > 5000000 -- Khách hàng
                VIP > 5 triệu ), VipMonthlySales AS ( SELECT YEAR(o.order_date)
                AS year, MONTH(o.order_date) AS month, SUM(o.total_amount) AS
                vip_monthly_revenue FROM orders o INNER JOIN VipCustomers v ON
                o.customer_id = v.customer_id GROUP BY YEAR(o.order_date),
                MONTH(o.order_date) ) SELECT ms.year, ms.month,
                ms.monthly_revenue, ms.total_orders,
                COALESCE(vms.vip_monthly_revenue, 0) AS vip_revenue, ROUND(
                COALESCE(vms.vip_monthly_revenue, 0) * 100.0 /
                ms.monthly_revenue, 2 ) AS vip_percentage FROM MonthlySales ms
                LEFT JOIN VipMonthlySales vms ON ms.year = vms.year AND ms.month
                = vms.month ORDER BY ms.year DESC, ms.month DESC;
              </div>
            </div>

            <h4>3️⃣ CTE đệ quy (Recursive CTE)</h4>
            <div class="example">
              <p>
                CTE đệ quy cho phép bạn thực hiện các truy vấn trên cấu trúc dữ
                liệu phân cấp như cây tổ chức, danh mục sản phẩm...
              </p>
              <div class="code-block">
                -- Ví dụ: Tìm tất cả nhân viên dưới quyền của một manager WITH
                EmployeeHierarchy AS ( -- Anchor: Manager gốc SELECT
                <span class="keyword">WITH</span> EmployeeHierarchy
                <span class="keyword">AS</span> (
                <span class="comment"
                  >-- Anchor query: Tìm điểm bắt đầu (top managers)</span
                >
                <span class="keyword">SELECT</span>
                employee_id, employee_name, manager_id,
                <span class="number">1</span>
                <span class="keyword">AS</span> level,
                <span class="function">CAST</span>(employee_name
                <span class="keyword">AS</span>
                <span class="datatype">NVARCHAR</span>(<span class="number"
                  >1000</span
                >)) <span class="keyword">AS</span> hierarchy_path
                <span class="keyword">FROM</span> employees
                <span class="keyword">WHERE</span> manager_id
                <span class="keyword">IS NULL</span>
                <span class="comment">-- Top-level managers</span>

                <span class="keyword">UNION ALL</span>

                <span class="comment"
                  >-- Recursive part: Tìm nhân viên dưới quyền</span
                >
                <span class="keyword">SELECT</span>
                e.employee_id, e.employee_name, e.manager_id, eh.level +
                <span class="number">1</span>,
                <span class="function">CAST</span>(eh.hierarchy_path +
                <span class="string">' > '</span> + e.employee_name
                <span class="keyword">AS</span>
                <span class="datatype">NVARCHAR</span>(<span class="number"
                  >1000</span
                >)) <span class="keyword">FROM</span> employees e
                <span class="keyword">INNER JOIN</span> EmployeeHierarchy eh
                <span class="keyword">ON</span> e.manager_id = eh.employee_id
                <span class="keyword">WHERE</span> eh.level <
                <span class="number">10</span>
                <span class="comment"
                  >-- Giới hạn độ sâu để tránh vòng lặp vô hạn</span
                >
                )
                <span class="keyword">SELECT</span>
                employee_id, employee_name, level, hierarchy_path,
                <span class="function">REPLICATE</span>(<span class="string"
                  >' '</span
                >, level - <span class="number">1</span>) + employee_name
                <span class="keyword">AS</span> indented_name
                <span class="keyword">FROM</span> EmployeeHierarchy
                <span class="keyword">ORDER BY</span> hierarchy_path;
              </div>

              <p><b>Giải thích CTE đệ quy:</b></p>
              <ul>
                <li>
                  <b>Anchor query:</b> Phần đầu tìm điểm bắt đầu (managers không
                  có manager)
                </li>
                <li>
                  <b>UNION ALL:</b> Kết hợp kết quả từ anchor và recursive part
                </li>
                <li>
                  <b>Recursive part:</b> Tự tham chiếu đến CTE để tìm các level
                  tiếp theo
                </li>
                <li>
                  <b>Termination condition:</b> Điều kiện dừng để tránh vòng lặp
                  vô hạn
                </li>
              </ul>
            </div>

            <h3>💡 Ví dụ thực tế: Phân tích doanh số bán hàng</h3>
            <div class="example">
              <h4>Báo cáo tổng hợp sử dụng nhiều CTE:</h4>
              <div class="code-block">
                <span class="comment"
                  >-- Phân tích hiệu suất bán hàng tổng thể</span
                >
                <span class="keyword">WITH</span> CategorySales
                <span class="keyword">AS</span> (
                <span class="comment">-- Doanh thu theo danh mục</span>
                <span class="keyword">SELECT</span>
                c.category_id, c.category_name,
                <span class="function">SUM</span>(oi.quantity * oi.list_price)
                <span class="keyword">AS</span> category_revenue,
                <span class="function">COUNT</span>(<span class="keyword"
                  >DISTINCT</span
                >
                o.order_id) <span class="keyword">AS</span> total_orders,
                <span class="function">AVG</span>(oi.quantity * oi.list_price)
                <span class="keyword">AS</span> avg_order_value
                <span class="keyword">FROM</span> categories c
                <span class="keyword">INNER JOIN</span> products p
                <span class="keyword">ON</span> c.category_id = p.category_id
                <span class="keyword">INNER JOIN</span> order_items oi
                <span class="keyword">ON</span> p.product_id = oi.product_id
                <span class="keyword">INNER JOIN</span> orders o
                <span class="keyword">ON</span> oi.order_id = o.order_id
                <span class="keyword">WHERE</span> o.order_date >=
                <span class="function">DATEADD</span>(<span class="keyword"
                  >MONTH</span
                >, -<span class="number">12</span>,
                <span class="function">GETDATE</span>())
                <span class="comment">-- 12 tháng gần nhất</span>
                <span class="keyword">GROUP BY</span> c.category_id,
                c.category_name ), TopProducts <span class="keyword">AS</span> (
                <span class="comment"
                  >-- Top 3 sản phẩm bán chạy trong mỗi danh mục</span
                >
                <span class="keyword">SELECT</span>
                category_id, product_id, product_name, total_sold,
                <span class="function">ROW_NUMBER</span>()
                <span class="keyword">OVER</span> (<span class="keyword"
                  >PARTITION BY</span
                >
                category_id <span class="keyword">ORDER BY</span> total_sold
                <span class="keyword">DESC</span>)
                <span class="keyword">AS</span> rank_in_category
                <span class="keyword">FROM</span> (
                <span class="keyword">SELECT</span>
                p.category_id, p.product_id, p.product_name,
                <span class="function">SUM</span>(oi.quantity)
                <span class="keyword">AS</span> total_sold
                <span class="keyword">FROM</span> products p
                <span class="keyword">INNER JOIN</span> order_items oi
                <span class="keyword">ON</span> p.product_id = oi.product_id
                <span class="keyword">INNER JOIN</span> orders o
                <span class="keyword">ON</span> oi.order_id = o.order_id
                <span class="keyword">WHERE</span> o.order_date >=
                <span class="function">DATEADD</span>(<span class="keyword"
                  >MONTH</span
                >, -<span class="number">12</span>,
                <span class="function">GETDATE</span>())
                <span class="keyword">GROUP BY</span> p.category_id,
                p.product_id, p.product_name ) ProductSales ), QuarterlySales
                <span class="keyword">AS</span> (
                <span class="comment">-- Doanh thu theo quý</span>
                <span class="keyword">SELECT</span>
                <span class="function">YEAR</span>(o.order_date)
                <span class="keyword">AS</span> year,
                <span class="function">CEILING</span>(<span class="function"
                  >MONTH</span
                >(o.order_date) / <span class="number">3.0</span>)
                <span class="keyword">AS</span> quarter,
                <span class="function">SUM</span>(oi.quantity * oi.list_price)
                <span class="keyword">AS</span> quarterly_revenue
                <span class="keyword">FROM</span> orders o
                <span class="keyword">INNER JOIN</span> order_items oi
                <span class="keyword">ON</span> o.order_id = oi.order_id
                <span class="keyword">WHERE</span> o.order_date >=
                <span class="function">DATEADD</span>(<span class="keyword"
                  >MONTH</span
                >, -<span class="number">12</span>,
                <span class="function">GETDATE</span>())
                <span class="keyword">GROUP BY</span>
                <span class="function">YEAR</span>(o.order_date),
                <span class="function">CEILING</span>(<span class="function"
                  >MONTH</span
                >(o.order_date) / <span class="number">3.0</span>) )
                <span class="comment"
                  >-- Truy vấn chính kết hợp tất cả CTE</span
                >
                <span class="keyword">SELECT</span>
                cs.category_name, cs.category_revenue, cs.total_orders,
                cs.avg_order_value,
                <span class="comment"
                  >-- Top selling product trong danh mục</span
                >
                tp.product_name <span class="keyword">AS</span> top_product,
                tp.total_sold
                <span class="keyword">AS</span> top_product_quantity,
                <span class="comment"
                  >-- Percentage của danh mục so với tổng doanh thu</span
                >
                <span class="function">ROUND</span>( cs.category_revenue *
                <span class="number">100.0</span> /
                <span class="function">SUM</span>(cs.category_revenue)
                <span class="keyword">OVER</span>(),
                <span class="number">2</span> )
                <span class="keyword">AS</span> category_percentage,
                <span class="comment">-- Rank danh mục theo doanh thu</span>
                <span class="function">RANK</span>()
                <span class="keyword">OVER</span> (<span class="keyword"
                  >ORDER BY</span
                >
                cs.category_revenue <span class="keyword">DESC</span>)
                <span class="keyword">AS</span> category_rank
                <span class="keyword">FROM</span> CategorySales cs
                <span class="keyword">LEFT JOIN</span> TopProducts tp
                <span class="keyword">ON</span> cs.category_id = tp.category_id
                <span class="keyword">AND</span> tp.rank_in_category =
                <span class="number">1</span>
                <span class="keyword">ORDER BY</span> cs.category_revenue
                <span class="keyword">DESC</span>;
              </div>
            </div>

            <h3>⚡ Hiệu suất và Best Practices</h3>

            <div class="success-box">
              <h4>✅ Nên làm:</h4>
              <ul>
                <li>
                  <b>Đặt tên CTE có ý nghĩa:</b> Sử dụng tên mô tả rõ ràng mục
                  đích của CTE
                </li>
                <li>
                  <b>Sử dụng CTE cho logic phức tạp:</b> Thay thế subquery lồng
                  nhau bằng CTE
                </li>
                <li>
                  <b>Chia nhỏ truy vấn:</b> Chia một truy vấn lớn thành nhiều
                  CTE nhỏ hơn
                </li>
                <li>
                  <b>Comment rõ ràng:</b> Thêm comment giải thích logic của mỗi
                  CTE
                </li>
                <li>
                  <b>Tối ưu index:</b> Đảm bảo các cột trong WHERE, JOIN có
                  index phù hợp
                </li>
              </ul>
            </div>

            <div class="info-box">
              <h4>❌ Tránh:</h4>
              <ul>
                <li>
                  <b>CTE quá phức tạp:</b> Không nên đặt quá nhiều logic vào một
                  CTE
                </li>
                <li>
                  <b>Recursive CTE không có điều kiện dừng:</b> Có thể gây vòng
                  lặp vô hạn
                </li>
                <li>
                  <b>Sử dụng CTE khi không cần:</b> Với truy vấn đơn giản,
                  subquery có thể đủ
                </li>
                <li><b>Quên index:</b> CTE vẫn cần index để chạy nhanh</li>
              </ul>
            </div>

            <h3>🔄 CTE vs Subquery vs Temporary Table</h3>
            <table>
              <thead>
                <tr>
                  <th>Đặc điểm</th>
                  <th>CTE</th>
                  <th>Subquery</th>
                  <th>Temporary Table</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>Khả năng đọc</b></td>
                  <td>Rất tốt</td>
                  <td>Khó với truy vấn phức tạp</td>
                  <td>Tốt</td>
                </tr>
                <tr>
                  <td><b>Tái sử dụng</b></td>
                  <td>Trong cùng một query</td>
                  <td>Không</td>
                  <td>Trong cùng session</td>
                </tr>
                <tr>
                  <td><b>Đệ quy</b></td>
                  <td>Có</td>
                  <td>Không</td>
                  <td>Không</td>
                </tr>
                <tr>
                  <td><b>Hiệu suất</b></td>
                  <td>Tương đương subquery</td>
                  <td>Tốt</td>
                  <td>Tốt cho dataset lớn</td>
                </tr>
                <tr>
                  <td><b>Khi nào dùng</b></td>
                  <td>Logic phức tạp, đệ quy</td>
                  <td>Truy vấn đơn giản</td>
                  <td>Dữ liệu lớn, nhiều thao tác</td>
                </tr>
              </tbody>
            </table>

            <div class="highlight-box">
              <h4>🎯 Kết luận:</h4>
              <p>
                <b>CTE</b> là một công cụ mạnh mẽ giúp bạn viết SQL
                <b>dễ đọc, dễ hiểu và dễ bảo trì</b>. Đặc biệt hữu ích cho:
              </p>
              <ul>
                <li>
                  <b>Chia nhỏ truy vấn phức tạp</b> thành các bước logic rõ ràng
                </li>
                <li><b>Thay thế subquery lồng nhau</b> khó đọc</li>
                <li><b>Xử lý dữ liệu phân cấp</b> với CTE đệ quy</li>
                <li><b>Tái sử dụng logic</b> trong cùng một truy vấn</li>
                <li><b>Làm việc nhóm</b> - code dễ hiểu cho đồng nghiệp</li>
              </ul>
            </div>
          </section>

          <!-- 21 -->
          <section class="section" id="conditions">
            <h2>21. Câu lệnh điều khiển</h2>

            <div class="info-box">
              <h4>🎛️ Các câu lệnh điều khiển (Control Flow Statements)</h4>
              <p>
                Các câu lệnh điều khiển trong SQL, thường được sử dụng trong các
                <b>thủ tục lưu trữ (Stored Procedures)</b>,
                <b>hàm (Functions)</b>, và <b>khối mã (Blocks)</b>, cho phép bạn
                điều hướng logic thực thi của chương trình.
              </p>
              <p>
                Chúng giúp tạo ra các
                <b>logic phức tạp, xử lý điều kiện, lặp và xử lý lỗi</b> trong
                SQL.
              </p>
            </div>

            <h3>🔀 1. Câu lệnh điều kiện (IF...ELSE, CASE)</h3>

            <h4>⚡ IF...ELSE</h4>
            <div class="highlight-box">
              <p>
                Cho phép bạn thực hiện các khối mã khác nhau dựa trên một điều
                kiện.
              </p>
            </div>

            <div class="example">
              <h4>Cú pháp cơ bản:</h4>
              <div class="code-block">
                -- Cú pháp IF...ELSE đơn giản IF condition statement(s) ELSE
                statement(s); -- Cú pháp IF...ELSE với khối lệnh IF condition
                BEGIN statement1; statement2; END ELSE BEGIN statement3;
                statement4; END;
              </div>
            </div>

            <div class="example">
              <h4>Ví dụ thực tế:</h4>
              <div class="code-block">
                -- Phân loại sản phẩm theo giá DECLARE @price DECIMAL(10, 2) =
                1500; IF @price > 1000 PRINT 'Sản phẩm đắt tiền'; ELSE PRINT
                'Sản phẩm bình dân'; -- Ví dụ phức tạp hơn với nhiều điều kiện
                DECLARE @quantity INT = 50; DECLARE @status VARCHAR(20); IF
                @quantity > 100 BEGIN SET @status = 'Dư thừa'; PRINT 'Kho hàng
                dư thừa, cần khuyến mãi'; END ELSE IF @quantity > 50 BEGIN SET
                @status = 'Đủ dùng'; PRINT 'Mức tồn kho ổn định'; END ELSE IF
                @quantity > 10 BEGIN SET @status = 'Sắp hết'; PRINT 'Cần nhập
                thêm hàng'; END ELSE BEGIN SET @status = 'Hết hàng'; PRINT 'Khẩn
                cấp: Nhập hàng ngay!'; END; SELECT @status AS inventory_status;
              </div>
            </div>

            <h4>🔄 CASE</h4>
            <div class="highlight-box">
              <p>
                Một biểu thức phức tạp hơn IF...ELSE, cho phép bạn so sánh một
                giá trị với nhiều điều kiện khác nhau và trả về kết quả tương
                ứng.
              </p>
            </div>

            <div class="example">
              <h4>CASE trong SELECT:</h4>
              <div class="code-block">
                <span class="comment">-- Phân loại sản phẩm theo giá</span>
                <span class="keyword">SELECT</span> <span class="column">product_id</span>, <span class="column">product_name</span>, <span class="column">list_price</span>,
                  <span class="keyword">CASE</span> 
                    <span class="keyword">WHEN</span> <span class="column">list_price</span> <span class="operator">></span> <span class="number">1000</span> <span class="keyword">THEN</span> <span class="string">'High-end'</span>
                    <span class="keyword">WHEN</span> <span class="column">list_price</span> <span class="keyword">BETWEEN</span> <span class="number">500</span> <span class="keyword">AND</span> <span class="number">1000</span> <span class="keyword">THEN</span> <span class="string">'Mid-range'</span>
                    <span class="keyword">WHEN</span> <span class="column">list_price</span> <span class="keyword">BETWEEN</span> <span class="number">100</span> <span class="keyword">AND</span> <span class="number">499</span> <span class="keyword">THEN</span> <span class="string">'Budget'</span>
                    <span class="keyword">ELSE</span> <span class="string">'Economy'</span>
                  <span class="keyword">END</span> <span class="keyword">AS</span> <span class="column">product_category</span>,
                  <span class="comment">-- CASE với phép tính</span>
                  <span class="keyword">CASE</span> 
                    <span class="keyword">WHEN</span> <span class="column">list_price</span> <span class="operator">></span> <span class="number">1000</span> <span class="keyword">THEN</span> <span class="column">list_price</span> <span class="operator">*</span> <span class="number">0.05</span> <span class="comment">-- 5% discount</span>
                    <span class="keyword">WHEN</span> <span class="column">list_price</span> <span class="operator">></span> <span class="number">500</span> <span class="keyword">THEN</span> <span class="column">list_price</span> <span class="operator">*</span> <span class="number">0.03</span> <span class="comment">-- 3% discount</span>
                    <span class="keyword">ELSE</span> <span class="column">list_price</span> <span class="operator">*</span> <span class="number">0.01</span> <span class="comment">-- 1% discount</span>
                  <span class="keyword">END</span> <span class="keyword">AS</span> <span class="column">discount_amount</span>
                <span class="keyword">FROM</span> <span class="table">products</span>;
              </div>
            </div>

            <div class="example">
              <h4>CASE trong Stored Procedure:</h4>
              <div class="code-block">
                <span class="comment">-- Procedure tính phí ship dựa trên trọng lượng và khoảng cách</span>
                <span class="keyword">CREATE PROCEDURE</span> <span class="function">CalculateShippingFee</span> 
                  <span class="column">@weight</span> <span class="datatype">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),
                  <span class="column">@distance</span> <span class="datatype">INT</span>,
                  <span class="column">@shipping_fee</span> <span class="datatype">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">OUTPUT</span>
                <span class="keyword">AS</span>
                <span class="keyword">BEGIN</span>
                  <span class="keyword">SET</span> <span class="column">@shipping_fee</span> <span class="operator">=</span> 
                    <span class="keyword">CASE</span> 
                      <span class="keyword">WHEN</span> <span class="column">@weight</span> <span class="operator"><=</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="column">@distance</span> <span class="operator"><=</span> <span class="number">50</span> <span class="keyword">THEN</span> <span class="number">20000</span>
                      <span class="keyword">WHEN</span> <span class="column">@weight</span> <span class="operator"><=</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="column">@distance</span> <span class="operator"><=</span> <span class="number">100</span> <span class="keyword">THEN</span> <span class="number">35000</span>
                      <span class="keyword">WHEN</span> <span class="column">@weight</span> <span class="operator"><=</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="column">@distance</span> <span class="operator"><=</span> <span class="number">50</span> <span class="keyword">THEN</span> <span class="number">40000</span>
                      <span class="keyword">WHEN</span> <span class="column">@weight</span> <span class="operator"><=</span> <span class="number">5</span> <span class="keyword">AND</span> <span class="column">@distance</span> <span class="operator"><=</span> <span class="number">100</span> <span class="keyword">THEN</span> <span class="number">60000</span>
                      <span class="keyword">WHEN</span> <span class="column">@weight</span> <span class="operator"><=</span> <span class="number">10</span> <span class="keyword">THEN</span> <span class="number">80000</span> <span class="operator">+</span> (<span class="column">@distance</span> <span class="operator">*</span> <span class="number">500</span>)
                      <span class="keyword">ELSE</span> <span class="number">120000</span> <span class="operator">+</span> (<span class="column">@weight</span> <span class="operator">*</span> <span class="number">5000</span>) <span class="operator">+</span> (<span class="column">@distance</span> <span class="operator">*</span> <span class="number">800</span>)
                    <span class="keyword">END</span>;
                    
                  <span class="comment">-- Log tính phí</span>
                  <span class="keyword">PRINT</span> <span class="string">'Trọng lượng: '</span> <span class="operator">+</span> <span class="function">CAST</span>(<span class="column">@weight</span> <span class="keyword">AS</span> <span class="datatype">VARCHAR</span>) <span class="operator">+</span> <span class="string">'kg'</span>;
                  <span class="keyword">PRINT</span> <span class="string">'Khoảng cách: '</span> <span class="operator">+</span> <span class="function">CAST</span>(<span class="column">@distance</span> <span class="keyword">AS</span> <span class="datatype">VARCHAR</span>) <span class="operator">+</span> <span class="string">'km'</span>;
                  <span class="keyword">PRINT</span> <span class="string">'Phí ship: '</span> <span class="operator">+</span> <span class="function">FORMAT</span>(<span class="column">@shipping_fee</span>, <span class="string">'N0'</span>) <span class="operator">+</span> <span class="string">' VND'</span>;
                <span class="keyword">END</span>;
              </div>
            </div>

            <h3>🔄 2. Vòng lặp (LOOP, WHILE/REPEAT)</h3>

            <h4>⏰ WHILE</h4>
            <div class="highlight-box">
              <p>Lặp lại một khối mã miễn là một điều kiện còn đúng.</p>
            </div>

            <div class="example">
              <h4>WHILE cơ bản:</h4>
              <div class="code-block">
                <span class="comment">-- Đếm từ 1 đến 5</span>
                <span class="keyword">DECLARE</span> <span class="column">@counter</span> <span class="datatype">INT</span> <span class="operator">=</span> <span class="number">1</span>;
                <span class="keyword">WHILE</span> <span class="column">@counter</span> <span class="operator"><=</span> <span class="number">5</span>
                <span class="keyword">BEGIN</span>
                  <span class="keyword">PRINT</span> <span class="string">'Số đếm: '</span> <span class="operator">+</span> <span class="function">CAST</span>(<span class="column">@counter</span> <span class="keyword">AS</span> <span class="datatype">VARCHAR</span>);
                  <span class="keyword">SET</span> <span class="column">@counter</span> <span class="operator">=</span> <span class="column">@counter</span> <span class="operator">+</span> <span class="number">1</span>;
                <span class="keyword">END</span>;
                <span class="keyword">PRINT</span> <span class="string">'Hoàn thành đếm!'</span>;
              </div>
            </div>

            <div class="example">
              <h4>WHILE với logic phức tạp:</h4>
              <div class="code-block">
                -- Tự động tạo mã sản phẩm DECLARE @product_count INT = 0;
                DECLARE @max_products INT = 10; DECLARE @product_code
                VARCHAR(20); WHILE @product_count < @max_products BEGIN SET
                @product_count = @product_count + 1; -- Tạo mã sản phẩm SET
                @product_code = 'PRD' + RIGHT('000' + CAST(@product_count AS
                VARCHAR), 3); -- Kiểm tra mã đã tồn tại chưa IF NOT EXISTS
                (SELECT 1 FROM products WHERE product_code = @product_code)
                BEGIN INSERT INTO products (product_code, product_name,
                created_date) VALUES (@product_code, 'Sản phẩm ' +
                @product_code, GETDATE()); PRINT 'Đã tạo sản phẩm: ' +
                @product_code; END ELSE BEGIN PRINT 'Mã ' + @product_code + ' đã
                tồn tại, bỏ qua...'; END; -- Nghỉ 1 giây (nếu cần) WAITFOR DELAY
                '00:00:01'; END; PRINT 'Hoàn thành tạo ' + CAST(@product_count
                AS VARCHAR) + ' sản phẩm!';
              </div>
            </div>

            <div class="example">
              <h4>WHILE với BREAK và CONTINUE:</h4>
              <div class="code-block">
                -- Xử lý batch dữ liệu DECLARE @batch_size INT = 100; DECLARE
                @processed_count INT = 0; DECLARE @total_records INT; DECLARE
                @error_count INT = 0; -- Đếm tổng số records cần xử lý SELECT
                @total_records = COUNT(*) FROM pending_orders; WHILE
                @processed_count < @total_records BEGIN BEGIN TRY -- Xử lý batch
                UPDATE TOP(@batch_size) pending_orders SET status = 'processed',
                processed_date = GETDATE() WHERE status = 'pending'; SET
                @processed_count = @processed_count + @@ROWCOUNT; PRINT 'Đã xử
                lý: ' + CAST(@processed_count AS VARCHAR) + '/' +
                CAST(@total_records AS VARCHAR); -- Nếu không còn record nào
                được update, thoát vòng lặp IF @@ROWCOUNT = 0 BREAK; END TRY
                BEGIN CATCH SET @error_count = @error_count + 1; PRINT 'Lỗi xử
                lý batch: ' + ERROR_MESSAGE(); -- Nếu quá nhiều lỗi, dừng lại IF
                @error_count > 5 BEGIN PRINT 'Quá nhiều lỗi, dừng xử lý!';
                BREAK; END; -- Tiếp tục với batch tiếp theo CONTINUE; END CATCH;
                -- Nghỉ giữa các batch WAITFOR DELAY '00:00:02'; END;
              </div>
            </div>

            <h3>⚠️ 3. Xử lý lỗi (TRY...CATCH, DECLARE HANDLER)</h3>

            <h4>🛡️ TRY...CATCH</h4>
            <div class="highlight-box">
              <p>
                Cho phép bạn xử lý lỗi một cách có kiểm soát. Khối TRY chứa mã
                có thể gây lỗi, và khối CATCH sẽ được thực thi nếu có lỗi xảy
                ra.
              </p>
            </div>

            <div class="example">
              <h4>TRY...CATCH cơ bản:</h4>
              <div class="code-block">
                -- Xử lý lỗi chia cho 0 BEGIN TRY -- Câu lệnh có thể gây lỗi
                DECLARE @result INT = 10 / 0; PRINT 'Kết quả: ' + CAST(@result
                AS VARCHAR); END TRY BEGIN CATCH PRINT 'Đã xảy ra lỗi: ' +
                ERROR_MESSAGE(); PRINT 'Mã lỗi: ' + CAST(ERROR_NUMBER() AS
                VARCHAR); PRINT 'Độ nghiêm trọng: ' + CAST(ERROR_SEVERITY() AS
                VARCHAR); PRINT 'Trạng thái: ' + CAST(ERROR_STATE() AS VARCHAR);
                PRINT 'Tại dòng: ' + CAST(ERROR_LINE() AS VARCHAR); END CATCH;
              </div>
            </div>

            <div class="example">
              <h4>TRY...CATCH trong Transaction:</h4>
              <div class="code-block">
                -- Stored Procedure chuyển tiền an toàn CREATE PROCEDURE
                TransferMoney @from_account_id INT, @to_account_id INT, @amount
                DECIMAL(15,2) AS BEGIN DECLARE @error_message VARCHAR(500);
                DECLARE @from_balance DECIMAL(15,2); BEGIN TRANSACTION; BEGIN
                TRY -- Kiểm tra tài khoản nguồn SELECT @from_balance = balance
                FROM accounts WHERE account_id = @from_account_id; IF
                @from_balance IS NULL BEGIN RAISERROR('Tài khoản nguồn không tồn
                tại', 16, 1); RETURN; END; IF @from_balance < @amount BEGIN
                RAISERROR('Số dư không đủ. Số dư hiện tại: %s', 16, 1,
                FORMAT(@from_balance, 'N2')); RETURN; END; -- Kiểm tra tài khoản
                đích IF NOT EXISTS (SELECT 1 FROM accounts WHERE account_id =
                @to_account_id) BEGIN RAISERROR('Tài khoản đích không tồn tại',
                16, 1); RETURN; END; -- Thực hiện chuyển tiền UPDATE accounts
                SET balance = balance - @amount WHERE account_id =
                @from_account_id; UPDATE accounts SET balance = balance +
                @amount WHERE account_id = @to_account_id; -- Ghi log giao dịch
                INSERT INTO transaction_log (from_account, to_account, amount,
                transaction_date, status) VALUES (@from_account_id,
                @to_account_id, @amount, GETDATE(), 'completed'); COMMIT
                TRANSACTION; PRINT 'Chuyển tiền thành công: ' + FORMAT(@amount,
                'N2'); END TRY BEGIN CATCH ROLLBACK TRANSACTION; SET
                @error_message = ERROR_MESSAGE(); PRINT 'Lỗi chuyển tiền: ' +
                @error_message; -- Ghi log lỗi INSERT INTO error_log
                (error_message, error_time, procedure_name) VALUES
                (@error_message, GETDATE(), 'TransferMoney'); -- Ném lại lỗi nếu
                cần THROW; END CATCH; END;
              </div>
            </div>

            <h4>🎯 Các hàm ERROR trong CATCH:</h4>
            <table>
              <thead>
                <tr>
                  <th>Hàm</th>
                  <th>Mô tả</th>
                  <th>Ví dụ</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>ERROR_MESSAGE()</b></td>
                  <td>Thông báo lỗi chi tiết</td>
                  <td>"Division by zero error encountered"</td>
                </tr>
                <tr>
                  <td><b>ERROR_NUMBER()</b></td>
                  <td>Mã số lỗi</td>
                  <td>8134</td>
                </tr>
                <tr>
                  <td><b>ERROR_SEVERITY()</b></td>
                  <td>Mức độ nghiêm trọng (1-25)</td>
                  <td>16</td>
                </tr>
                <tr>
                  <td><b>ERROR_STATE()</b></td>
                  <td>Trạng thái lỗi</td>
                  <td>1</td>
                </tr>
                <tr>
                  <td><b>ERROR_LINE()</b></td>
                  <td>Số dòng xảy ra lỗi</td>
                  <td>15</td>
                </tr>
                <tr>
                  <td><b>ERROR_PROCEDURE()</b></td>
                  <td>Tên procedure/function lỗi</td>
                  <td>"TransferMoney"</td>
                </tr>
              </tbody>
            </table>

            <h3>🎯 4. Điều hướng khác (GOTO, RETURN, LEAVE, ITERATE)</h3>

            <h4>↩️ RETURN</h4>
            <div class="highlight-box">
              <p>
                Thoát khỏi một thủ tục lưu trữ hoặc hàm và trả về một giá trị.
              </p>
            </div>

            <div class="example">
              <h4>RETURN trong Stored Procedure:</h4>
              <div class="code-block">
                -- Procedure kiểm tra và tạo đơn hàng CREATE PROCEDURE
                CreateOrder @customer_id INT, @product_id INT, @quantity INT AS
                BEGIN DECLARE @stock_quantity INT; DECLARE @order_id INT; --
                Kiểm tra khách hàng IF NOT EXISTS (SELECT 1 FROM customers WHERE
                customer_id = @customer_id) BEGIN PRINT 'Lỗi: Khách hàng không
                tồn tại'; RETURN -1; -- Mã lỗi -1 END; -- Kiểm tra sản phẩm và
                tồn kho SELECT @stock_quantity = stock_quantity FROM products
                WHERE product_id = @product_id; IF @stock_quantity IS NULL BEGIN
                PRINT 'Lỗi: Sản phẩm không tồn tại'; RETURN -2; -- Mã lỗi -2
                END; IF @stock_quantity < @quantity BEGIN PRINT 'Lỗi: Không đủ
                tồn kho. Còn lại: ' + CAST(@stock_quantity AS VARCHAR); RETURN
                -3; -- Mã lỗi -3 END; -- Tạo đơn hàng INSERT INTO orders
                (customer_id, order_date, status) VALUES (@customer_id,
                GETDATE(), 'pending'); SET @order_id = SCOPE_IDENTITY(); INSERT
                INTO order_items (order_id, product_id, quantity, unit_price)
                SELECT @order_id, @product_id, @quantity, list_price FROM
                products WHERE product_id = @product_id; -- Cập nhật tồn kho
                UPDATE products SET stock_quantity = stock_quantity - @quantity
                WHERE product_id = @product_id; PRINT 'Tạo đơn hàng thành công.
                Order ID: ' + CAST(@order_id AS VARCHAR); RETURN @order_id; --
                Trả về Order ID END; -- Sử dụng procedure DECLARE @result INT;
                EXEC @result = CreateOrder @customer_id = 1, @product_id = 5,
                @quantity = 2; IF @result > 0 PRINT 'Order được tạo với ID: ' +
                CAST(@result AS VARCHAR); ELSE PRINT 'Tạo order thất bại với mã
                lỗi: ' + CAST(@result AS VARCHAR);
              </div>
            </div>

            <h4>➡️ GOTO (Không khuyến khích)</h4>
            <div class="info-box">
              <p>
                <b>Lưu ý:</b> GOTO không được khuyến khích vì có thể làm cho mã
                trở nên khó đọc và bảo trì. Tuy nhiên, đôi khi nó có thể hữu ích
                trong một số trường hợp đặc biệt.
              </p>
            </div>

            <div class="example">
              <h4>GOTO - Ví dụ (chỉ để tham khảo):</h4>
              <div class="code-block">
                -- Ví dụ sử dụng GOTO (không khuyến khích) DECLARE @counter INT
                = 1; DECLARE @max_attempts INT = 3; DECLARE @success BIT = 0;
                retry_label: BEGIN TRY -- Thao tác có thể thất bại INSERT INTO
                critical_table (data) VALUES ('important_data'); SET @success =
                1; GOTO success_label; END TRY BEGIN CATCH SET @counter =
                @counter + 1; IF @counter <= @max_attempts BEGIN PRINT 'Thử lại
                lần ' + CAST(@counter AS VARCHAR); WAITFOR DELAY '00:00:01'; --
                Đợi 1 giây GOTO retry_label; END ELSE BEGIN PRINT 'Thất bại sau
                ' + CAST(@max_attempts AS VARCHAR) + ' lần thử'; GOTO
                error_label; END; END CATCH; success_label: PRINT 'Thành công!';
                GOTO end_label; error_label: PRINT 'Xử lý lỗi cuối cùng';
                end_label: PRINT 'Kết thúc procedure';
              </div>
            </div>

            <h4>🔄 BREAK và CONTINUE</h4>
            <div class="example">
              <h4>Sử dụng BREAK và CONTINUE trong WHILE:</h4>
              <div class="code-block">
                -- Xử lý danh sách file, bỏ qua file lỗi DECLARE @file_id INT =
                1; DECLARE @max_files INT = 100; DECLARE @error_count INT = 0;
                DECLARE @max_errors INT = 10; WHILE @file_id <= @max_files BEGIN
                BEGIN TRY -- Giả lập xử lý file IF @file_id % 7 = 0 -- Giả lập
                file lỗi RAISERROR('File corrupted', 16, 1); PRINT 'Xử lý file '
                + CAST(@file_id AS VARCHAR) + ' thành công'; END TRY BEGIN CATCH
                SET @error_count = @error_count + 1; PRINT 'Lỗi xử lý file ' +
                CAST(@file_id AS VARCHAR) + ': ' + ERROR_MESSAGE(); -- Nếu quá
                nhiều lỗi, dừng lại IF @error_count >= @max_errors BEGIN PRINT
                'Quá nhiều lỗi (' + CAST(@error_count AS VARCHAR) + '), dừng xử
                lý!'; BREAK; -- Thoát khỏi vòng lặp END; -- Bỏ qua file lỗi,
                tiếp tục với file tiếp theo SET @file_id = @file_id + 1;
                CONTINUE; -- Bỏ qua phần còn lại, lặp tiếp END CATCH; SET
                @file_id = @file_id + 1; END; PRINT 'Hoàn thành xử lý. Tổng lỗi:
                ' + CAST(@error_count AS VARCHAR);
              </div>
            </div>

            <h3>💡 Best Practices cho Control Flow</h3>

            <div class="success-box">
              <h4>✅ Nên làm:</h4>
              <ul>
                <li>
                  <b>Sử dụng TRY...CATCH:</b> Luôn xử lý lỗi có thể xảy ra
                </li>
                <li>
                  <b>Kiểm tra điều kiện trước:</b> Validate input trước khi xử
                  lý
                </li>
                <li><b>Log lỗi chi tiết:</b> Ghi lại thông tin lỗi để debug</li>
                <li><b>Sử dụng RETURN codes:</b> Trả về mã lỗi có ý nghĩa</li>
                <li><b>Tối ưu vòng lặp:</b> Tránh vòng lặp vô hạn</li>
                <li><b>Transaction safety:</b> Sử dụng ROLLBACK khi có lỗi</li>
              </ul>
            </div>

            <div class="info-box">
              <h4>❌ Tránh:</h4>
              <ul>
                <li>
                  <b>GOTO không cần thiết:</b> Làm code khó đọc và maintain
                </li>
                <li>
                  <b>Vòng lặp không có điều kiện dừng:</b> Có thể gây infinite
                  loop
                </li>
                <li><b>Không xử lý lỗi:</b> Có thể làm crash ứng dụng</li>
                <li><b>Nested quá sâu:</b> Khó đọc và debug</li>
                <li><b>Hardcode values:</b> Nên dùng variables/parameters</li>
              </ul>
            </div>

            <h3>🎯 Ví dụ tổng hợp: Procedure xử lý đơn hàng</h3>
            <div class="example">
              <h4>Procedure hoàn chỉnh với tất cả control flow:</h4>
              <div class="code-block">
                -- Procedure xử lý batch đơn hàng với đầy đủ control flow CREATE
                PROCEDURE ProcessOrderBatch @batch_size INT = 50, @max_errors
                INT = 5 AS BEGIN DECLARE @processed_count INT = 0; DECLARE
                @error_count INT = 0; DECLARE @order_id INT; DECLARE
                @customer_id INT; DECLARE @total_amount DECIMAL(15,2); DECLARE
                @payment_status VARCHAR(20); -- Cursor để xử lý từng đơn hàng
                DECLARE order_cursor CURSOR FOR SELECT TOP (@batch_size)
                order_id, customer_id, total_amount, payment_status FROM orders
                WHERE status = 'pending' ORDER BY order_date; OPEN order_cursor;
                WHILE 1 = 1 -- Vòng lặp vô hạn, sẽ dùng BREAK để thoát BEGIN
                FETCH NEXT FROM order_cursor INTO @order_id, @customer_id,
                @total_amount, @payment_status; -- Nếu không còn record, thoát
                IF @@FETCH_STATUS <> 0 BREAK; BEGIN TRY -- Kiểm tra điều kiện IF
                @payment_status != 'paid' BEGIN PRINT 'Order ' + CAST(@order_id
                AS VARCHAR) + ' chưa thanh toán, bỏ qua'; CONTINUE; -- Tiếp tục
                với order tiếp theo END; -- Xử lý order IF @total_amount >
                1000000 -- Đơn hàng lớn BEGIN -- Cần approval đặc biệt UPDATE
                orders SET status = 'pending_approval', notes = 'Đơn hàng lớn
                cần duyệt' WHERE order_id = @order_id; PRINT 'Order ' +
                CAST(@order_id AS VARCHAR) + ' cần duyệt (giá trị cao)'; END
                ELSE BEGIN -- Xử lý bình thường UPDATE orders SET status =
                'processing', processing_date = GETDATE() WHERE order_id =
                @order_id; -- Cập nhật inventory UPDATE products SET
                stock_quantity = stock_quantity - oi.quantity FROM products p
                INNER JOIN order_items oi ON p.product_id = oi.product_id WHERE
                oi.order_id = @order_id; PRINT 'Xử lý thành công order ' +
                CAST(@order_id AS VARCHAR); END; SET @processed_count =
                @processed_count + 1; END TRY BEGIN CATCH SET @error_count =
                @error_count + 1; -- Log lỗi INSERT INTO error_log (order_id,
                error_message, error_time) VALUES (@order_id, ERROR_MESSAGE(),
                GETDATE()); PRINT 'Lỗi xử lý order ' + CAST(@order_id AS
                VARCHAR) + ': ' + ERROR_MESSAGE(); -- Nếu quá nhiều lỗi, dừng xử
                lý IF @error_count >= @max_errors BEGIN PRINT 'Quá nhiều lỗi,
                dừng batch processing!'; BREAK; END; END CATCH; END; CLOSE
                order_cursor; DEALLOCATE order_cursor; -- Báo cáo kết quả PRINT
                'Batch processing hoàn thành:'; PRINT '- Đã xử lý: ' +
                CAST(@processed_count AS VARCHAR) + ' orders'; PRINT '- Lỗi: ' +
                CAST(@error_count AS VARCHAR) + ' orders'; -- Trả về status code
                IF @error_count = 0 RETURN 0; -- Thành công hoàn toàn ELSE IF
                @error_count < @max_errors RETURN 1; -- Thành công một phần ELSE
                RETURN -1; -- Thất bại END;
              </div>
            </div>

            <div class="highlight-box">
              <h4>🎯 Kết luận:</h4>
              <p>
                Các câu lệnh điều khiển giúp bạn tạo ra
                <b>logic phức tạp và xử lý các tình huống đặc biệt</b> trong
                SQL:
              </p>
              <ul>
                <li>
                  <b>IF...ELSE & CASE:</b> Xử lý điều kiện và phân nhánh logic
                </li>
                <li>
                  <b>WHILE:</b> Lặp lại các thao tác đến khi đạt điều kiện
                </li>
                <li><b>TRY...CATCH:</b> Xử lý lỗi an toàn và có kiểm soát</li>
                <li><b>RETURN:</b> Thoát sớm và trả về kết quả</li>
                <li><b>BREAK/CONTINUE:</b> Điều khiển luồng trong vòng lặp</li>
              </ul>
            </div>
          </section>

          <!-- 22 -->
          <section class="section" id="udf">
            <h2>22. UDF (User-Defined Function)</h2>

            <div class="info-box">
              <h4>🔧 UDF (User-Defined Function) là gì?</h4>
              <p>
                <b>User-Defined Function (Hàm do người dùng định nghĩa)</b> là
                một chương trình con được viết bằng SQL hoặc một ngôn ngữ khác
                (như C#, Java) và được lưu trữ trong cơ sở dữ liệu. Nó cho phép
                bạn <b>đóng gói các logic phức tạp, có thể tái sử dụng</b>, để
                thực hiện một tác vụ cụ thể.
              </p>
              <p>
                Thay vì phải viết đi viết lại một đoạn mã, bạn chỉ cần
                <b>gọi hàm này</b>.
              </p>
            </div>

            <h3>🌟 Ưu điểm của UDF</h3>
            <div class="success-box">
              <h4>✅ Những lợi ích chính:</h4>
              <ul>
                <li>
                  <b>Tái sử dụng code:</b> Bạn có thể gọi hàm nhiều lần trong
                  các truy vấn khác nhau mà không cần viết lại mã
                </li>
                <li>
                  <b>Cải thiện hiệu suất:</b> Các hàm được biên dịch và lưu trữ
                  trong cơ sở dữ liệu, giúp giảm thời gian thực thi
                </li>
                <li>
                  <b>Đơn giản hóa truy vấn:</b> Giúp các câu truy vấn phức tạp
                  trở nên dễ đọc và dễ hiểu hơn
                </li>
                <li>
                  <b>Tính nhất quán:</b> Đảm bảo logic tính toán được thực hiện
                  giống nhau ở mọi nơi
                </li>
                <li>
                  <b>Bảo mật:</b> Có thể ẩn logic phức tạp khỏi người dùng cuối
                </li>
              </ul>
            </div>

            <h3>📚 Các loại UDF phổ biến</h3>
            <div class="highlight-box">
              <p>Có <b>hai loại UDF chính</b> trong SQL Server:</p>
              <ul>
                <li><b>Scalar Function:</b> Trả về một giá trị duy nhất</li>
                <li><b>Table-Valued Function:</b> Trả về một bảng dữ liệu</li>
              </ul>
            </div>

            <h3>1️⃣ Scalar Function (Hàm vô hướng)</h3>
            <div class="example">
              <p>
                <b>Đặc điểm:</b> Hàm vô hướng nhận một hoặc nhiều tham số đầu
                vào và <b>trả về một giá trị duy nhất</b>.
              </p>

              <h4>Ví dụ cơ bản: Tính thuế VAT</h4>
              <div class="code-block">
                -- Tạo hàm tính thuế VAT 10% trên giá sản phẩm CREATE FUNCTION
                calculate_tax (@price DECIMAL(10, 2)) RETURNS DECIMAL(10, 2) AS
                BEGIN RETURN @price * 0.1; END;
              </div>

              <h4>Cách sử dụng:</h4>
              <div class="code-block">
                -- Sử dụng hàm để tính thuế cho một giá trị cụ thể SELECT
                dbo.calculate_tax(100) AS tax_amount; -- Trả về 10.00 -- Sử dụng
                hàm trong câu lệnh SELECT với bảng SELECT product_id,
                product_name, list_price, dbo.calculate_tax(list_price) AS
                tax_amount, list_price + dbo.calculate_tax(list_price) AS
                total_price FROM products;
              </div>
            </div>

            <div class="example">
              <h4>Scalar Function phức tạp hơn:</h4>
              <div class="code-block">
                -- Hàm tính discount dựa trên số lượng và loại khách hàng CREATE
                FUNCTION calculate_discount ( @quantity INT, @unit_price
                DECIMAL(10,2), @customer_type VARCHAR(20) ) RETURNS
                DECIMAL(10,2) AS BEGIN DECLARE @discount_rate DECIMAL(5,4) = 0;
                DECLARE @total_amount DECIMAL(15,2) = @quantity * @unit_price;
                -- Discount theo loại khách hàng IF @customer_type = 'VIP' SET
                @discount_rate = 0.15; -- 15% ELSE IF @customer_type = 'Premium'
                SET @discount_rate = 0.10; -- 10% ELSE IF @customer_type =
                'Regular' SET @discount_rate = 0.05; -- 5% -- Discount thêm theo
                số lượng IF @quantity >= 100 SET @discount_rate = @discount_rate
                + 0.05; -- +5% ELSE IF @quantity >= 50 SET @discount_rate =
                @discount_rate + 0.03; -- +3% ELSE IF @quantity >= 20 SET
                @discount_rate = @discount_rate + 0.02; -- +2% -- Giới hạn
                discount tối đa 25% IF @discount_rate > 0.25 SET @discount_rate
                = 0.25; RETURN @total_amount * @discount_rate; END; -- Sử dụng
                hàm SELECT c.customer_name, c.customer_type, oi.quantity,
                oi.unit_price, oi.quantity * oi.unit_price AS subtotal,
                dbo.calculate_discount(oi.quantity, oi.unit_price,
                c.customer_type) AS discount_amount, (oi.quantity *
                oi.unit_price) - dbo.calculate_discount(oi.quantity,
                oi.unit_price, c.customer_type) AS final_amount FROM order_items
                oi INNER JOIN orders o ON oi.order_id = o.order_id INNER JOIN
                customers c ON o.customer_id = c.customer_id;
              </div>
            </div>

            <div class="example">
              <h4>Hàm xử lý chuỗi:</h4>
              <div class="code-block">
                -- Hàm tạo mã sản phẩm tự động CREATE FUNCTION
                generate_product_code( @category_code VARCHAR(5),
                @sequence_number INT ) RETURNS VARCHAR(20) AS BEGIN DECLARE
                @product_code VARCHAR(20); DECLARE @year VARCHAR(4) =
                CAST(YEAR(GETDATE()) AS VARCHAR(4)); DECLARE @sequence
                VARCHAR(6) = RIGHT('000000' + CAST(@sequence_number AS VARCHAR),
                6); SET @product_code = @category_code + '-' + @year + '-' +
                @sequence; RETURN @product_code; END; -- Sử dụng SELECT
                dbo.generate_product_code('ELC', 1) AS product_code1, --
                ELC-2025-000001 dbo.generate_product_code('CLT', 245) AS
                product_code2, -- CLT-2025-000245
                dbo.generate_product_code('BK', 1052) AS product_code3; --
                BK-2025-001052
              </div>
            </div>

            <h3>2️⃣ Table-Valued Function (Hàm trả về bảng)</h3>
            <div class="example">
              <p>
                <b>Đặc điểm:</b> Hàm trả về bảng nhận một hoặc nhiều tham số đầu
                vào và <b>trả về một bảng dữ liệu</b> (một tập hợp các hàng và
                cột).
              </p>

              <h4>Inline Table-Valued Function:</h4>
              <div class="code-block">
                -- Hàm trả về danh sách sản phẩm theo thương hiệu CREATE
                FUNCTION get_products_by_brand (@brand_id INT) RETURNS TABLE AS
                RETURN ( SELECT product_id, product_name, brand_id, list_price,
                stock_quantity FROM products WHERE brand_id = @brand_id ); --
                Cách sử dụng SELECT * FROM dbo.get_products_by_brand(1); -- Sử
                dụng trong JOIN SELECT p.product_name, p.list_price,
                b.brand_name FROM dbo.get_products_by_brand(1) p INNER JOIN
                brands b ON p.brand_id = b.brand_id;
              </div>
            </div>

            <div class="example">
              <h4>Multi-Statement Table-Valued Function:</h4>
              <div class="code-block">
                -- Hàm trả về báo cáo bán hàng theo tháng CREATE FUNCTION
                get_monthly_sales_report(@year INT, @month INT) RETURNS
                @SalesReport TABLE ( product_id INT, product_name VARCHAR(100),
                category_name VARCHAR(50), quantity_sold INT, total_revenue
                DECIMAL(15,2), avg_price DECIMAL(10,2) ) AS BEGIN INSERT INTO
                @SalesReport SELECT p.product_id, p.product_name,
                c.category_name, SUM(oi.quantity) AS quantity_sold,
                SUM(oi.quantity * oi.unit_price) AS total_revenue,
                AVG(oi.unit_price) AS avg_price FROM products p INNER JOIN
                categories c ON p.category_id = c.category_id INNER JOIN
                order_items oi ON p.product_id = oi.product_id INNER JOIN orders
                o ON oi.order_id = o.order_id WHERE YEAR(o.order_date) = @year
                AND MONTH(o.order_date) = @month AND o.status = 'completed'
                GROUP BY p.product_id, p.product_name, c.category_name HAVING
                SUM(oi.quantity) > 0; RETURN; END; -- Sử dụng hàm SELECT * FROM
                dbo.get_monthly_sales_report(2025, 9) ORDER BY total_revenue
                DESC; -- Tìm top 5 sản phẩm bán chạy nhất SELECT TOP 5
                product_name, category_name, quantity_sold,
                FORMAT(total_revenue, 'N0') AS formatted_revenue FROM
                dbo.get_monthly_sales_report(2025, 9) ORDER BY quantity_sold
                DESC;
              </div>
            </div>

            <div class="example">
              <h4>Table-Valued Function với logic phức tạp:</h4>
              <div class="code-block">
                -- Hàm phân tích hiệu suất khách hàng CREATE FUNCTION
                analyze_customer_performance(@start_date DATE, @end_date DATE)
                RETURNS @CustomerAnalysis TABLE ( customer_id INT, customer_name
                VARCHAR(100), total_orders INT, total_spent DECIMAL(15,2),
                avg_order_value DECIMAL(10,2), last_order_date DATE,
                customer_segment VARCHAR(20), loyalty_score DECIMAL(5,2) ) AS
                BEGIN INSERT INTO @CustomerAnalysis SELECT c.customer_id,
                c.customer_name, COUNT(o.order_id) AS total_orders,
                COALESCE(SUM(o.total_amount), 0) AS total_spent,
                COALESCE(AVG(o.total_amount), 0) AS avg_order_value,
                MAX(o.order_date) AS last_order_date, CASE WHEN
                COALESCE(SUM(o.total_amount), 0) > 10000000 THEN 'VIP' WHEN
                COALESCE(SUM(o.total_amount), 0) > 5000000 THEN 'Premium' WHEN
                COALESCE(SUM(o.total_amount), 0) > 1000000 THEN 'Gold' WHEN
                COALESCE(SUM(o.total_amount), 0) > 0 THEN 'Regular' ELSE
                'Inactive' END AS customer_segment, -- Loyalty score: Tính dựa
                trên tần suất mua và giá trị CASE WHEN COUNT(o.order_id) = 0
                THEN 0 ELSE (COUNT(o.order_id) * 10) +
                (COALESCE(SUM(o.total_amount), 0) / 100000) + (CASE WHEN
                MAX(o.order_date) >= DATEADD(MONTH, -3, GETDATE()) THEN 20 WHEN
                MAX(o.order_date) >= DATEADD(MONTH, -6, GETDATE()) THEN 10 WHEN
                MAX(o.order_date) >= DATEADD(YEAR, -1, GETDATE()) THEN 5 ELSE 0
                END) END AS loyalty_score FROM customers c LEFT JOIN orders o ON
                c.customer_id = o.customer_id AND o.order_date BETWEEN
                @start_date AND @end_date AND o.status = 'completed' GROUP BY
                c.customer_id, c.customer_name; RETURN; END; -- Sử dụng để phân
                tích khách hàng SELECT customer_segment, COUNT(*) AS
                customer_count, AVG(total_spent) AS avg_spent_per_customer,
                AVG(loyalty_score) AS avg_loyalty_score FROM
                dbo.analyze_customer_performance('2024-01-01', '2025-09-21')
                GROUP BY customer_segment ORDER BY avg_spent_per_customer DESC;
              </div>
            </div>

            <h3>🔧 So sánh Scalar vs Table-Valued Functions</h3>
            <table>
              <thead>
                <tr>
                  <th>Đặc điểm</th>
                  <th>Scalar Function</th>
                  <th>Table-Valued Function</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>Giá trị trả về</b></td>
                  <td>Một giá trị duy nhất</td>
                  <td>Một bảng dữ liệu</td>
                </tr>
                <tr>
                  <td><b>Sử dụng trong</b></td>
                  <td>SELECT, WHERE, SET</td>
                  <td>FROM, JOIN</td>
                </tr>
                <tr>
                  <td><b>Performance</b></td>
                  <td>Nhanh cho logic đơn giản</td>
                  <td>Tốt cho tập dữ liệu phức tạp</td>
                </tr>
                <tr>
                  <td><b>Caching</b></td>
                  <td>Có thể cache kết quả</td>
                  <td>Inline TVF có thể optimize</td>
                </tr>
                <tr>
                  <td><b>Ví dụ sử dụng</b></td>
                  <td>Tính toán, format, validation</td>
                  <td>Filtering, reporting, joins</td>
                </tr>
              </tbody>
            </table>

            <h3>⚡ Performance và Best Practices</h3>

            <div class="success-box">
              <h4>✅ Nên làm:</h4>
              <ul>
                <li>
                  <b>Sử dụng Inline TVF:</b> Thay vì Multi-statement TVF khi có
                  thể
                </li>
                <li>
                  <b>Tối ưu logic:</b> Viết code SQL hiệu quả bên trong hàm
                </li>
                <li>
                  <b>Sử dụng tham số phù hợp:</b> Đúng kiểu dữ liệu và kích
                  thước
                </li>
                <li><b>Error handling:</b> Xử lý lỗi trong hàm phức tạp</li>
                <li><b>Đặt tên có ý nghĩa:</b> Dễ hiểu và maintain</li>
                <li>
                  <b>Document hàm:</b> Comment rõ ràng mục đích và cách dùng
                </li>
              </ul>
            </div>

            <div class="info-box">
              <h4>❌ Tránh:</h4>
              <ul>
                <li><b>UDF trong WHERE với bảng lớn:</b> Có thể chậm</li>
                <li><b>Logic quá phức tạp:</b> Nên dùng Stored Procedure</li>
                <li>
                  <b>Gọi UDF khác bên trong UDF:</b> Có thể gây performance
                  issues
                </li>
                <li>
                  <b>Non-deterministic functions:</b> GETDATE(), RAND() trong
                  Scalar UDF
                </li>
                <li><b>Side effects:</b> UDF không nên thay đổi dữ liệu</li>
              </ul>
            </div>

            <h3>🛠️ Quản lý UDF</h3>

            <div class="example">
              <h4>Xem thông tin UDF:</h4>
              <div class="code-block">
                -- Liệt kê tất cả UDF trong database SELECT
                OBJECT_SCHEMA_NAME(object_id) AS schema_name, name AS
                function_name, type_desc AS function_type, create_date,
                modify_date FROM sys.objects WHERE type IN ('FN', 'IF', 'TF') --
                FN=Scalar, IF=Inline TVF, TF=Multi-statement TVF ORDER BY
                schema_name, name; -- Xem definition của một UDF SELECT o.name
                AS function_name, m.definition FROM sys.objects o INNER JOIN
                sys.sql_modules m ON o.object_id = m.object_id WHERE o.name =
                'calculate_tax';
              </div>
            </div>

            <div class="example">
              <h4>Modify và Drop UDF:</h4>
              <div class="code-block">
                -- Sửa đổi hàm existing ALTER FUNCTION calculate_tax (@price
                DECIMAL(10, 2)) RETURNS DECIMAL(10, 2) AS BEGIN -- Cập nhật thuế
                VAT thành 8% RETURN @price * 0.08; END; -- Xóa hàm DROP FUNCTION
                IF EXISTS dbo.calculate_tax; -- Kiểm tra dependencies trước khi
                xóa SELECT OBJECT_SCHEMA_NAME(referencing_id) AS
                referencing_schema, OBJECT_NAME(referencing_id) AS
                referencing_object, o.type_desc AS referencing_type FROM
                sys.sql_expression_dependencies d INNER JOIN sys.objects o ON
                d.referencing_id = o.object_id WHERE referenced_id =
                OBJECT_ID('dbo.calculate_tax');
              </div>
            </div>

            <h3>🎯 Ví dụ tổng hợp: Hệ thống UDF cho E-commerce</h3>
            <div class="example">
              <h4>Bộ UDF hoàn chỉnh cho hệ thống bán hàng:</h4>
              <div class="code-block">
                -- 1. Scalar Function: Tính shipping fee CREATE FUNCTION
                calculate_shipping_fee( @weight DECIMAL(10,2), @distance INT,
                @express_delivery BIT = 0 ) RETURNS DECIMAL(10,2) AS BEGIN
                DECLARE @base_fee DECIMAL(10,2) = 20000; -- 20k base DECLARE
                @weight_fee DECIMAL(10,2) = 0; DECLARE @distance_fee
                DECIMAL(10,2) = 0; DECLARE @express_fee DECIMAL(10,2) = 0; --
                Phí theo trọng lượng SET @weight_fee = (@weight - 1) * 5000; --
                5k/kg sau kg đầu tiên IF @weight_fee < 0 SET @weight_fee = 0; --
                Phí theo khoảng cách IF @distance > 50 SET @distance_fee =
                (@distance - 50) * 500; -- 500/km sau 50km đầu -- Phí express IF
                @express_delivery = 1 SET @express_fee = @base_fee * 0.5; --
                <span class="operator"></span>+</span><span class="number">50</span><span class="operator">%</span> 
                <span class="keyword">RETURN</span> <span class="column">@base_fee</span> <span class="operator">+</span> <span class="column">@weight_fee</span> <span class="operator">+</span> <span class="column">@distance_fee</span> <span class="operator">+</span> <span class="column">@express_fee</span>;
                <span class="keyword">END</span>;

                <span class="comment">-- 2. Table-Valued Function: Lấy sản phẩm theo filter</span>
                <span class="keyword">CREATE FUNCTION</span> <span class="function">get_filtered_products</span>(
                  <span class="column">@category_id</span> <span class="datatype">INT</span> <span class="operator">=</span> <span class="keyword">NULL</span>,
                  <span class="column">@min_price</span> <span class="datatype">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="operator">=</span> <span class="keyword">NULL</span>,
                  <span class="column">@max_price</span> <span class="datatype">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="operator">=</span> <span class="keyword">NULL</span>,
                  <span class="column">@in_stock_only</span> <span class="datatype">BIT</span> <span class="operator">=</span> <span class="number">0</span>
                ) 
                <span class="keyword">RETURNS TABLE</span> 
                <span class="keyword">AS</span> 
                <span class="keyword">RETURN</span> (
                  <span class="keyword">SELECT</span> <span class="column">p.product_id</span>, <span class="column">p.product_name</span>, <span class="column">p.list_price</span>, <span class="column">p.stock_quantity</span>, 
                         <span class="column">c.category_name</span>, <span class="column">b.brand_name</span>
                  <span class="keyword">FROM</span> <span class="table">products</span> <span class="keyword">p</span>
                  <span class="keyword">INNER JOIN</span> <span class="table">categories</span> <span class="keyword">c</span> <span class="keyword">ON</span> <span class="column">p.category_id</span> <span class="operator">=</span> <span class="column">c.category_id</span>
                  <span class="keyword">INNER JOIN</span> <span class="table">brands</span> <span class="keyword">b</span> <span class="keyword">ON</span> <span class="column">p.brand_id</span> <span class="operator">=</span> <span class="column">b.brand_id</span>
                  <span class="keyword">WHERE</span> (<span class="column">@category_id</span> <span class="keyword">IS NULL</span> <span class="keyword">OR</span> <span class="column">p.category_id</span> <span class="operator">=</span> <span class="column">@category_id</span>)
                    <span class="keyword">AND</span> (<span class="column">@min_price</span> <span class="keyword">IS NULL</span> <span class="keyword">OR</span> <span class="column">p.list_price</span> <span class="operator">>=</span> <span class="column">@min_price</span>)
                    <span class="keyword">AND</span> (<span class="column">@max_price</span> <span class="keyword">IS NULL</span> <span class="keyword">OR</span> <span class="column">p.list_price</span> <span class="operator"><=</span> <span class="column">@max_price</span>)
                    <span class="keyword">AND</span> (<span class="column">@in_stock_only</span> <span class="operator">=</span> <span class="number">0</span> <span class="keyword">OR</span> <span class="column">p.stock_quantity</span> <span class="operator">></span> <span class="number">0</span>)
                );

                <span class="comment">-- 3. Sử dụng các UDF trong một query thực tế</span>
                <span class="keyword">SELECT</span> <span class="column">p.product_name</span>, <span class="column">p.list_price</span>, <span class="column">p.stock_quantity</span>,
                       <span class="function">dbo.calculate_tax</span>(<span class="column">p.list_price</span>) <span class="keyword">AS</span> <span class="column">tax_amount</span>,
                       <span class="column">p.list_price</span> <span class="operator">+</span> <span class="function">dbo.calculate_tax</span>(<span class="column">p.list_price</span>) <span class="keyword">AS</span> <span class="column">total_price</span>,
                       <span class="function">dbo.calculate_shipping_fee</span>(<span class="number">2.5</span>, <span class="number">75</span>, <span class="number">0</span>) <span class="keyword">AS</span> <span class="column">standard_shipping</span>,
                       <span class="function">dbo.calculate_shipping_fee</span>(<span class="number">2.5</span>, <span class="number">75</span>, <span class="number">1</span>) <span class="keyword">AS</span> <span class="column">express_shipping</span>
                <span class="keyword">FROM</span> <span class="function">dbo.get_filtered_products</span>(<span class="number">1</span>, <span class="number">100000</span>, <span class="number">500000</span>, <span class="number">1</span>) <span class="keyword">p</span>
                <span class="keyword">ORDER BY</span> <span class="column">p.list_price</span> <span class="keyword">DESC</span>;
              </div>
            </div>

            <div class="highlight-box">
              <h4>🎯 Kết luận:</h4>
              <p>
                <b>User-Defined Functions</b> là công cụ mạnh mẽ giúp bạn
                <b>tái sử dụng logic và đơn giản hóa SQL</b>:
              </p>
              <ul>
                <li>
                  <b>Scalar Functions:</b> Hoàn hảo cho tính toán, validation,
                  formatting
                </li>
                <li>
                  <b>Table-Valued Functions:</b> Tuyệt vời cho filtering,
                  reporting, complex queries
                </li>
                <li><b>Tái sử dụng cao:</b> Viết một lần, dùng nhiều nơi</li>
                <li><b>Maintainability:</b> Logic tập trung, dễ cập nhật</li>
                <li>
                  <b>Performance:</b> Được optimize và cached bởi SQL Engine
                </li>
              </ul>
            </div>
          </section>

          <!-- 23 -->
          <section class="section" id="sp">
            <h2>23. Stored Procedure</h2>

            <div class="info-box">
              <h4>⚙️ Stored Procedure là gì?</h4>
              <p>
                <b>Stored Procedure (Thủ tục lưu trữ)</b> là một chương trình
                con hoặc một tập hợp các câu lệnh SQL được
                <b>biên dịch và lưu trữ trong cơ sở dữ liệu</b>. Nó là một đối
                tượng cơ sở dữ liệu có tên, tương tự như một bảng hoặc một view.
              </p>
              <p>
                Khác với hàm UDF chỉ có thể trả về một giá trị hoặc một bảng,
                một Stored Procedure có thể
                <b>thực hiện nhiều tác vụ khác nhau</b>, bao gồm cả việc thay
                đổi dữ liệu (như INSERT, UPDATE, DELETE), chạy các câu lệnh điều
                khiển phức tạp (như IF/ELSE, WHILE), và trả về nhiều tập kết
                quả.
              </p>
            </div>

            <div class="example">
              <h4>Cú pháp chung:</h4>
              <div class="code-block">
                CREATE PROCEDURE procedure_name @parameter1 datatype,
                @parameter2 datatype = default_value AS BEGIN -- Các câu lệnh
                SQL -- Logic xử lý -- Return values (optional) END;
              </div>
            </div>

            <h3>🌟 Ưu điểm của Stored Procedure</h3>
            <div class="success-box">
              <p>
                Sử dụng Stored Procedure mang lại nhiều lợi ích quan trọng trong
                phát triển ứng dụng và quản lý cơ sở dữ liệu:
              </p>
              <ul>
                <li>
                  <b>Tăng hiệu suất:</b> Thủ tục lưu trữ được biên dịch và lưu
                  trữ sẵn trong cơ sở dữ liệu. Điều này giúp giảm thời gian xử
                  lý vì không cần phải biên dịch lại mỗi khi được gọi
                </li>
                <li>
                  <b>Tái sử dụng code:</b> Bạn có thể gọi một thủ tục lưu trữ
                  nhiều lần từ các ứng dụng khác nhau hoặc từ các thủ tục khác,
                  giúp tránh lặp lại mã và dễ dàng bảo trì
                </li>
                <li>
                  <b>Tăng cường bảo mật:</b> Bạn có thể cấp quyền cho người dùng
                  thực thi một thủ tục lưu trữ mà không cần cấp quyền truy cập
                  trực tiếp vào các bảng cơ sở
                </li>
                <li>
                  <b>Giảm lưu lượng mạng:</b> Thay vì gửi nhiều câu lệnh SQL qua
                  mạng, ứng dụng chỉ cần gửi tên của thủ tục và các tham số cần
                  thiết
                </li>
                <li>
                  <b>Tính nhất quán:</b> Logic nghiệp vụ được tập trung, đảm bảo
                  xử lý đồng nhất
                </li>
              </ul>
            </div>

            <h3>📝 Các loại Stored Procedure</h3>

            <h4>1️⃣ Thủ tục đơn giản (Simple Procedure)</h4>
            <div class="example">
              <p>Tạo một Stored Procedure để lấy tất cả sản phẩm:</p>
              <div class="code-block">
                <span class="keyword">CREATE PROCEDURE</span> <span class="function">get_products</span> 
                <span class="keyword">AS</span>
                <span class="keyword">BEGIN</span>
                  <span class="keyword">SELECT</span> <span class="column">product_id</span>, <span class="column">product_name</span>, <span class="column">list_price</span>, <span class="column">stock_quantity</span>, <span class="column">category_id</span>
                  <span class="keyword">FROM</span> <span class="table">products</span> 
                  <span class="keyword">ORDER BY</span> <span class="column">product_name</span>;
                <span class="keyword">END</span>;
                
                <span class="comment">-- Cách gọi</span>
                <span class="keyword">EXEC</span> <span class="function">get_products</span>;
              </div>
            </div>

            <h4>2️⃣ Thủ tục có tham số đầu vào (Input Parameters)</h4>
            <div class="example">
              <p>Tạo một Stored Procedure để lấy sản phẩm theo ID:</p>
              <div class="code-block">
                <span class="keyword">CREATE PROCEDURE</span> <span class="function">get_product_by_id</span> 
                  <span class="column">@product_id</span> <span class="datatype">INT</span> 
                <span class="keyword">AS</span>
                <span class="keyword">BEGIN</span>
                  <span class="comment">-- Kiểm tra tham số đầu vào</span>
                  <span class="keyword">IF</span> <span class="column">@product_id</span> <span class="keyword">IS NULL</span> <span class="keyword">OR</span> <span class="column">@product_id</span> <span class="operator"><=</span> <span class="number">0</span>
                  <span class="keyword">BEGIN</span>
                    <span class="keyword">RAISERROR</span>(<span class="string">'Product ID phải là số dương'</span>, <span class="number">16</span>, <span class="number">1</span>);
                    <span class="keyword">RETURN</span>;
                  <span class="keyword">END</span>;
                  
                  <span class="keyword">SELECT</span> <span class="column">p.product_id</span>, <span class="column">p.product_name</span>, <span class="column">p.list_price</span>, <span class="column">p.stock_quantity</span>,
                         <span class="column">c.category_name</span>, <span class="column">b.brand_name</span>
                  <span class="keyword">FROM</span> <span class="table">products</span> <span class="keyword">p</span>
                  <span class="keyword">LEFT JOIN</span> <span class="table">categories</span> <span class="keyword">c</span> <span class="keyword">ON</span> <span class="column">p.category_id</span> <span class="operator">=</span> <span class="column">c.category_id</span>
                  <span class="keyword">LEFT JOIN</span> <span class="table">brands</span> <span class="keyword">b</span> <span class="keyword">ON</span> <span class="column">p.brand_id</span> <span class="operator">=</span> <span class="column">b.brand_id</span>
                  <span class="keyword">WHERE</span> <span class="column">p.product_id</span> <span class="operator">=</span> <span class="column">@product_id</span>;
                  
                  <span class="comment">-- Kiểm tra xem có tìm thấy sản phẩm không</span>
                  <span class="keyword">IF</span> <span class="function">@@ROWCOUNT</span> <span class="operator">=</span> <span class="number">0</span>
                  <span class="keyword">BEGIN</span>
                    <span class="keyword">PRINT</span> <span class="string">'Không tìm thấy sản phẩm với ID: '</span> <span class="operator">+</span> <span class="function">CAST</span>(<span class="column">@product_id</span> <span class="keyword">AS</span> <span class="datatype">VARCHAR</span>);
                  <span class="keyword">END</span>;
                <span class="keyword">END</span>;
                
                <span class="comment">-- Cách gọi</span>
                <span class="keyword">EXEC</span> <span class="function">get_product_by_id</span> <span class="column">@product_id</span> <span class="operator">=</span> <span class="number">10</span>;
                <span class="keyword">EXEC</span> <span class="function">get_product_by_id</span> <span class="number">10</span>; <span class="comment">-- Cách viết ngắn gọn</span>
              </div>
            </div>

            <h4>3️⃣ Thủ tục với tham số có giá trị mặc định</h4>
            <div class="example">
              <div class="code-block">
                <span class="keyword"></span>CREATE PROCEDURE</span> <span class="function">get_products_by_category</span> 
                  <span class="column">@category_id</span> <span class="datatype">INT</span> <span class="operator">=</span> <span class="keyword">NULL</span>,
                  <span class="column">@min_price</span> <span class="datatype">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="operator">=</span> <span class="number">0</span>,
                  <span class="column">@max_price</span> <span class="datatype">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="operator">=</span> <span class="keyword">NULL</span>,
                  <span class="column">@order_by</span> <span class="datatype">VARCHAR</span>(<span class="number">50</span>) <span class="operator">=</span> <span class="string">'product_name'</span>
                <span class="keyword">AS</span>
                <span class="keyword">BEGIN</span>
                  <span class="comment">-- Validate order by parameter</span>
                  <span class="keyword">IF</span> <span class="column">@order_by</span> <span class="keyword">NOT IN</span> (<span class="string">'product_name'</span>, <span class="string">'list_price'</span>, <span class="string">'stock_quantity'</span>)
                  <span class="keyword">BEGIN</span>
                    <span class="keyword">SET</span> <span class="column">@order_by</span> <span class="operator">=</span> <span class="string">'product_name'</span>;
                  <span class="keyword">END</span>;
                  
                  <span class="comment">-- Dynamic query với parameters</span>
                  <span class="keyword">SELECT</span> <span class="column">p.product_id</span>, <span class="column">p.product_name</span>, <span class="column">p.list_price</span>, <span class="column">p.stock_quantity</span>, <span class="column">c.category_name</span>
                  <span class="keyword">FROM</span> <span class="table">products</span> <span class="keyword">p</span>
                  <span class="keyword">INNER JOIN</span> <span class="table">categories</span> <span class="keyword">c</span> <span class="keyword">ON</span> <span class="column">p.category_id</span> <span class="operator">=</span> <span class="column">c.category_id</span>
                  <span class="keyword">WHERE</span> (<span class="column">@category_id</span> <span class="keyword">IS NULL</span> <span class="keyword">OR</span> <span class="column">p.category_id</span> <span class="operator">=</span> <span class="column">@category_id</span>)
                    <span class="keyword">AND</span> <span class="column">p.list_price</span> <span class="operator">>=</span> <span class="column">@min_price</span>
                    <span class="keyword">AND</span> (<span class="column">@max_price</span> <span class="keyword">IS NULL</span> <span class="keyword">OR</span> <span class="column">p.list_price</span> <span class="operator"><=</span> <span class="column">@max_price</span>)
                  <span class="keyword">ORDER BY</span> 
                    <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="column">@order_by</span> <span class="operator">=</span> <span class="string">'product_name'</span> <span class="keyword">THEN</span> <span class="column">p.product_name</span> <span class="keyword">END</span>,
                    <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="column">@order_by</span> <span class="operator">=</span> <span class="string">'list_price'</span> <span class="keyword">THEN</span> <span class="column">p.list_price</span> <span class="keyword">END</span>,
                    <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="column">@order_by</span> <span class="operator">=</span> <span class="string">'stock_quantity'</span> <span class="keyword">THEN</span> <span class="column">p.stock_quantity</span> <span class="keyword">END</span>;
                <span class="keyword">END</span>;
                
                <span class="comment">-- Các cách gọi khác nhau</span>
                <span class="keyword">EXEC</span> <span class="function">get_products_by_category</span>; <span class="comment">-- Lấy tất cả</span>
                <span class="keyword">EXEC</span> <span class="function">get_products_by_category</span> <span class="column">@category_id</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- Theo category</span>
                <span class="keyword">EXEC</span> <span class="function">get_products_by_category</span> <span class="column">@min_price</span> <span class="operator">=</span> <span class="number">100000</span>, <span class="column">@max_price</span> <span class="operator">=</span> <span class="number">500000</span>; <span class="comment">-- Theo giá</span>
                <span class="keyword">EXEC</span> <span class="function">get_products_by_category</span> <span class="column">@category_id</span> <span class="operator">=</span> <span class="number">1</span>, <span class="column">@order_by</span> <span class="operator">=</span> <span class="string">'list_price'</span>; <span class="comment">-- Với sắp xếp</span>
              </div>
            </div>

            <h4>4️⃣ Thủ tục với tham số đầu ra (Output Parameters)</h4>
            <div class="example">
              <div class="code-block">
                <span class="keyword"></span>CREATE PROCEDURE</span> <span class="function">get_order_summary</span> 
                  <span class="column">@customer_id</span> <span class="datatype">INT</span>,
                  <span class="column">@total_orders</span> <span class="datatype">INT</span> <span class="keyword">OUTPUT</span>,
                  <span class="column">@total_amount</span> <span class="datatype">DECIMAL</span>(<span class="number">15</span>,<span class="number">2</span>) <span class="keyword">OUTPUT</span>,
                  <span class="column">@avg_order_value</span> <span class="datatype">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">OUTPUT</span>,
                  <span class="column">@last_order_date</span> <span class="datatype">DATE</span> <span class="keyword">OUTPUT</span>
                <span class="keyword">AS</span>
                <span class="keyword">BEGIN</span>
                  <span class="keyword">SELECT</span> <span class="column">@total_orders</span> <span class="operator">=</span> <span class="function">COUNT</span>(<span class="column">order_id</span>),
                         <span class="column">@total_amount</span> <span class="operator">=</span> <span class="function">COALESCE</span>(<span class="function">SUM</span>(<span class="column">total_amount</span>), <span class="number">0</span>),
                         <span class="column">@avg_order_value</span> <span class="operator">=</span> <span class="function">COALESCE</span>(<span class="function">AVG</span>(<span class="column">total_amount</span>), <span class="number">0</span>),
                         <span class="column">@last_order_date</span> <span class="operator">=</span> <span class="function">MAX</span>(<span class="column">order_date</span>)
                  <span class="keyword">FROM</span> <span class="table">orders</span> 
                  <span class="keyword">WHERE</span> <span class="column">customer_id</span> <span class="operator">=</span> <span class="column">@customer_id</span> <span class="keyword">AND</span> <span class="column">status</span> <span class="operator">=</span> <span class="string">'completed'</span>;
                  
                  <span class="comment">-- Trả về thông tin chi tiết trong result set</span>
                  <span class="keyword">SELECT</span> <span class="column">c.customer_name</span>, <span class="column">@total_orders</span> <span class="keyword">AS</span> <span class="column">total_orders</span>,
                         <span class="column">@total_amount</span> <span class="keyword">AS</span> <span class="column">total_amount</span>, <span class="column">@avg_order_value</span> <span class="keyword">AS</span> <span class="column">avg_order_value</span>,
                         <span class="column">@last_order_date</span> <span class="keyword">AS</span> <span class="column">last_order_date</span>,
                         <span class="keyword">CASE</span> 
                           <span class="keyword">WHEN</span> <span class="column">@total_amount</span> <span class="operator">></span> <span class="number">10000000</span> <span class="keyword">THEN</span> <span class="string">'VIP'</span>
                           <span class="keyword">WHEN</span> <span class="column">@total_amount</span> <span class="operator">></span> <span class="number">5000000</span> <span class="keyword">THEN</span> <span class="string">'Premium'</span>
                           <span class="keyword">WHEN</span> <span class="column">@total_amount</span> <span class="operator">></span> <span class="number">1000000</span> <span class="keyword">THEN</span> <span class="string">'Gold'</span>
                           <span class="keyword">ELSE</span> <span class="string">'Regular'</span>
                         <span class="keyword">END</span> <span class="keyword">AS</span> <span class="column">customer_tier</span>
                  <span class="keyword">FROM</span> <span class="table">customers</span> <span class="keyword">c</span> 
                  <span class="keyword">WHERE</span> <span class="column">c.customer_id</span> <span class="operator">=</span> <span class="column">@customer_id</span>;
                <span class="keyword">END</span>;
                
                <span class="comment">-- Cách sử dụng với OUTPUT parameters</span>
                <span class="keyword">DECLARE</span> <span class="column">@orders</span> <span class="datatype">INT</span>, <span class="column">@amount</span> <span class="datatype">DECIMAL</span>(<span class="number">15</span>,<span class="number">2</span>), <span class="column">@avg</span> <span class="datatype">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>), <span class="column">@last_date</span> <span class="datatype">DATE</span>;
                
                <span class="keyword">EXEC</span> <span class="function">get_order_summary</span> 
                  <span class="column">@customer_id</span> <span class="operator">=</span> <span class="number">1</span>,
                  <span class="column">@total_orders</span> <span class="operator">=</span> <span class="column">@orders</span> <span class="keyword">OUTPUT</span>,
                  <span class="column">@total_amount</span> <span class="operator">=</span> <span class="column">@amount</span> <span class="keyword">OUTPUT</span>,
                  <span class="column">@avg_order_value</span> <span class="operator">=</span> <span class="column">@avg</span> <span class="keyword">OUTPUT</span>,
                  <span class="column">@last_order_date</span> <span class="operator">=</span> <span class="column">@last_date</span> <span class="keyword">OUTPUT</span>;
                  
                <span class="comment">-- Sử dụng các giá trị OUTPUT</span>
                <span class="keyword">PRINT</span> <span class="string">'Tổng đơn hàng: '</span> <span class="operator">+</span> <span class="function">CAST</span>(<span class="column">@orders</span> <span class="keyword">AS</span> <span class="datatype">VARCHAR</span>);
                <span class="keyword">PRINT</span> <span class="string">'Tổng giá trị: '</span> <span class="operator">+</span> <span class="function">FORMAT</span>(<span class="column">@amount</span>, <span class="string">'N0'</span>);
                <span class="keyword">PRINT</span> <span class="string">'Giá trị trung bình: '</span> <span class="operator">+</span> <span class="function">FORMAT</span>(<span class="column">@avg</span>, <span class="string">'N0'</span>);
                <span class="keyword">PRINT</span> <span class="string">'Đơn hàng cuối: '</span> <span class="operator">+</span> <span class="function">CAST</span>(<span class="column">@last_date</span> <span class="keyword">AS</span> <span class="datatype">VARCHAR</span>);
              </div>
            </div>

            <h4>5️⃣ Thủ tục với logic điều khiển phức tạp</h4>
            <div class="example">
              <p>
                Tạo một Stored Procedure để chèn sản phẩm mới, kiểm tra nếu tên
                sản phẩm đã tồn tại:
              </p>
              <div class="code-block">
                CREATE PROCEDURE insert_new_product @product_name VARCHAR(255),
                @category_id INT, @brand_id INT, @list_price DECIMAL(10,2),
                @stock_quantity INT = 0, @description NTEXT = NULL,
                @new_product_id INT OUTPUT AS BEGIN SET NOCOUNT ON; -- Không trả
                về row count DECLARE @error_message VARCHAR(500); BEGIN TRY --
                Validate inputs IF LTRIM(RTRIM(@product_name)) = '' BEGIN
                RAISERROR('Tên sản phẩm không được để trống', 16, 1); RETURN;
                END; IF @list_price < 0 BEGIN RAISERROR('Giá sản phẩm không được
                âm', 16, 1); RETURN; END; -- Kiểm tra category exists IF NOT
                EXISTS (SELECT 1 FROM categories WHERE category_id =
                @category_id) BEGIN RAISERROR('Category ID không tồn tại: %d',
                16, 1, @category_id); RETURN; END; -- Kiểm tra brand exists IF
                NOT EXISTS (SELECT 1 FROM brands WHERE brand_id = @brand_id)
                BEGIN RAISERROR('Brand ID không tồn tại: %d', 16, 1, @brand_id);
                RETURN; END; -- Kiểm tra duplicate product name IF EXISTS
                (SELECT 1 FROM products WHERE product_name = @product_name)
                BEGIN PRINT 'Cảnh báo: Sản phẩm "' + @product_name + '" đã tồn
                tại.'; -- Lấy ID của sản phẩm existing SELECT @new_product_id =
                product_id FROM products WHERE product_name = @product_name;
                RETURN; END; -- Insert new product INSERT INTO products (
                product_name, category_id, brand_id, list_price, stock_quantity,
                description, created_date, updated_date ) VALUES (
                @product_name, @category_id, @brand_id, @list_price,
                @stock_quantity, @description, GETDATE(), GETDATE() ); -- Lấy ID
                của sản phẩm vừa tạo SET @new_product_id = SCOPE_IDENTITY();
                PRINT 'Sản phẩm "' + @product_name + '" đã được thêm thành công
                với ID: ' + CAST(@new_product_id AS VARCHAR); END TRY BEGIN
                CATCH SET @error_message = ERROR_MESSAGE(); RAISERROR('Lỗi khi
                thêm sản phẩm: %s', 16, 1, @error_message); END CATCH; END; --
                Sử dụng procedure DECLARE @product_id INT; EXEC
                insert_new_product @product_name = 'iPhone 15 Pro Max',
                @category_id = 1, @brand_id = 2, @list_price = 29990000,
                @stock_quantity = 50, @description = 'Flagship smartphone from
                Apple', @new_product_id = @product_id OUTPUT; IF @product_id IS
                NOT NULL PRINT 'Product created with ID: ' + CAST(@product_id AS
                VARCHAR);
              </div>
            </div>

            <h3>🔄 Stored Procedure với Transaction</h3>
            <div class="example">
              <h4>Procedure xử lý đặt hàng với transaction safety:</h4>
              <div class="code-block">
                CREATE PROCEDURE process_order @customer_id INT, @product_items
                NVARCHAR(MAX), -- JSON string: [{"product_id":1,"quantity":2}]
                @payment_method VARCHAR(50), @shipping_address NVARCHAR(500),
                @order_id INT OUTPUT AS BEGIN SET NOCOUNT ON; DECLARE
                @total_amount DECIMAL(15,2) = 0; DECLARE @error_message
                VARCHAR(500); BEGIN TRANSACTION; BEGIN TRY -- Validate customer
                IF NOT EXISTS (SELECT 1 FROM customers WHERE customer_id =
                @customer_id) BEGIN RAISERROR('Customer không tồn tại', 16, 1);
                RETURN; END; -- Create order INSERT INTO orders (customer_id,
                order_date, status, payment_method, shipping_address) VALUES
                (@customer_id, GETDATE(), 'processing', @payment_method,
                @shipping_address); SET @order_id = SCOPE_IDENTITY(); -- Process
                order items (giả sử dùng JSON) DECLARE @product_id INT,
                @quantity INT, @unit_price DECIMAL(10,2), @stock INT; -- Cursor
                để xử lý từng item (simplified example) DECLARE item_cursor
                CURSOR FOR SELECT product_id, quantity FROM
                OPENJSON(@product_items) WITH (product_id INT '$.product_id',
                quantity INT '$.quantity'); OPEN item_cursor; WHILE 1 = 1 BEGIN
                FETCH NEXT FROM item_cursor INTO @product_id, @quantity; IF
                @@FETCH_STATUS <> 0 BREAK; -- Get product info and check stock
                SELECT @unit_price = list_price, @stock = stock_quantity FROM
                products WHERE product_id = @product_id; IF @unit_price IS NULL
                BEGIN RAISERROR('Product ID %d không tồn tại', 16, 1,
                @product_id); CLOSE item_cursor; DEALLOCATE item_cursor;
                ROLLBACK TRANSACTION; RETURN; END; IF @stock < @quantity BEGIN
                RAISERROR('Không đủ stock cho product ID %d. Còn lại: %d', 16,
                1, @product_id, @stock); CLOSE item_cursor; DEALLOCATE
                item_cursor; ROLLBACK TRANSACTION; RETURN; END; -- Insert order
                item INSERT INTO order_items (order_id, product_id, quantity,
                unit_price) VALUES (@order_id, @product_id, @quantity,
                @unit_price); -- Update stock UPDATE products SET stock_quantity
                = stock_quantity - @quantity, updated_date = GETDATE() WHERE
                product_id = @product_id; SET @total_amount = @total_amount +
                (@quantity * @unit_price); END; CLOSE item_cursor; DEALLOCATE
                item_cursor; -- Update order total UPDATE orders SET
                total_amount = @total_amount, updated_date = GETDATE() WHERE
                order_id = @order_id; COMMIT TRANSACTION; PRINT 'Đơn hàng ' +
                CAST(@order_id AS VARCHAR) + ' đã được tạo thành công. Tổng
                tiền: ' + FORMAT(@total_amount, 'N0'); END TRY BEGIN CATCH IF
                @@TRANCOUNT > 0 ROLLBACK TRANSACTION; SET @error_message =
                ERROR_MESSAGE(); RAISERROR('Lỗi xử lý đơn hàng: %s', 16, 1,
                @error_message); SET @order_id = NULL; END CATCH; END;
              </div>
            </div>

            <h3>📊 Stored Procedure trả về nhiều Result Sets</h3>
            <div class="example">
              <div class="code-block">
                CREATE PROCEDURE get_customer_dashboard @customer_id INT AS
                BEGIN SET NOCOUNT ON; -- Result Set 1: Customer Info SELECT
                customer_id, customer_name, email, phone, registration_date,
                customer_type FROM customers WHERE customer_id = @customer_id;
                -- Result Set 2: Recent Orders SELECT TOP 10 order_id,
                order_date, status, total_amount, payment_method FROM orders
                WHERE customer_id = @customer_id ORDER BY order_date DESC; --
                Result Set 3: Favorite Products SELECT TOP 5 p.product_name,
                SUM(oi.quantity) AS total_purchased, AVG(oi.unit_price) AS
                avg_price FROM order_items oi INNER JOIN orders o ON oi.order_id
                = o.order_id INNER JOIN products p ON oi.product_id =
                p.product_id WHERE o.customer_id = @customer_id AND o.status =
                'completed' GROUP BY p.product_id, p.product_name ORDER BY
                total_purchased DESC; -- Result Set 4: Summary Statistics SELECT
                COUNT(DISTINCT o.order_id) AS total_orders,
                COALESCE(SUM(o.total_amount), 0) AS total_spent,
                COALESCE(AVG(o.total_amount), 0) AS avg_order_value,
                MAX(o.order_date) AS last_order_date FROM orders o WHERE
                o.customer_id = @customer_id AND o.status = 'completed'; END; --
                Gọi procedure sẽ trả về 4 result sets EXEC
                get_customer_dashboard @customer_id = 1;
              </div>
            </div>

            <h3>🔧 Quản lý Stored Procedures</h3>

            <div class="example">
              <h4>Xem thông tin Stored Procedures:</h4>
              <div class="code-block">
                -- Liệt kê tất cả stored procedures SELECT
                SCHEMA_NAME(schema_id) AS schema_name, name AS procedure_name,
                create_date, modify_date, type_desc FROM sys.procedures ORDER BY
                schema_name, name; -- Xem definition của một procedure SELECT
                p.name AS procedure_name, m.definition FROM sys.procedures p
                INNER JOIN sys.sql_modules m ON p.object_id = m.object_id WHERE
                p.name = 'get_products'; -- Xem parameters của một procedure
                SELECT p.name AS procedure_name, pm.name AS parameter_name,
                t.name AS data_type, pm.max_length, pm.precision, pm.scale,
                pm.is_output FROM sys.procedures p INNER JOIN sys.parameters pm
                ON p.object_id = pm.object_id INNER JOIN sys.types t ON
                pm.user_type_id = t.user_type_id WHERE p.name = 'process_order'
                ORDER BY pm.parameter_id;
              </div>
            </div>

            <div class="example">
              <h4>Modify và Drop Procedures:</h4>
              <div class="code-block">
                -- Sửa đổi procedure existing ALTER PROCEDURE get_products AS
                BEGIN SELECT product_id, product_name, list_price,
                stock_quantity, CASE WHEN stock_quantity > 100 THEN 'In Stock'
                WHEN stock_quantity > 0 THEN 'Low Stock' ELSE 'Out of Stock' END
                AS stock_status FROM products WHERE stock_quantity >= 0 -- Only
                show valid products ORDER BY product_name; END; -- Xóa procedure
                DROP PROCEDURE IF EXISTS dbo.old_procedure_name; -- Kiểm tra
                dependencies trước khi xóa SELECT
                OBJECT_SCHEMA_NAME(referencing_id) AS referencing_schema,
                OBJECT_NAME(referencing_id) AS referencing_object, o.type_desc
                AS referencing_type FROM sys.sql_expression_dependencies d INNER
                JOIN sys.objects o ON d.referencing_id = o.object_id WHERE
                referenced_id = OBJECT_ID('dbo.get_products');
              </div>
            </div>

            <h3>⚡ Performance và Best Practices</h3>

            <div class="success-box">
              <h4>✅ Nên làm:</h4>
              <ul>
                <li>
                  <b>SET NOCOUNT ON:</b> Tắt messages về row count để tăng
                  performance
                </li>
                <li>
                  <b>Validate inputs:</b> Kiểm tra tham số đầu vào kỹ lưỡng
                </li>
                <li>
                  <b>Use transactions:</b> Đảm bảo data consistency với
                  BEGIN/COMMIT/ROLLBACK
                </li>
                <li>
                  <b>Error handling:</b> Sử dụng TRY...CATCH cho tất cả
                  procedures quan trọng
                </li>
                <li>
                  <b>Use OUTPUT parameters:</b> Trả về status codes và values
                </li>
                <li><b>Optimize queries:</b> Đảm bảo có index phù hợp</li>
                <li>
                  <b>Document thoroughly:</b> Comment rõ ràng logic và
                  parameters
                </li>
              </ul>
            </div>

            <div class="info-box">
              <h4>❌ Tránh:</h4>
              <ul>
                <li>
                  <b>Dynamic SQL không cần thiết:</b> Có thể gây SQL injection
                </li>
                <li><b>Procedures quá dài:</b> Khó maintain và debug</li>
                <li><b>Hardcode values:</b> Nên dùng parameters</li>
                <li><b>Không xử lý lỗi:</b> Có thể gây data inconsistency</li>
                <li>
                  <b>Cursors không cần thiết:</b> Chậm hơn set-based operations
                </li>
                <li>
                  <b>Quá nhiều result sets:</b> Gây khó khăn cho application
                </li>
              </ul>
            </div>

            <h3>🔄 So sánh Stored Procedure vs UDF vs View</h3>
            <table>
              <thead>
                <tr>
                  <th>Đặc điểm</th>
                  <th>Stored Procedure</th>
                  <th>User-Defined Function</th>
                  <th>View</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>Có thể thay đổi dữ liệu</b></td>
                  <td>Có (INSERT/UPDATE/DELETE)</td>
                  <td>Không</td>
                  <td>Không (chỉ đọc)</td>
                </tr>
                <tr>
                  <td><b>Trả về</b></td>
                  <td>Multiple result sets, parameters</td>
                  <td>Single value hoặc table</td>
                  <td>Single result set</td>
                </tr>
                <tr>
                  <td><b>Sử dụng trong SELECT</b></td>
                  <td>Không</td>
                  <td>Có (UDF)</td>
                  <td>Có</td>
                </tr>
                <tr>
                  <td><b>Transaction support</b></td>
                  <td>Có</td>
                  <td>Không</td>
                  <td>Không</td>
                </tr>
                <tr>
                  <td><b>Error handling</b></td>
                  <td>TRY...CATCH</td>
                  <td>Hạn chế</td>
                  <td>Không</td>
                </tr>
                <tr>
                  <td><b>Khi nào dùng</b></td>
                  <td>Complex business logic</td>
                  <td>Calculations, formatting</td>
                  <td>Simple data presentation</td>
                </tr>
              </tbody>
            </table>

            <div class="highlight-box">
              <h4>🎯 Kết luận:</h4>
              <p>
                <b>Stored Procedures</b> là công cụ mạnh mẽ nhất để
                <b>xử lý logic nghiệp vụ phức tạp</b> trong SQL:
              </p>
              <ul>
                <li><b>Flexibility:</b> Có thể thực hiện mọi thao tác SQL</li>
                <li><b>Security:</b> Kiểm soát truy cập chặt chẽ</li>
                <li><b>Performance:</b> Được compile và cache</li>
                <li><b>Transaction support:</b> Đảm bảo data integrity</li>
                <li><b>Reusability:</b> Logic tập trung, dễ maintain</li>
              </ul>
            </div>
          </section>

          <!-- 24 -->
          <section class="section" id="exception">
            <h2>24. Exception</h2>

            <div class="info-box">
              <h4>⚠️ Xử lý ngoại lệ là gì?</h4>
              <p>
                <b>Xử lý ngoại lệ (Exception Handling)</b> là một cơ chế cho
                phép bạn quản lý và phản ứng với các lỗi hoặc các tình huống bất
                thường có thể xảy ra trong quá trình thực thi một câu lệnh SQL
                hoặc một khối mã.
              </p>
              <p>
                Thay vì để chương trình bị dừng đột ngột, cơ chế này giúp bạn
                <b>"bắt" lỗi và thực hiện một hành động nào đó</b> (như ghi lại
                lỗi, trả về một thông báo thân thiện, hoặc hủy bỏ giao dịch).
              </p>
            </div>

            <h3>🛡️ TRY...CATCH trong SQL Server</h3>
            <div class="highlight-box">
              <p>
                Cơ chế TRY...CATCH được sử dụng để xử lý lỗi một cách có cấu
                trúc trong SQL Server. Nó hoạt động tương tự như trong các ngôn
                ngữ lập trình khác.
              </p>
            </div>

            <div class="example">
              <h4>📋 Cấu trúc TRY...CATCH:</h4>
              <div class="code-block">
                BEGIN TRY -- Khối mã có thể gây lỗi -- Các câu lệnh SQL cần kiểm
                soát lỗi END TRY BEGIN CATCH -- Khối xử lý lỗi -- Được thực thi
                khi có lỗi xảy ra trong TRY -- Có thể sử dụng các hàm ERROR_*()
                để lấy thông tin lỗi END CATCH;
              </div>

              <p><b>Khối TRY:</b></p>
              <ul>
                <li>
                  Chứa một hoặc nhiều câu lệnh SQL mà bạn muốn kiểm soát lỗi
                </li>
                <li>
                  Nếu bất kỳ lỗi nào xảy ra trong khối này, việc thực thi sẽ
                  dừng lại và chuyển đến khối CATCH
                </li>
              </ul>

              <p><b>Khối CATCH:</b></p>
              <ul>
                <li>Chứa các câu lệnh SQL để xử lý lỗi</li>
                <li>
                  Khối này chỉ được thực thi khi có lỗi xảy ra trong khối TRY
                </li>
                <li>
                  Bạn có thể sử dụng các hàm hệ thống để lấy thông tin chi tiết
                  về lỗi
                </li>
              </ul>
            </div>

            <h3>🔍 Các hàm ERROR trong CATCH</h3>
            <table>
              <thead>
                <tr>
                  <th>Hàm</th>
                  <th>Mô tả</th>
                  <th>Ví dụ trả về</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>ERROR_NUMBER()</b></td>
                  <td>Số lỗi của hệ thống</td>
                  <td>547, 8134, 2627</td>
                </tr>
                <tr>
                  <td><b>ERROR_MESSAGE()</b></td>
                  <td>Thông báo lỗi chi tiết</td>
                  <td>"Division by zero error"</td>
                </tr>
                <tr>
                  <td><b>ERROR_SEVERITY()</b></td>
                  <td>Mức độ nghiêm trọng (1-25)</td>
                  <td>16 (User errors)</td>
                </tr>
                <tr>
                  <td><b>ERROR_STATE()</b></td>
                  <td>Trạng thái lỗi</td>
                  <td>1, 2, 3...</td>
                </tr>
                <tr>
                  <td><b>ERROR_LINE()</b></td>
                  <td>Số dòng xảy ra lỗi</td>
                  <td>15, 23, 45...</td>
                </tr>
                <tr>
                  <td><b>ERROR_PROCEDURE()</b></td>
                  <td>Tên stored procedure/function</td>
                  <td>"sp_insert_order"</td>
                </tr>
              </tbody>
            </table>

            <h3>💡 Ví dụ cơ bản</h3>
            <div class="example">
              <h4>Xử lý lỗi chia cho 0:</h4>
              <div class="code-block">
                BEGIN TRY DECLARE @result INT; SET @result = 10 / 0; -- Gây lỗi
                chia cho 0 PRINT 'Kết quả: ' + CAST(@result AS VARCHAR); END TRY
                BEGIN CATCH PRINT 'Đã xảy ra lỗi!'; PRINT 'Mã lỗi: ' +
                CAST(ERROR_NUMBER() AS VARCHAR); PRINT 'Thông báo: ' +
                ERROR_MESSAGE(); PRINT 'Độ nghiêm trọng: ' +
                CAST(ERROR_SEVERITY() AS VARCHAR); PRINT 'Trạng thái: ' +
                CAST(ERROR_STATE() AS VARCHAR); PRINT 'Dòng lỗi: ' +
                CAST(ERROR_LINE() AS VARCHAR); END CATCH; -- Kết quả sẽ in ra:
                -- Đã xảy ra lỗi! -- Mã lỗi: 8134 -- Thông báo: Divide by zero
                error encountered. -- Độ nghiêm trọng: 16 -- Trạng thái: 1 --
                Dòng lỗi: 3
              </div>
            </div>

            <h3>🔄 TRY...CATCH với Transaction</h3>
            <div class="example">
              <h4>Ví dụ thêm đơn hàng với xử lý lỗi:</h4>
              <div class="code-block">
                -- Stored Procedure thêm đơn hàng an toàn CREATE PROCEDURE
                sp_create_order @customer_id INT, @product_id INT, @quantity INT
                AS BEGIN SET NOCOUNT ON; DECLARE @order_id INT; DECLARE
                @stock_quantity INT; DECLARE @unit_price DECIMAL(10,2); BEGIN
                TRY -- Bắt đầu transaction BEGIN TRANSACTION; -- Kiểm tra
                customer tồn tại IF NOT EXISTS (SELECT 1 FROM customers WHERE
                customer_id = @customer_id) BEGIN RAISERROR('Customer ID %d
                không tồn tại', 16, 1, @customer_id); RETURN; END; -- Kiểm tra
                sản phẩm và lấy thông tin SELECT @stock_quantity =
                stock_quantity, @unit_price = list_price FROM products WHERE
                product_id = @product_id; IF @stock_quantity IS NULL BEGIN
                RAISERROR('Product ID %d không tồn tại', 16, 1, @product_id);
                RETURN; END; -- Kiểm tra tồn kho IF @stock_quantity < @quantity
                BEGIN RAISERROR('Không đủ tồn kho. Còn lại: %d, yêu cầu: %d',
                16, 1, @stock_quantity, @quantity); RETURN; END; -- Tạo đơn hàng
                INSERT INTO orders (customer_id, order_date, total_amount,
                status) VALUES (@customer_id, GETDATE(), @quantity *
                @unit_price, 'processing'); SET @order_id = SCOPE_IDENTITY(); --
                Thêm order items INSERT INTO order_items (order_id, product_id,
                quantity, unit_price) VALUES (@order_id, @product_id, @quantity,
                @unit_price); -- Cập nhật tồn kho UPDATE products SET
                stock_quantity = stock_quantity - @quantity, updated_date =
                GETDATE() WHERE product_id = @product_id; -- Commit transaction
                nếu thành công COMMIT TRANSACTION; PRINT 'Đơn hàng ' +
                CAST(@order_id AS VARCHAR) + ' đã được tạo thành công'; RETURN
                @order_id; END TRY BEGIN CATCH -- Kiểm tra và rollback
                transaction nếu đang mở IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION;
                -- Ghi log lỗi chi tiết DECLARE @error_message VARCHAR(2048) =
                'Lỗi tại procedure: ' + ISNULL(ERROR_PROCEDURE(),
                'sp_create_order') + ', Dòng: ' + CAST(ERROR_LINE() AS VARCHAR)
                + ', Thông báo: ' + ERROR_MESSAGE(); -- Ghi vào bảng error_log
                INSERT INTO error_log (error_message, error_number,
                error_severity, error_time, procedure_name) VALUES
                (@error_message, ERROR_NUMBER(), ERROR_SEVERITY(), GETDATE(),
                'sp_create_order'); -- Trả về lỗi cho ứng dụng
                RAISERROR(@error_message, 16, 1); RETURN -1; -- Return error
                code END CATCH; END; -- Sử dụng procedure EXEC sp_create_order
                @customer_id = 1, @product_id = 5, @quantity = 2;
              </div>
            </div>

            <h3>📊 TRY...CATCH lồng nhau (Nested)</h3>
            <div class="example">
              <h4>Xử lý lỗi đa cấp:</h4>
              <div class="code-block">
                CREATE PROCEDURE sp_complex_operation @operation_type
                VARCHAR(20) AS BEGIN BEGIN TRY PRINT 'Bắt đầu thao tác: ' +
                @operation_type; IF @operation_type = 'risky_operation' BEGIN --
                Thao tác có thể gây lỗi cấp 2 BEGIN TRY -- Giả lập thao tác phức
                tạp DECLARE @result INT = 100 / 0; -- Lỗi chia cho 0 PRINT 'Thao
                tác phức tạp thành công'; END TRY BEGIN CATCH PRINT 'Lỗi cấp 2:
                ' + ERROR_MESSAGE(); -- Thử phương án backup BEGIN TRY PRINT
                'Thử phương án backup...'; -- Giả lập backup operation thành
                công SET @result = 100 / 1; PRINT 'Phương án backup thành công';
                END TRY BEGIN CATCH PRINT 'Phương án backup cũng thất bại: ' +
                ERROR_MESSAGE(); -- Re-throw error để outer catch xử lý THROW;
                END CATCH; END CATCH; END ELSE BEGIN PRINT 'Thao tác bình thường
                hoàn thành'; END; END TRY BEGIN CATCH PRINT 'Lỗi cấp 1 (chính):
                ' + ERROR_MESSAGE(); PRINT 'Mã lỗi: ' + CAST(ERROR_NUMBER() AS
                VARCHAR); -- Cleanup operations PRINT 'Thực hiện cleanup...'; --
                Log vào hệ thống INSERT INTO error_log (error_message,
                error_time, procedure_name) VALUES ('Complex operation failed: '
                + ERROR_MESSAGE(), GETDATE(), 'sp_complex_operation'); END
                CATCH; END; -- Test các trường hợp EXEC sp_complex_operation
                @operation_type = 'normal'; EXEC sp_complex_operation
                @operation_type = 'risky_operation';
              </div>
            </div>

            <h3>🚨 RAISERROR và THROW</h3>

            <h4>📢 RAISERROR</h4>
            <div class="example">
              <p>
                Tạo và ném một lỗi tùy chỉnh với thông báo và mức độ nghiêm
                trọng cụ thể.
              </p>
              <div class="code-block">
                -- Cú pháp RAISERROR RAISERROR('message', severity, state,
                [arguments]); -- Ví dụ sử dụng RAISERROR CREATE PROCEDURE
                sp_validate_age @age INT AS BEGIN IF @age < 0 BEGIN
                RAISERROR('Tuổi không thể âm: %d', 16, 1, @age); RETURN; END; IF
                @age > 150 BEGIN RAISERROR('Tuổi không hợp lệ: %d (quá cao)',
                16, 2, @age); RETURN; END; IF @age < 18 BEGIN -- Warning level
                (severity 10) RAISERROR('Cảnh báo: Tuổi dưới 18: %d', 10, 1,
                @age); END; PRINT 'Tuổi hợp lệ: ' + CAST(@age AS VARCHAR); END;
                -- Test RAISERROR BEGIN TRY EXEC sp_validate_age @age = -5; END
                TRY BEGIN CATCH PRINT 'Caught error: ' + ERROR_MESSAGE(); END
                CATCH;
              </div>
            </div>

            <h4>🎯 THROW (SQL Server 2012+)</h4>
            <div class="example">
              <p>
                THROW là cách hiện đại hơn để ném lỗi, đơn giản và mạnh mẽ hơn
                RAISERROR.
              </p>
              <div class="code-block">
                -- Cú pháp THROW THROW error_number, message, state; -- Hoặc
                re-throw lỗi hiện tại THROW; -- Ví dụ sử dụng THROW CREATE
                PROCEDURE sp_transfer_money @from_account INT, @to_account INT,
                @amount DECIMAL(15,2) AS BEGIN BEGIN TRY BEGIN TRANSACTION; --
                Validate amount IF @amount <= 0 THROW 50001, 'Số tiền chuyển
                phải lớn hơn 0', 1; -- Check from account exists and has
                sufficient balance DECLARE @balance DECIMAL(15,2); SELECT
                @balance = balance FROM accounts WHERE account_id =
                @from_account; IF @balance IS NULL THROW 50002, 'Tài khoản nguồn
                không tồn tại', 1; IF @balance < @amount THROW 50003, 'Số dư
                không đủ để chuyển', 1; -- Check to account exists IF NOT EXISTS
                (SELECT 1 FROM accounts WHERE account_id = @to_account) THROW
                50004, 'Tài khoản đích không tồn tại', 1; -- Perform transfer
                UPDATE accounts SET balance = balance - @amount WHERE account_id
                = @from_account; UPDATE accounts SET balance = balance + @amount
                WHERE account_id = @to_account; -- Log transaction INSERT INTO
                transaction_log (from_account, to_account, amount,
                transaction_time) VALUES (@from_account, @to_account, @amount,
                GETDATE()); COMMIT TRANSACTION; PRINT 'Chuyển tiền thành công: '
                + FORMAT(@amount, 'N0') + ' VND'; END TRY BEGIN CATCH IF
                @@TRANCOUNT > 0 ROLLBACK TRANSACTION; -- Re-throw để preserve
                original error THROW; END CATCH; END; -- Test THROW BEGIN TRY
                EXEC sp_transfer_money @from_account = 1, @to_account = 2,
                @amount = -100; END TRY BEGIN CATCH PRINT 'Error ' +
                CAST(ERROR_NUMBER() AS VARCHAR) + ': ' + ERROR_MESSAGE(); END
                CATCH;
              </div>
            </div>

            <h3>📝 Logging và Monitoring Errors</h3>
            <div class="example">
              <h4>Hệ thống log lỗi hoàn chỉnh:</h4>
              <div class="code-block">
                -- Tạo bảng error log CREATE TABLE error_log ( log_id INT
                IDENTITY(1,1) PRIMARY KEY, error_number INT, error_message
                NVARCHAR(4000), error_severity INT, error_state INT, error_line
                INT, error_procedure NVARCHAR(128), error_time DATETIME2 DEFAULT
                GETDATE(), user_name NVARCHAR(128) DEFAULT SUSER_NAME(),
                host_name NVARCHAR(128) DEFAULT HOST_NAME(), application_name
                NVARCHAR(128) DEFAULT APP_NAME() ); -- Stored procedure để log
                lỗi CREATE PROCEDURE sp_log_error @additional_info
                NVARCHAR(1000) = NULL AS BEGIN INSERT INTO error_log (
                error_number, error_message, error_severity, error_state,
                error_line, error_procedure, additional_info ) VALUES (
                ERROR_NUMBER(), ERROR_MESSAGE(), ERROR_SEVERITY(),
                ERROR_STATE(), ERROR_LINE(), ERROR_PROCEDURE(), @additional_info
                ); END; -- Sử dụng trong procedure khác CREATE PROCEDURE
                sp_risky_operation @param1 INT, @param2 VARCHAR(50) AS BEGIN
                BEGIN TRY -- Thao tác có thể gây lỗi IF @param1 = 0 THROW 50001,
                'Parameter 1 cannot be zero', 1; DECLARE @result INT = 100 /
                @param1; PRINT 'Result: ' + CAST(@result AS VARCHAR); END TRY
                BEGIN CATCH -- Log lỗi với thông tin bổ sung EXEC sp_log_error
                @additional_info = 'Parameters: @param1=' + CAST(@param1 AS
                VARCHAR) + ', @param2=' + ISNULL(@param2, 'NULL'); -- Re-throw
                để caller biết có lỗi THROW; END CATCH; END; -- Query để xem
                error logs SELECT log_id, error_number, error_message,
                error_procedure, error_time, user_name, additional_info FROM
                error_log ORDER BY error_time DESC;
              </div>
            </div>

            <h3>⚡ Best Practices cho Exception Handling</h3>

            <div class="success-box">
              <h4>✅ Nên làm:</h4>
              <ul>
                <li>
                  <b>Luôn sử dụng TRY...CATCH:</b> Cho tất cả procedures quan
                  trọng
                </li>
                <li>
                  <b>Log lỗi chi tiết:</b> Ghi lại đầy đủ thông tin để debug
                </li>
                <li>
                  <b>Rollback transactions:</b> Khi có lỗi trong transaction
                </li>
                <li>
                  <b>Validate inputs:</b> Kiểm tra tham số trước khi xử lý
                </li>
                <li>
                  <b>Use meaningful error messages:</b> Thông báo lỗi dễ hiểu
                </li>
                <li>
                  <b>Set appropriate severity levels:</b> Phân biệt warning và
                  error
                </li>
                <li>
                  <b>Clean up resources:</b> Đóng cursors, deallocate memory
                </li>
              </ul>
            </div>

            <div class="info-box">
              <h4>❌ Tránh:</h4>
              <ul>
                <li><b>Ignore errors:</b> Luôn xử lý lỗi, không bỏ qua</li>
                <li>
                  <b>Generic error messages:</b> Thông báo lỗi quá chung chung
                </li>
                <li>
                  <b>Catching và re-throwing không cần thiết:</b> Làm mất
                  performance
                </li>
                <li><b>Hardcode error numbers:</b> Nên dùng constants</li>
                <li>
                  <b>Expose sensitive information:</b> Không để lộ thông tin
                  nhạy cảm trong error
                </li>
                <li>
                  <b>Multiple nested TRY...CATCH:</b> Gây khó đọc và debug
                </li>
              </ul>
            </div>

            <h3>🔄 So sánh RAISERROR vs THROW</h3>
            <table>
              <thead>
                <tr>
                  <th>Đặc điểm</th>
                  <th>RAISERROR</th>
                  <th>THROW</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>SQL Server version</b></td>
                  <td>Tất cả versions</td>
                  <td>2012+</td>
                </tr>
                <tr>
                  <td><b>Cú pháp</b></td>
                  <td>Phức tạp hơn</td>
                  <td>Đơn giản hơn</td>
                </tr>
                <tr>
                  <td><b>Error number range</b></td>
                  <td>50001-2147483647</td>
                  <td>50000-2147483647</td>
                </tr>
                <tr>
                  <td><b>Severity control</b></td>
                  <td>Có thể điều chỉnh</td>
                  <td>Luôn là 16</td>
                </tr>
                <tr>
                  <td><b>Re-throw capability</b></td>
                  <td>Không</td>
                  <td>Có (THROW;)</td>
                </tr>
                <tr>
                  <td><b>String formatting</b></td>
                  <td>Có (%d, %s)</td>
                  <td>Không</td>
                </tr>
                <tr>
                  <td><b>Khuyến nghị</b></td>
                  <td>Legacy code</td>
                  <td>New development</td>
                </tr>
              </tbody>
            </table>

            <div class="highlight-box">
              <h4>🎯 Kết luận:</h4>
              <p>
                <b>Exception Handling</b> là kỹ năng quan trọng để tạo ra
                <b>ứng dụng database ổn định và tin cậy</b>:
              </p>
              <ul>
                <li>
                  <b>TRY...CATCH:</b> Cơ chế chính để xử lý lỗi trong SQL Server
                </li>
                <li><b>Transaction safety:</b> Luôn rollback khi có lỗi</li>
                <li><b>Error logging:</b> Ghi lại lỗi để phân tích và debug</li>
                <li>
                  <b>User-friendly messages:</b> Thông báo lỗi dễ hiểu cho người
                  dùng
                </li>
                <li>
                  <b>Graceful degradation:</b> Ứng dụng không bị crash khi có
                  lỗi
                </li>
              </ul>
            </div>
          </section>

          <!-- 25 -->
          <section class="section" id="transaction">
            <h2>25. Transaction</h2>

            <div class="info-box">
              <h4>💰 Transaction là gì?</h4>
              <p>
                <b>Transaction (Giao dịch)</b> là một đơn vị logic của công việc
                được thực hiện trên cơ sở dữ liệu. Nó bao gồm một hoặc nhiều câu
                lệnh SQL được thực thi như một <b>khối duy nhất</b>.
              </p>
              <p>
                Điều quan trọng là một giao dịch phải thỏa mãn bốn thuộc tính
                <b>ACID</b>:
              </p>
            </div>

            <h3>🔬 Thuộc tính ACID</h3>
            <div class="highlight-box">
              <h4>💎 A.C.I.D Properties:</h4>
              <ul>
                <li><b>A</b>tomicity (Tính nguyên tố)</li>
                <li><b>C</b>onsistency (Tính nhất quán)</li>
                <li><b>I</b>solation (Tính cô lập)</li>
                <li><b>D</b>urability (Tính bền vững)</li>
              </ul>
            </div>

            <div class="example">
              <h4>🔐 Atomicity (Tính nguyên tố):</h4>
              <p>
                Toàn bộ giao dịch phải được thực hiện thành công, hoặc không có
                phần nào được thực hiện. Nếu có lỗi xảy ra ở bất kỳ đâu trong
                giao dịch, mọi thay đổi sẽ bị hủy bỏ.
              </p>
              <div class="code-block">
                <span class="comment"></span>-- Ví dụ: Chuyển tiền giữa 2 tài khoản</span>
                <span class="keyword">BEGIN TRANSACTION</span>;
                
                <span class="keyword">UPDATE</span> <span class="table">accounts</span> 
                <span class="keyword">SET</span> <span class="column">balance</span> <span class="operator">=</span> <span class="column">balance</span> <span class="operator">-</span> <span class="number">1000000</span> 
                <span class="keyword">WHERE</span> <span class="column">account_id</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- Trừ tiền tài khoản A</span>
                
                <span class="keyword">UPDATE</span> <span class="table">accounts</span> 
                <span class="keyword">SET</span> <span class="column">balance</span> <span class="operator">=</span> <span class="column">balance</span> <span class="operator">+</span> <span class="number">1000000</span> 
                <span class="keyword">WHERE</span> <span class="column">account_id</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">-- Cộng tiền tài khoản B</span>
                
                <span class="comment">-- Nếu bất kỳ lệnh nào thất bại, cả 2 lệnh đều bị ROLLBACK</span>
                <span class="keyword">COMMIT</span>;
              </div>
            </div>

            <div class="example">
              <h4>✅ Consistency (Tính nhất quán):</h4>
              <p>
                Giao dịch phải đưa cơ sở dữ liệu từ một trạng thái nhất quán này
                sang một trạng thái nhất quán khác.
              </p>
              <div class="code-block">
                <span class="comment">-- Ví dụ: Tổng tiền trong tất cả tài khoản phải không đổi sau khi chuyển tiền</span>
                <span class="comment">-- Trước giao dịch: Account1(5M) + Account2(3M) = 8M</span>
                <span class="keyword">BEGIN TRANSACTION</span>;
                
                <span class="keyword">UPDATE</span> <span class="table">accounts</span> 
                <span class="keyword">SET</span> <span class="column">balance</span> <span class="operator">=</span> <span class="column">balance</span> <span class="operator">-</span> <span class="number">1000000</span> 
                <span class="keyword">WHERE</span> <span class="column">account_id</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- Account1: 4M</span>
                
                <span class="keyword">UPDATE</span> <span class="table">accounts</span> 
                <span class="keyword">SET</span> <span class="column">balance</span> <span class="operator">=</span> <span class="column">balance</span> <span class="operator">+</span> <span class="number">1000000</span> 
                <span class="keyword">WHERE</span> <span class="column">account_id</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">-- Account2: 4M</span>
                
                <span class="keyword">COMMIT</span>;
                <span class="comment">-- Sau giao dịch: Account1(4M) + Account2(4M) = 8M (không đổi)</span>
              </div>
            </div>

            <div class="example">
              <h4>🔒 Isolation (Tính cô lập):</h4>
              <p>Các giao dịch đồng thời không được can thiệp vào nhau.</p>
              <div class="code-block">
                <span class="comment">-- Transaction 1 và Transaction 2 chạy đồng thời</span>
                <span class="comment">-- Transaction 1:</span>
                <span class="keyword">BEGIN TRANSACTION</span>;
                <span class="keyword">SELECT</span> <span class="column">balance</span> <span class="keyword">FROM</span> <span class="table">accounts</span> <span class="keyword">WHERE</span> <span class="column">account_id</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- Đọc balance</span>
                <span class="comment">-- ... làm việc gì đó ...</span>
                <span class="keyword">UPDATE</span> <span class="table">accounts</span> <span class="keyword">SET</span> <span class="column">balance</span> <span class="operator">=</span> <span class="column">balance</span> <span class="operator">-</span> <span class="number">500000</span> <span class="keyword">WHERE</span> <span class="column">account_id</span> <span class="operator">=</span> <span class="number">1</span>;
                <span class="keyword">COMMIT</span>;
                
                <span class="comment">-- Transaction 2 không thể thấy changes của Transaction 1 cho đến khi COMMIT</span>
              </div>
            </div>

            <div class="example">
              <h4>💾 Durability (Tính bền vững):</h4>
              <p>
                Các thay đổi đã được cam kết (commit) sẽ tồn tại vĩnh viễn, ngay
                cả khi hệ thống bị lỗi.
              </p>
              <div class="code-block">
                BEGIN TRANSACTION; INSERT INTO orders (customer_id,
                total_amount) VALUES (1, 2000000); COMMIT; -- Sau khi COMMIT, dữ
                liệu được lưu vĩnh viễn -- Ngay cả khi server restart, order này
                vẫn tồn tại
              </div>
            </div>

            <h3>🎛️ Các lệnh Transaction cơ bản</h3>

            <div class="success-box">
              <h4>📋 Các lệnh chính:</h4>
              <ul>
                <li>
                  <b>BEGIN TRANSACTION (BEGIN TRAN):</b> Bắt đầu một giao dịch
                  mới
                </li>
                <li>
                  <b>COMMIT TRANSACTION (COMMIT):</b> Lưu vĩnh viễn tất cả các
                  thay đổi
                </li>
                <li>
                  <b>ROLLBACK TRANSACTION (ROLLBACK):</b> Hủy bỏ tất cả các thay
                  đổi
                </li>
                <li>
                  <b>SAVE TRANSACTION:</b> Tạo savepoint trong transaction
                </li>
              </ul>
            </div>

            <div class="example">
              <h4>Cú pháp cơ bản:</h4>
              <div class="code-block">
                -- Cú pháp đầy đủ BEGIN TRANSACTION [transaction_name]; -- Các
                câu lệnh SQL IF (condition_success) COMMIT TRANSACTION
                [transaction_name]; ELSE ROLLBACK TRANSACTION
                [transaction_name]; -- Cú pháp ngắn gọn BEGIN TRAN; -- SQL
                statements COMMIT; -- hoặc ROLLBACK;
              </div>
            </div>

            <h3>💡 Ví dụ thực tế</h3>

            <h4>📦 Ví dụ 1: Cập nhật tồn kho sản phẩm</h4>
            <div class="example">
              <p>
                Giả sử bạn cần cập nhật số lượng tồn kho của một sản phẩm. Đây
                là một thao tác rất quan trọng và cần được thực hiện trong một
                giao dịch để đảm bảo tính toàn vẹn của dữ liệu.
              </p>
              <div class="code-block">
                -- Phiên bản cơ bản (sử dụng @@ERROR - legacy) BEGIN
                TRANSACTION; UPDATE products SET stock_quantity = stock_quantity
                - 1 WHERE product_id = 1; IF @@ERROR <> 0 ROLLBACK; ELSE COMMIT;
              </div>

              <p><b>Giải thích:</b></p>
              <ul>
                <li><b>BEGIN TRANSACTION:</b> Bắt đầu giao dịch mới</li>
                <li><b>UPDATE:</b> Giảm số lượng tồn kho đi 1</li>
                <li>
                  <b>@@ERROR:</b> Biến hệ thống lưu mã lỗi của câu lệnh cuối
                  cùng
                </li>
                <li><b>ROLLBACK:</b> Hủy thay đổi nếu có lỗi</li>
                <li><b>COMMIT:</b> Lưu thay đổi nếu thành công</li>
              </ul>
            </div>

            <h4>🛒 Ví dụ 2: Xử lý đơn hàng (Modern approach)</h4>
            <div class="example">
              <div class="code-block">
                -- Phiên bản hiện đại với TRY...CATCH BEGIN TRY BEGIN
                TRANSACTION; DECLARE @product_id INT = 1; DECLARE @quantity INT
                = 2; DECLARE @customer_id INT = 100; DECLARE @current_stock INT;
                -- Kiểm tra tồn kho hiện tại SELECT @current_stock =
                stock_quantity FROM products WHERE product_id = @product_id; --
                Validate có đủ tồn kho không IF @current_stock < @quantity BEGIN
                RAISERROR('Không đủ tồn kho. Còn lại: %d, yêu cầu: %d', 16, 1,
                @current_stock, @quantity); RETURN; END; -- Tạo đơn hàng INSERT
                INTO orders (customer_id, order_date, status, total_amount)
                VALUES (@customer_id, GETDATE(), 'processing', 0); DECLARE
                @order_id INT = SCOPE_IDENTITY(); -- Thêm order items INSERT
                INTO order_items (order_id, product_id, quantity, unit_price)
                SELECT @order_id, @product_id, @quantity, list_price FROM
                products WHERE product_id = @product_id; -- Cập nhật tồn kho
                UPDATE products SET stock_quantity = stock_quantity - @quantity,
                updated_date = GETDATE() WHERE product_id = @product_id; -- Cập
                nhật tổng tiền đơn hàng UPDATE orders SET total_amount = (
                SELECT SUM(quantity * unit_price) FROM order_items WHERE
                order_id = @order_id ) WHERE order_id = @order_id; COMMIT
                TRANSACTION; PRINT 'Đơn hàng ' + CAST(@order_id AS VARCHAR) + '
                đã được tạo thành công'; END TRY BEGIN CATCH IF @@TRANCOUNT > 0
                ROLLBACK TRANSACTION; PRINT 'Lỗi: ' + ERROR_MESSAGE(); THROW;
                END CATCH;
              </div>
            </div>

            <h4>💳 Ví dụ 3: Chuyển tiền giữa tài khoản</h4>
            <div class="example">
              <div class="code-block">
                CREATE PROCEDURE sp_transfer_money @from_account_id INT,
                @to_account_id INT, @amount DECIMAL(15,2) AS BEGIN SET NOCOUNT
                ON; BEGIN TRY BEGIN TRANSACTION; DECLARE @from_balance
                DECIMAL(15,2); DECLARE @to_balance DECIMAL(15,2); -- Lock và lấy
                thông tin tài khoản (tránh race condition) SELECT @from_balance
                = balance FROM accounts WITH (UPDLOCK) WHERE account_id =
                @from_account_id; SELECT @to_balance = balance FROM accounts
                WITH (UPDLOCK) WHERE account_id = @to_account_id; -- Validate
                accounts exist IF @from_balance IS NULL BEGIN RAISERROR('Tài
                khoản nguồn không tồn tại: %d', 16, 1, @from_account_id);
                RETURN; END; IF @to_balance IS NULL BEGIN RAISERROR('Tài khoản
                đích không tồn tại: %d', 16, 1, @to_account_id); RETURN; END; --
                Validate amount IF @amount <= 0 BEGIN RAISERROR('Số tiền chuyển
                phải lớn hơn 0', 16, 1); RETURN; END; -- Validate sufficient
                balance IF @from_balance < @amount BEGIN RAISERROR('Số dư không
                đủ. Có: %s, cần: %s', 16, 1, FORMAT(@from_balance, 'N0'),
                FORMAT(@amount, 'N0')); RETURN; END; -- Thực hiện chuyển tiền
                UPDATE accounts SET balance = balance - @amount, updated_date =
                GETDATE() WHERE account_id = @from_account_id; UPDATE accounts
                SET balance = balance + @amount, updated_date = GETDATE() WHERE
                account_id = @to_account_id; -- Ghi log giao dịch INSERT INTO
                transaction_history (from_account, to_account, amount,
                transaction_time, description) VALUES (@from_account_id,
                @to_account_id, @amount, GETDATE(), 'Money transfer'); COMMIT
                TRANSACTION; PRINT 'Chuyển tiền thành công: ' + FORMAT(@amount,
                'N0') + ' VND'; PRINT 'Từ tài khoản ' + CAST(@from_account_id AS
                VARCHAR) + ' đến tài khoản ' + CAST(@to_account_id AS VARCHAR);
                END TRY BEGIN CATCH IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION;
                DECLARE @error_msg VARCHAR(2000) = 'Lỗi chuyển tiền: ' +
                ERROR_MESSAGE() + ' (Line: ' + CAST(ERROR_LINE() AS VARCHAR) +
                ')'; PRINT @error_msg; THROW; END CATCH; END; -- Sử dụng EXEC
                sp_transfer_money @from_account_id = 1, @to_account_id = 2,
                @amount = 500000;
              </div>
            </div>

            <h3>🎚️ Transaction Isolation Levels</h3>
            <div class="highlight-box">
              <p>
                SQL Server hỗ trợ nhiều mức độ cô lập khác nhau để cân bằng giữa
                hiệu suất và tính nhất quán:
              </p>
            </div>

            <table>
              <thead>
                <tr>
                  <th>Isolation Level</th>
                  <th>Dirty Read</th>
                  <th>Non-Repeatable Read</th>
                  <th>Phantom Read</th>
                  <th>Performance</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>READ UNCOMMITTED</b></td>
                  <td>Có</td>
                  <td>Có</td>
                  <td>Có</td>
                  <td>Cao nhất</td>
                </tr>
                <tr>
                  <td><b>READ COMMITTED</b> (default)</td>
                  <td>Không</td>
                  <td>Có</td>
                  <td>Có</td>
                  <td>Cao</td>
                </tr>
                <tr>
                  <td><b>REPEATABLE READ</b></td>
                  <td>Không</td>
                  <td>Không</td>
                  <td>Có</td>
                  <td>Trung bình</td>
                </tr>
                <tr>
                  <td><b>SERIALIZABLE</b></td>
                  <td>Không</td>
                  <td>Không</td>
                  <td>Không</td>
                  <td>Thấp</td>
                </tr>
                <tr>
                  <td><b>SNAPSHOT</b></td>
                  <td>Không</td>
                  <td>Không</td>
                  <td>Không</td>
                  <td>Cao</td>
                </tr>
              </tbody>
            </table>

            <div class="example">
              <h4>Thiết lập Isolation Level:</h4>
              <div class="code-block">
                -- Thiết lập cho session hiện tại SET TRANSACTION ISOLATION
                LEVEL READ COMMITTED; -- Thiết lập cho một transaction cụ thể
                BEGIN TRANSACTION; SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
                SELECT * FROM accounts WHERE account_id = 1; -- Other operations
                COMMIT; -- Sử dụng table hints SELECT * FROM accounts WITH
                (NOLOCK) WHERE account_id = 1; -- READ UNCOMMITTED SELECT * FROM
                accounts WITH (READCOMMITTED) WHERE account_id = 1;
              </div>
            </div>

            <h3>💾 Savepoints trong Transaction</h3>
            <div class="example">
              <h4>Sử dụng Savepoints để rollback một phần:</h4>
              <div class="code-block">
                BEGIN TRANSACTION; -- Bước 1: Tạo đơn hàng INSERT INTO orders
                (customer_id, order_date) VALUES (1, GETDATE()); DECLARE
                @order_id INT = SCOPE_IDENTITY(); SAVE TRANSACTION SavePoint1;
                -- Tạo savepoint -- Bước 2: Thêm sản phẩm 1 INSERT INTO
                order_items (order_id, product_id, quantity, unit_price) VALUES
                (@order_id, 1, 2, 100000); SAVE TRANSACTION SavePoint2; -- Tạo
                savepoint thứ 2 -- Bước 3: Thêm sản phẩm 2 (giả sử có lỗi) BEGIN
                TRY INSERT INTO order_items (order_id, product_id, quantity,
                unit_price) VALUES (@order_id, 999, 1, 50000); -- Product 999
                không tồn tại END TRY BEGIN CATCH PRINT 'Lỗi thêm sản phẩm 2: '
                + ERROR_MESSAGE(); ROLLBACK TRANSACTION SavePoint2; -- Chỉ
                rollback từ SavePoint2 PRINT 'Đã rollback việc thêm sản phẩm 2,
                giữ lại sản phẩm 1'; END CATCH; -- Tiếp tục với các bước khác...
                UPDATE orders SET total_amount = ( SELECT SUM(quantity *
                unit_price) FROM order_items WHERE order_id = @order_id ) WHERE
                order_id = @order_id; COMMIT TRANSACTION; -- Commit toàn bộ (trừ
                phần đã rollback)
              </div>
            </div>

            <h3>🔍 Monitoring Transactions</h3>
            <div class="example">
              <h4>Kiểm tra trạng thái Transaction:</h4>
              <div class="code-block">
                -- Kiểm tra có transaction đang mở không SELECT @@TRANCOUNT AS
                'Open Transactions'; -- Xem thông tin các transactions đang chạy
                SELECT session_id, transaction_id, name, transaction_begin_time,
                transaction_type, transaction_state FROM
                sys.dm_tran_session_transactions st INNER JOIN
                sys.dm_tran_active_transactions at ON st.transaction_id =
                at.transaction_id; -- Xem locks đang được hold SELECT
                resource_type, resource_database_id,
                resource_associated_entity_id, request_mode, request_status FROM
                sys.dm_tran_locks WHERE request_session_id = @@SPID;
              </div>
            </div>

            <h3>⚡ Best Practices cho Transactions</h3>

            <div class="success-box">
              <h4>✅ Nên làm:</h4>
              <ul>
                <li>
                  <b>Keep transactions short:</b> Tối thiểu hóa thời gian
                  transaction
                </li>
                <li><b>Use TRY...CATCH:</b> Luôn có error handling</li>
                <li><b>Check @@TRANCOUNT:</b> Trước khi ROLLBACK</li>
                <li>
                  <b>Use appropriate isolation level:</b> Cân bằng performance
                  và consistency
                </li>
                <li><b>Index appropriately:</b> Giảm lock time</li>
                <li><b>Order operations:</b> Tránh deadlocks</li>
                <li>
                  <b>Use UPDLOCK hints:</b> Khi cần prevent concurrent
                  modifications
                </li>
              </ul>
            </div>

            <div class="info-box">
              <h4>❌ Tránh:</h4>
              <ul>
                <li>
                  <b>Long-running transactions:</b> Gây blocking và deadlocks
                </li>
                <li>
                  <b>User interaction trong transaction:</b> KHÔNG đợi user
                  input
                </li>
                <li><b>Quên COMMIT/ROLLBACK:</b> Gây resource leaks</li>
                <li>
                  <b>Nested transactions phức tạp:</b> Khó control và debug
                </li>
                <li>
                  <b>SELECT trong transaction không cần thiết:</b> Giữ locks lâu
                  hơn
                </li>
                <li>
                  <b>Inconsistent error handling:</b> Có thể gây data corruption
                </li>
              </ul>
            </div>

            <h3>🔄 Deadlock Prevention</h3>
            <div class="example">
              <h4>Strategies để tránh Deadlocks:</h4>
              <div class="code-block">
                -- 1. Truy cập tables theo thứ tự nhất quán -- Transaction A và
                B đều access theo thứ tự: orders -> customers -> products -- 2.
                Sử dụng timeout SET LOCK_TIMEOUT 5000; -- 5 seconds timeout --
                3. Sử dụng appropriate isolation level SET TRANSACTION ISOLATION
                LEVEL READ COMMITTED; -- 4. Ví dụ procedure an toàn CREATE
                PROCEDURE sp_safe_order_update @order_id INT, @customer_id INT
                AS BEGIN SET NOCOUNT ON; BEGIN TRY BEGIN TRANSACTION; -- Luôn
                access theo thứ tự ID tăng dần để tránh deadlock DECLARE
                @table_order TABLE (table_name VARCHAR(50), id INT); INSERT INTO
                @table_order VALUES ('customers', @customer_id), ('orders',
                @order_id); -- Process theo thứ tự DECLARE @first_table
                VARCHAR(50), @first_id INT; DECLARE @second_table VARCHAR(50),
                @second_id INT; SELECT TOP 1 @first_table = table_name,
                @first_id = id FROM @table_order ORDER BY id; SELECT TOP 1
                @second_table = table_name, @second_id = id FROM @table_order
                WHERE id > @first_id ORDER BY id; -- Lock theo thứ tự để tránh
                deadlock IF @first_table = 'customers' SELECT * FROM customers
                WITH (UPDLOCK) WHERE customer_id = @first_id; IF @second_table =
                'orders' SELECT * FROM orders WITH (UPDLOCK) WHERE order_id =
                @second_id; -- Thực hiện business logic UPDATE orders SET status
                = 'confirmed' WHERE order_id = @order_id; COMMIT TRANSACTION;
                END TRY BEGIN CATCH IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION;
                THROW; END CATCH; END;
              </div>
            </div>

            <div class="highlight-box">
              <h4>🎯 Kết luận:</h4>
              <p>
                <b>Transactions</b> là nền tảng của
                <b>tính toàn vẹn dữ liệu</b> trong database:
              </p>
              <ul>
                <li>
                  <b>ACID Properties:</b> Đảm bảo reliability và consistency
                </li>
                <li><b>Error Handling:</b> TRY...CATCH để xử lý lỗi an toàn</li>
                <li>
                  <b>Isolation Levels:</b> Cân bằng performance và data
                  consistency
                </li>
                <li>
                  <b>Best Practices:</b> Keep short, handle errors, prevent
                  deadlocks
                </li>
                <li>
                  <b>Monitoring:</b> Track transaction status và performance
                </li>
              </ul>
            </div>
          </section>

          <!-- 26 -->
          <section class="section" id="trigger">
            <h2>26. Trigger</h2>

            <div class="info-box">
              <h4>🎯 Trigger là gì?</h4>
              <p>
                <b>Trigger (bộ kích hoạt)</b> là một khối mã SQL đặc biệt, được
                lưu trữ trong cơ sở dữ liệu, và sẽ <b>tự động chạy</b> khi có
                một sự kiện nhất định xảy ra trên một bảng hoặc một view.
              </p>
              <p>
                Trigger hoạt động giống như một <b>"kẻ nghe lén"</b> luôn theo
                dõi các thay đổi trên bảng. Trigger được sử dụng để
                <b>duy trì tính toàn vẹn của dữ liệu</b> và tự động hóa các tác
                vụ liên quan.
              </p>
            </div>

            <h3>⚡ Sự kiện kích hoạt</h3>
            <div class="highlight-box">
              <p>Trigger có thể được kích hoạt bởi các sự kiện sau:</p>
              <ul>
                <li><b>INSERT:</b> Khi có hàng mới được thêm vào</li>
                <li><b>UPDATE:</b> Khi một hàng hiện có được cập nhật</li>
                <li><b>DELETE:</b> Khi một hàng bị xóa</li>
              </ul>
              <p>
                Các sự kiện này được gọi là
                <b>DML (Data Manipulation Language)</b>.
              </p>
            </div>

            <h3>📋 Các loại Trigger</h3>

            <h4>1️⃣ DML Trigger</h4>
            <div class="example">
              <p>
                Chạy khi có một sự kiện INSERT, UPDATE, hoặc DELETE xảy ra trên
                một bảng.
              </p>

              <h5>🕐 AFTER Triggers (Thực thi sau):</h5>
              <ul>
                <li>Chạy <b>sau khi</b> câu lệnh DML được thực thi</li>
                <li>Có thể rollback transaction nếu cần</li>
                <li>Phổ biến nhất và dễ sử dụng</li>
              </ul>

              <h5>🔄 INSTEAD OF Triggers (Thực thi thay thế):</h5>
              <ul>
                <li>Chạy <b>thay thế cho</b> câu lệnh DML</li>
                <li>Thường được sử dụng với Views</li>
                <li>Có thể customize hoàn toàn logic thực thi</li>
              </ul>
            </div>

            <h4>2️⃣ DDL Trigger</h4>
            <div class="example">
              <p>
                Chạy khi có một sự kiện DDL (Data Definition Language) xảy ra,
                chẳng hạn như CREATE, ALTER, hoặc DROP một đối tượng trong cơ sở
                dữ liệu.
              </p>
              <ul>
                <li>Audit schema changes</li>
                <li>Prevent unauthorized modifications</li>
                <li>Log database structure changes</li>
              </ul>
            </div>

            <h3>📝 Bảng ảo trong Trigger</h3>
            <table>
              <thead>
                <tr>
                  <th>Bảng ảo</th>
                  <th>Chứa dữ liệu</th>
                  <th>Có trong trigger</th>
                  <th>Mô tả</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><b>inserted</b></td>
                  <td>Dữ liệu mới</td>
                  <td>INSERT, UPDATE</td>
                  <td>Hàng vừa được chèn hoặc giá trị mới sau update</td>
                </tr>
                <tr>
                  <td><b>deleted</b></td>
                  <td>Dữ liệu cũ</td>
                  <td>DELETE, UPDATE</td>
                  <td>Hàng vừa bị xóa hoặc giá trị cũ trước update</td>
                </tr>
              </tbody>
            </table>

            <h3>💡 Ví dụ cơ bản</h3>

            <h4>📦 Ví dụ 1: Cập nhật tồn kho tự động</h4>
            <div class="example">
              <p>
                Một trường hợp sử dụng phổ biến của trigger là để cập nhật tự
                động số lượng tồn kho khi có một đơn hàng mới được thêm vào:
              </p>
              <div class="code-block">
                CREATE TRIGGER trg_update_stock ON order_items -- Trigger trên
                bảng order_items AFTER INSERT -- Kích hoạt sau khi có lệnh
                INSERT AS BEGIN SET NOCOUNT ON; -- Không trả về số lượng rows
                affected -- Cập nhật tồn kho cho tất cả sản phẩm vừa được order
                UPDATE products SET stock_quantity = stock_quantity -
                i.quantity, updated_date = GETDATE() FROM products p INNER JOIN
                inserted i ON p.product_id = i.product_id; -- Log thông tin
                PRINT 'Đã cập nhật tồn kho cho ' + CAST(@@ROWCOUNT AS VARCHAR) +
                ' sản phẩm'; END;
              </div>

              <p><b>Giải thích:</b></p>
              <ul>
                <li>
                  <b>CREATE TRIGGER trg_update_stock:</b> Tạo trigger tên
                  trg_update_stock
                </li>
                <li><b>ON order_items:</b> Gắn trigger vào bảng order_items</li>
                <li>
                  <b>AFTER INSERT:</b> Trigger chạy sau khi INSERT hoàn thành
                </li>
                <li>
                  <b>inserted:</b> Bảng ảo chứa các hàng vừa được chèn vào
                </li>
                <li>
                  <b>JOIN với inserted:</b> Cập nhật stock cho tất cả sản phẩm
                  trong đơn hàng
                </li>
              </ul>
            </div>

            <h4>🔒 Ví dụ 2: Ngăn xóa khách hàng có đơn hàng</h4>
            <div class="example">
              <p>
                Trigger có khả năng hủy bỏ các thao tác đã thực hiện bằng cách
                sử dụng lệnh ROLLBACK:
              </p>
              <div class="code-block">
                CREATE TRIGGER trg_prevent_customer_delete ON customers AFTER
                DELETE AS BEGIN SET NOCOUNT ON; -- Kiểm tra xem khách hàng vừa
                xóa có đơn hàng không IF EXISTS ( SELECT 1 FROM orders o INNER
                JOIN deleted d ON o.customer_id = d.customer_id ) BEGIN -- In
                thông báo lỗi PRINT 'Không thể xóa khách hàng đã có đơn hàng.';
                -- Rollback transaction để hủy việc xóa ROLLBACK TRANSACTION; --
                Hoặc có thể RAISERROR để báo lỗi chi tiết hơn RAISERROR('Khách
                hàng có đơn hàng liên quan, không thể xóa', 16, 1); END ELSE
                BEGIN PRINT 'Đã xóa khách hàng thành công'; END; END;
              </div>

              <p><b>Giải thích:</b></p>
              <ul>
                <li><b>deleted:</b> Bảng ảo chứa các hàng vừa bị xóa</li>
                <li>
                  <b>EXISTS check:</b> Kiểm tra xem có đơn hàng liên quan không
                </li>
                <li><b>ROLLBACK:</b> Hủy bỏ thao tác xóa nếu không hợp lệ</li>
                <li><b>RAISERROR:</b> Báo lỗi chi tiết cho ứng dụng</li>
              </ul>
            </div>

            <h3>🔄 Trigger cho UPDATE</h3>
            <div class="example">
              <h4>Audit log cho thay đổi giá sản phẩm:</h4>
              <div class="code-block">
                -- Tạo bảng audit log CREATE TABLE product_price_audit (
                audit_id INT IDENTITY(1,1) PRIMARY KEY, product_id INT,
                old_price DECIMAL(10,2), new_price DECIMAL(10,2), changed_by
                VARCHAR(100), changed_date DATETIME2 DEFAULT GETDATE() ); --
                Trigger audit cho việc thay đổi giá CREATE TRIGGER
                trg_audit_price_change ON products AFTER UPDATE AS BEGIN SET
                NOCOUNT ON; -- Chỉ log khi có thay đổi về giá IF
                UPDATE(list_price) BEGIN INSERT INTO product_price_audit (
                product_id, old_price, new_price, changed_by ) SELECT
                i.product_id, d.list_price AS old_price, i.list_price AS
                new_price, SUSER_NAME() AS changed_by FROM inserted i INNER JOIN
                deleted d ON i.product_id = d.product_id WHERE i.list_price !=
                d.list_price; -- Chỉ log khi giá thực sự thay đổi PRINT 'Đã ghi
                log thay đổi giá cho ' + CAST(@@ROWCOUNT AS VARCHAR) + ' sản
                phẩm'; END; END;
              </div>
            </div>

            <h3>🔀 INSTEAD OF Trigger</h3>
            <div class="example">
              <h4>Trigger cho View phức tạp:</h4>
              <div class="code-block">
                -- Tạo view kết hợp nhiều bảng CREATE VIEW vw_product_summary AS
                SELECT p.product_id, p.product_name, p.list_price,
                c.category_name, b.brand_name, p.stock_quantity FROM products p
                INNER JOIN categories c ON p.category_id = c.category_id INNER
                JOIN brands b ON p.brand_id = b.brand_id; -- Trigger INSTEAD OF
                cho phép INSERT vào view CREATE TRIGGER trg_insert_product_view
                ON vw_product_summary INSTEAD OF INSERT AS BEGIN SET NOCOUNT ON;
                DECLARE @category_id INT, @brand_id INT; -- Lấy category_id từ
                tên SELECT @category_id = category_id FROM categories WHERE
                category_name = (SELECT TOP 1 category_name FROM inserted); --
                Lấy brand_id từ tên SELECT @brand_id = brand_id FROM brands
                WHERE brand_name = (SELECT TOP 1 brand_name FROM inserted); --
                Validate IDs tồn tại IF @category_id IS NULL OR @brand_id IS
                NULL BEGIN RAISERROR('Category hoặc Brand không tồn tại', 16,
                1); RETURN; END; -- Insert vào bảng products thực tế INSERT INTO
                products (product_name, list_price, category_id, brand_id,
                stock_quantity) SELECT product_name, list_price, @category_id,
                @brand_id, stock_quantity FROM inserted; PRINT 'Đã thêm sản phẩm
                mới qua view'; END; -- Sử dụng view như bảng thông thường INSERT
                INTO vw_product_summary (product_name, list_price,
                category_name, brand_name, stock_quantity) VALUES ('iPhone 16',
                25000000, 'Electronics', 'Apple', 100);
              </div>
            </div>

            <h3>🏢 DDL Trigger</h3>
            <div class="example">
              <h4>Audit các thay đổi schema:</h4>
              <div class="code-block">
                -- Tạo bảng log cho DDL events CREATE TABLE ddl_audit_log (
                event_id INT IDENTITY(1,1) PRIMARY KEY, event_type VARCHAR(100),
                object_name VARCHAR(200), object_type VARCHAR(100), sql_command
                NVARCHAR(MAX), event_time DATETIME2 DEFAULT GETDATE(),
                login_name VARCHAR(100), server_name VARCHAR(100) ); -- DDL
                Trigger cho database level CREATE TRIGGER trg_ddl_audit ON
                DATABASE -- Áp dụng cho toàn database FOR CREATE_TABLE,
                ALTER_TABLE, DROP_TABLE, CREATE_PROCEDURE, ALTER_PROCEDURE,
                DROP_PROCEDURE AS BEGIN SET NOCOUNT ON; DECLARE @event_data XML
                = EVENTDATA(); INSERT INTO ddl_audit_log ( event_type,
                object_name, object_type, sql_command, login_name, server_name )
                VALUES ( @event_data.value('(/EVENT_INSTANCE/EventType)[1]',
                'VARCHAR(100)'),
                @event_data.value('(/EVENT_INSTANCE/ObjectName)[1]',
                'VARCHAR(200)'),
                @event_data.value('(/EVENT_INSTANCE/ObjectType)[1]',
                'VARCHAR(100)'),
                @event_data.value('(/EVENT_INSTANCE/TSQLCommand)[1]',
                'NVARCHAR(MAX)'),
                @event_data.value('(/EVENT_INSTANCE/LoginName)[1]',
                'VARCHAR(100)'),
                @event_data.value('(/EVENT_INSTANCE/ServerName)[1]',
                'VARCHAR(100)') ); END; -- Test DDL trigger CREATE TABLE
                test_table (id INT); -- Sẽ được log DROP TABLE test_table; --
                Cũng sẽ được log -- Xem audit log SELECT * FROM ddl_audit_log
                ORDER BY event_time DESC;
              </div>
            </div>

            <h3>🔧 Quản lý Triggers</h3>

            <div class="example">
              <h4>Xem thông tin Triggers:</h4>
              <div class="code-block">
                -- Liệt kê tất cả DML triggers SELECT t.name AS trigger_name,
                OBJECT_NAME(t.parent_id) AS table_name, t.type_desc,
                t.is_disabled, t.is_instead_of_trigger, m.definition FROM
                sys.triggers t LEFT JOIN sys.sql_modules m ON t.object_id =
                m.object_id WHERE t.parent_class = 1 -- DML triggers ORDER BY
                table_name, trigger_name; -- Xem DDL triggers SELECT name AS
                trigger_name, type_desc, parent_class_desc, is_disabled,
                create_date, modify_date FROM sys.triggers WHERE parent_class =
                0 -- DDL triggers ORDER BY name; -- Xem trigger events SELECT
                t.name AS trigger_name, te.type_name AS event_type FROM
                sys.triggers t INNER JOIN sys.trigger_events te ON t.object_id =
                te.object_id ORDER BY t.name, te.type_name;
              </div>
            </div>

            <div class="example">
              <h4>Enable/Disable và Drop Triggers:</h4>
              <div class="code-block">
                -- Disable trigger DISABLE TRIGGER trg_update_stock ON
                order_items; -- Enable trigger ENABLE TRIGGER trg_update_stock
                ON order_items; -- Disable tất cả triggers trên một bảng DISABLE
                TRIGGER ALL ON products; -- Enable tất cả triggers trên một bảng
                ENABLE TRIGGER ALL ON products; -- Sửa đổi trigger ALTER TRIGGER
                trg_update_stock ON order_items AFTER INSERT, UPDATE -- Thêm
                UPDATE event AS BEGIN SET NOCOUNT ON; -- Logic mới... IF EXISTS
                (SELECT 1 FROM inserted) BEGIN UPDATE products SET
                stock_quantity = stock_quantity - i.quantity, updated_date =
                GETDATE() FROM products p INNER JOIN inserted i ON p.product_id
                = i.product_id; END; END; -- Xóa trigger DROP TRIGGER IF EXISTS
                trg_update_stock; -- Xóa DDL trigger DROP TRIGGER trg_ddl_audit
                ON DATABASE;
              </div>
            </div>

            <h3>⚡ Performance và Best Practices</h3>

            <div class="success-box">
              <h4>✅ Nên làm:</h4>
              <ul>
                <li>
                  <b>SET NOCOUNT ON:</b> Tắt row count messages để tăng
                  performance
                </li>
                <li>
                  <b>Keep triggers lightweight:</b> Logic đơn giản và nhanh
                </li>
                <li>
                  <b>Handle multiple rows:</b> Trigger phải xử lý được nhiều
                  rows cùng lúc
                </li>
                <li>
                  <b>Use proper error handling:</b> TRY...CATCH cho triggers
                  phức tạp
                </li>
                <li><b>Test thoroughly:</b> Test với bulk operations</li>
                <li><b>Document trigger logic:</b> Comment rõ ràng mục đích</li>
                <li>
                  <b>Use specific events:</b> Chỉ trigger cho events cần thiết
                </li>
              </ul>
            </div>

            <div class="info-box">
              <h4>❌ Tránh:</h4>
              <ul>
                <li>
                  <b>Recursive triggers:</b> Trigger gọi trigger khác tạo vòng
                  lặp
                </li>
                <li>
                  <b>Heavy operations:</b> Complex queries, external calls
                </li>
                <li>
                  <b>User interaction:</b> PRINT, SELECT statements showing data
                  to user
                </li>
                <li><b>Assuming single row:</b> Luôn xử lý nhiều rows</li>
                <li>
                  <b>Trigger chains:</b> Quá nhiều triggers phụ thuộc nhau
                </li>
                <li>
                  <b>Business logic in triggers:</b> Nên để trong stored
                  procedures
                </li>
                <li>
                  <b>Modifying same table:</b> Có thể gây infinite recursion
                </li>
              </ul>
            </div>

            <h3>🎯 Ví dụ tổng hợp: Hệ thống Audit hoàn chỉnh</h3>
            <div class="example">
              <h4>Trigger audit universal cho mọi bảng:</h4>
              <div class="code-block">
                -- Bảng audit log chung CREATE TABLE audit_log ( audit_id BIGINT
                IDENTITY(1,1) PRIMARY KEY, table_name VARCHAR(100),
                operation_type VARCHAR(10), primary_key_value VARCHAR(100),
                old_values NVARCHAR(MAX), new_values NVARCHAR(MAX), changed_by
                VARCHAR(100), changed_date DATETIME2 DEFAULT GETDATE(),
                application_name VARCHAR(100) ); -- Function hỗ trợ convert row
                thành JSON string CREATE FUNCTION fn_row_to_json(@table_name
                VARCHAR(100), @row_data SQL_VARIANT) RETURNS NVARCHAR(MAX) AS
                BEGIN -- Simplified function - thực tế cần implement JSON
                serialization RETURN N'{"data": "serialized_row_data"}'; END; --
                Trigger template cho audit (áp dụng cho từng bảng cần audit)
                CREATE TRIGGER trg_audit_customers ON customers AFTER INSERT,
                UPDATE, DELETE AS BEGIN SET NOCOUNT ON; DECLARE @operation
                VARCHAR(10); DECLARE @table_name VARCHAR(100) = 'customers'; --
                Xác định loại operation IF EXISTS (SELECT 1 FROM inserted) AND
                EXISTS (SELECT 1 FROM deleted) SET @operation = 'UPDATE'; ELSE
                IF EXISTS (SELECT 1 FROM inserted) SET @operation = 'INSERT';
                ELSE SET @operation = 'DELETE'; -- Log cho INSERT IF @operation
                = 'INSERT' BEGIN INSERT INTO audit_log (table_name,
                operation_type, primary_key_value, new_values, changed_by,
                application_name) SELECT @table_name, @operation,
                CAST(customer_id AS VARCHAR), (SELECT * FROM inserted i WHERE
                i.customer_id = inserted.customer_id FOR JSON AUTO),
                SUSER_NAME(), APP_NAME() FROM inserted; END; -- Log cho DELETE
                IF @operation = 'DELETE' BEGIN INSERT INTO audit_log
                (table_name, operation_type, primary_key_value, old_values,
                changed_by, application_name) SELECT @table_name, @operation,
                CAST(customer_id AS VARCHAR), (SELECT * FROM deleted d WHERE
                d.customer_id = deleted.customer_id FOR JSON AUTO),
                SUSER_NAME(), APP_NAME() FROM deleted; END; -- Log cho UPDATE IF
                @operation = 'UPDATE' BEGIN INSERT INTO audit_log (table_name,
                operation_type, primary_key_value, old_values, new_values,
                changed_by, application_name) SELECT @table_name, @operation,
                CAST(i.customer_id AS VARCHAR), (SELECT * FROM deleted d WHERE
                d.customer_id = i.customer_id FOR JSON AUTO), (SELECT * FROM
                inserted ins WHERE ins.customer_id = i.customer_id FOR JSON
                AUTO), SUSER_NAME(), APP_NAME() FROM inserted i INNER JOIN
                deleted d ON i.customer_id = d.customer_id; END; END; --
                Procedure để generate audit trigger cho bất kỳ bảng nào CREATE
                PROCEDURE sp_create_audit_trigger @table_name VARCHAR(100),
                @primary_key_column VARCHAR(100) AS BEGIN DECLARE @sql
                NVARCHAR(MAX); SET @sql = N' CREATE TRIGGER trg_audit_' +
                @table_name + N' ON ' + @table_name + N' AFTER INSERT, UPDATE,
                DELETE AS BEGIN SET NOCOUNT ON; -- Implementation similar to
                above template -- Customized for specific table and primary key
                END;'; EXEC sp_executesql @sql; PRINT 'Created audit trigger for
                table: ' + @table_name; END;
              </div>
            </div>

            <div class="highlight-box">
              <h4>🎯 Kết luận:</h4>
              <p>
                <b>Triggers</b> là công cụ mạnh mẽ để
                <b>tự động hóa và duy trì tính toàn vẹn dữ liệu</b>:
              </p>
              <ul>
                <li><b>Automatic execution:</b> Chạy tự động khi có events</li>
                <li>
                  <b>Data integrity:</b> Enforce business rules và constraints
                </li>
                <li><b>Auditing:</b> Track changes và maintain history</li>
                <li><b>Complex logic:</b> Handle multi-table operations</li>
                <li>
                  <b>Performance consideration:</b> Must be lightweight và
                  efficient
                </li>
              </ul>
            </div>
          </section>

          <!-- 27 -->
          <section class="section" id="acid">
            <h2>27. ACID</h2>

            <div class="info-box">
              <h4>🏛️ ACID là gì?</h4>
              <p>
                <b>ACID</b> là một tập hợp các thuộc tính đảm bảo rằng các giao
                dịch trong cơ sở dữ liệu được xử lý một cách
                <b>đáng tin cậy</b>. Các thuộc tính này được thiết kế để đảm bảo
                <b>tính toàn vẹn của dữ liệu</b> trong các hoạt động trên cơ sở
                dữ liệu.
              </p>
              <p>
                ACID là viết tắt của: <b>A</b>tomicity, <b>C</b>onsistency,
                <b>I</b>solation, <b>D</b>urability
              </p>
            </div>

            <h3>💎 Bốn thuộc tính của ACID</h3>

            <h4>⚛️ 1. Atomicity (Tính nguyên tố)</h4>
            <div class="example">
              <div class="highlight-box">
                <p>
                  <b>Định nghĩa:</b> Thuộc tính này đảm bảo rằng một giao dịch
                  được coi là một
                  <b>đơn vị công việc duy nhất và không thể chia cắt</b>.
                </p>
                <p>
                  <b>Nguyên tắc:</b> Hoặc tất cả các câu lệnh trong giao dịch
                  đều được thực thi thành công, hoặc không có câu lệnh nào được
                  thực thi.
                </p>
              </div>

              <h5>🎯 Ví dụ thực tế - Chuyển tiền:</h5>
              <div class="code-block">
                -- Ví dụ vi phạm Atomicity (KHÔNG nên làm) UPDATE accounts SET
                balance = balance - 1000000 WHERE account_id = 1; -- Trừ tiền A
                -- Nếu lỗi xảy ra ở đây, chỉ có account 1 bị trừ tiền! UPDATE
                accounts SET balance = balance + 1000000 WHERE account_id = 2;
                -- Cộng tiền B -- Ví dụ tuân thủ Atomicity (ĐÚNG cách) BEGIN
                TRANSACTION; UPDATE accounts SET balance = balance - 1000000
                WHERE account_id = 1; UPDATE accounts SET balance = balance +
                1000000 WHERE account_id = 2; -- Nếu có lỗi bất kỳ, cả 2 lệnh
                đều bị ROLLBACK COMMIT TRANSACTION;
              </div>

              <div class="success-box">
                <h5>✅ Atomicity đảm bảo:</h5>
                <ul>
                  <li>
                    Nếu có lỗi xảy ra trong quá trình thực thi, toàn bộ giao
                    dịch sẽ bị hủy bỏ
                  </li>
                  <li>
                    Cơ sở dữ liệu sẽ quay trở lại trạng thái ban đầu trước khi
                    giao dịch bắt đầu
                  </li>
                  <li>
                    Không có trạng thái "nửa chừng" hoặc "không hoàn chỉnh"
                  </li>
                  <li>All-or-nothing principle: Tất cả hoặc không gì cả</li>
                </ul>
              </div>
            </div>

            <h4>⚖️ 2. Consistency (Tính nhất quán)</h4>
            <div class="example">
              <div class="highlight-box">
                <p>
                  <b>Định nghĩa:</b> Tính nhất quán đảm bảo rằng một giao dịch
                  sẽ đưa cơ sở dữ liệu từ một
                  <b>trạng thái hợp lệ (consistent)</b> này sang một
                  <b>trạng thái hợp lệ khác</b>.
                </p>
                <p>
                  <b>Nguyên tắc:</b> Các quy tắc toàn vẹn của cơ sở dữ liệu (như
                  ràng buộc, trigger) phải được tuân thủ sau khi giao dịch hoàn
                  thành.
                </p>
              </div>

              <h5>🎯 Ví dụ thực tế - Ràng buộc tổng tiền:</h5>
              <div class="code-block">
                -- Giả sử có constraint: Tổng tiền trong tất cả accounts >= 0 --
                Trước giao dịch: Account A (2M) + Account B (3M) = 5M total
                BEGIN TRANSACTION; -- Thử chuyển 3M từ A sang B (nhưng A chỉ có
                2M) UPDATE accounts SET balance = balance - 3000000 WHERE
                account_id = 1; -- A: -1M (Vi phạm constraint!) UPDATE accounts
                SET balance = balance + 3000000 WHERE account_id = 2; -- B: 6M
                -- Transaction sẽ bị ROLLBACK vì vi phạm constraint -- Database
                sẽ giữ nguyên trạng thái nhất quán ban đầu COMMIT TRANSACTION;
                -- Sẽ fail
              </div>

              <h5>🏗️ Các loại ràng buộc đảm bảo Consistency:</h5>
              <div class="code-block">
                -- 1. CHECK Constraints ALTER TABLE accounts ADD CONSTRAINT
                chk_positive_balance CHECK (balance >= 0); -- 2. FOREIGN KEY
                Constraints ALTER TABLE orders ADD CONSTRAINT fk_customer
                FOREIGN KEY (customer_id) REFERENCES customers(customer_id); --
                3. UNIQUE Constraints ALTER TABLE customers ADD CONSTRAINT
                uk_email UNIQUE (email); -- 4. Business Rules via Triggers
                CREATE TRIGGER trg_check_stock_consistency ON order_items AFTER
                INSERT AS BEGIN IF EXISTS ( SELECT 1 FROM products p INNER JOIN
                inserted i ON p.product_id = i.product_id WHERE p.stock_quantity
                < 0 ) BEGIN RAISERROR('Stock không thể âm', 16, 1); ROLLBACK
                TRANSACTION; END; END;
              </div>

              <div class="success-box">
                <h5>✅ Consistency đảm bảo:</h5>
                <ul>
                  <li>
                    Dữ liệu luôn tuân thủ các business rules và constraints
                  </li>
                  <li>
                    Không có dữ liệu "invalid" sau khi transaction hoàn thành
                  </li>
                  <li>Referential integrity được duy trì</li>
                  <li>Domain constraints và check constraints được enforce</li>
                </ul>
              </div>
            </div>

            <h4>🔒 3. Isolation (Tính cô lập)</h4>
            <div class="example">
              <div class="highlight-box">
                <p>
                  <b>Định nghĩa:</b> Thuộc tính này đảm bảo rằng các giao dịch
                  đồng thời <b>không can thiệp vào nhau</b>. Các thay đổi được
                  thực hiện bởi một giao dịch chưa hoàn thành sẽ không thể nhìn
                  thấy được bởi các giao dịch khác cho đến khi giao dịch đó được
                  cam kết (commit).
                </p>
                <p>
                  <b>Mục tiêu:</b> Ngăn chặn các vấn đề như đọc dữ liệu "bẩn"
                  (dirty reads) hoặc dữ liệu "lặp lại không nhất quán"
                  (non-repeatable reads).
                </p>
              </div>

              <h5>🎯 Ví dụ vấn đề khi thiếu Isolation:</h5>
              <div class="code-block">
                -- Scenario: 2 transactions chạy đồng thời -- Transaction 1
                (T1): BEGIN TRANSACTION; UPDATE accounts SET balance = balance +
                1000000 WHERE account_id = 1; -- Chưa COMMIT, nhưng T2 có thể
                đọc được giá trị này không? WAITFOR DELAY '00:00:10'; -- Delay
                10 giây ROLLBACK TRANSACTION; -- Cuối cùng ROLLBACK! --
                Transaction 2 (T2) - chạy đồng thời: BEGIN TRANSACTION; SELECT
                balance FROM accounts WHERE account_id = 1; -- Đọc được gì? --
                Nếu đọc được giá trị đã update của T1 -> DIRTY READ! -- Nếu T1
                rollback thì T2 đã đọc dữ liệu "phantom" COMMIT TRANSACTION;
              </div>

              <h5>🎚️ Isolation Levels trong SQL Server:</h5>
              <table>
                <thead>
                  <tr>
                    <th>Isolation Level</th>
                    <th>Dirty Read</th>
                    <th>Non-Repeatable Read</th>
                    <th>Phantom Read</th>
                    <th>Mô tả</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><b>READ UNCOMMITTED</b></td>
                    <td>❌ Có</td>
                    <td>❌ Có</td>
                    <td>❌ Có</td>
                    <td>Đọc được dữ liệu chưa commit</td>
                  </tr>
                  <tr>
                    <td><b>READ COMMITTED</b> (default)</td>
                    <td>✅ Không</td>
                    <td>❌ Có</td>
                    <td>❌ Có</td>
                    <td>Chỉ đọc dữ liệu đã commit</td>
                  </tr>
                  <tr>
                    <td><b>REPEATABLE READ</b></td>
                    <td>✅ Không</td>
                    <td>✅ Không</td>
                    <td>❌ Có</td>
                    <td>Đọc lặp lại cho kết quả giống nhau</td>
                  </tr>
                  <tr>
                    <td><b>SERIALIZABLE</b></td>
                    <td>✅ Không</td>
                    <td>✅ Không</td>
                    <td>✅ Không</td>
                    <td>Cô lập hoàn toàn, như chạy tuần tự</td>
                  </tr>
                </tbody>
              </table>

              <div class="code-block">
                -- Ví dụ thiết lập Isolation Level SET TRANSACTION ISOLATION
                LEVEL SERIALIZABLE; BEGIN TRANSACTION; SELECT * FROM accounts
                WHERE account_id = 1; -- Các transactions khác không thể modify
                account_id = 1 WAITFOR DELAY '00:00:05'; SELECT * FROM accounts
                WHERE account_id = 1; -- Kết quả giống lần đọc đầu COMMIT
                TRANSACTION;
              </div>

              <div class="success-box">
                <h5>✅ Isolation đảm bảo:</h5>
                <ul>
                  <li>Transactions không thấy incomplete changes của nhau</li>
                  <li>Đọc dữ liệu consistent trong suốt transaction</li>
                  <li>
                    Ngăn chặn dirty reads, non-repeatable reads, phantom reads
                  </li>
                  <li>
                    Transactions như thể chạy tuần tự (tùy isolation level)
                  </li>
                </ul>
              </div>
            </div>

            <h4>💾 4. Durability (Tính bền vững)</h4>
            <div class="example">
              <div class="highlight-box">
                <p>
                  <b>Định nghĩa:</b> Tính bền vững đảm bảo rằng khi một giao
                  dịch đã được cam kết (commit), các thay đổi của nó sẽ
                  <b>tồn tại vĩnh viễn</b> trong cơ sở dữ liệu, ngay cả trong
                  trường hợp hệ thống bị lỗi.
                </p>
                <p>
                  <b>Nguyên tắc:</b> Các thay đổi này được lưu trữ trong bộ nhớ
                  ổn định (như ổ đĩa) để đảm bảo không bị mất.
                </p>
              </div>

              <h5>🎯 Ví dụ thực tế - Đặt hàng online:</h5>
              <div class="code-block">
                -- Khách hàng đặt hàng và thanh toán thành công BEGIN
                TRANSACTION; INSERT INTO orders (customer_id, total_amount,
                status) VALUES (123, 2500000, 'paid'); INSERT INTO order_items
                (order_id, product_id, quantity, price) VALUES
                (SCOPE_IDENTITY(), 456, 2, 1250000); UPDATE products SET
                stock_quantity = stock_quantity - 2 WHERE product_id = 456;
                COMMIT TRANSACTION; -- ✅ Sau khi COMMIT thành công -- Ngay cả
                khi: -- - Server bị restart -- - Mất điện -- - Disk failure (nếu
                có backup/replication) -- - Application crash -- -- Đơn hàng vẫn
                tồn tại và không bị mất!
              </div>

              <h5>🛡️ Các cơ chế đảm bảo Durability:</h5>
              <div class="info-box">
                <h6>1. Transaction Log (WAL - Write-Ahead Logging):</h6>
                <ul>
                  <li>
                    Mọi thay đổi được ghi vào transaction log trước khi commit
                  </li>
                  <li>
                    Log được flush to disk trước khi transaction được coi là
                    committed
                  </li>
                  <li>
                    Recovery sử dụng log để replay transactions sau system
                    failure
                  </li>
                </ul>

                <h6>2. Checkpoint Process:</h6>
                <ul>
                  <li>Định kỳ flush dirty pages từ memory xuống disk</li>
                  <li>Đảm bảo committed data được persisted</li>
                  <li>Giảm thời gian recovery khi restart</li>
                </ul>

                <h6>3. Backup và Recovery:</h6>
                <ul>
                  <li>
                    Full backups, differential backups, transaction log backups
                  </li>
                  <li>Point-in-time recovery capabilities</li>
                  <li>High Availability solutions (Always On, Mirroring)</li>
                </ul>
              </div>

              <div class="code-block">
                -- Kiểm tra transaction log và checkpoint -- Xem thông tin
                transaction log SELECT name AS database_name,
                log_reuse_wait_desc, recovery_model_desc FROM sys.databases; --
                Force checkpoint (admin only) CHECKPOINT; -- Backup transaction
                log để đảm bảo durability BACKUP LOG YourDatabase TO DISK =
                'C:\Backup\YourDatabase_Log.trn';
              </div>

              <div class="success-box">
                <h5>✅ Durability đảm bảo:</h5>
                <ul>
                  <li>Committed transactions survive system failures</li>
                  <li>Data được lưu trữ persistent storage (disk)</li>
                  <li>Recovery mechanisms có thể restore committed state</li>
                  <li>No data loss cho completed transactions</li>
                </ul>
              </div>
            </div>

            <h3>🏗️ ACID trong thực tế</h3>

            <h4>💳 Ví dụ tổng hợp: Hệ thống thanh toán</h4>
            <div class="example">
              <div class="code-block">
                -- Stored Procedure minh họa đầy đủ ACID properties CREATE
                PROCEDURE sp_process_payment @customer_id INT, @order_id INT,
                @payment_amount DECIMAL(15,2), @payment_method VARCHAR(50) AS
                BEGIN SET NOCOUNT ON; -- ISOLATION: Set appropriate isolation
                level SET TRANSACTION ISOLATION LEVEL SERIALIZABLE; BEGIN TRY --
                ATOMICITY: Begin transaction BEGIN TRANSACTION; DECLARE
                @customer_balance DECIMAL(15,2); DECLARE @order_total
                DECIMAL(15,2); -- CONSISTENCY: Validate business rules SELECT
                @customer_balance = account_balance FROM customers WHERE
                customer_id = @customer_id; SELECT @order_total = total_amount
                FROM orders WHERE order_id = @order_id AND status = 'pending';
                -- Check constraints (CONSISTENCY) IF @customer_balance IS NULL
                BEGIN RAISERROR('Customer không tồn tại', 16, 1); RETURN; END;
                IF @order_total IS NULL BEGIN RAISERROR('Order không hợp lệ hoặc
                đã được xử lý', 16, 1); RETURN; END; IF @payment_amount !=
                @order_total BEGIN RAISERROR('Số tiền thanh toán không khớp với
                tổng đơn hàng', 16, 1); RETURN; END; IF @customer_balance <
                @payment_amount BEGIN RAISERROR('Số dư không đủ', 16, 1);
                RETURN; END; -- ATOMICITY: All operations must succeed together
                -- Trừ tiền từ tài khoản khách hàng UPDATE customers SET
                account_balance = account_balance - @payment_amount,
                updated_date = GETDATE() WHERE customer_id = @customer_id; --
                Cập nhật trạng thái đơn hàng UPDATE orders SET status = 'paid',
                payment_date = GETDATE(), payment_method = @payment_method,
                updated_date = GETDATE() WHERE order_id = @order_id; -- Ghi log
                giao dịch INSERT INTO payment_log ( customer_id, order_id,
                amount, payment_method, payment_time, status ) VALUES (
                @customer_id, @order_id, @payment_amount, @payment_method,
                GETDATE(), 'completed' ); -- Cập nhật inventory UPDATE products
                SET stock_quantity = stock_quantity - oi.quantity, updated_date
                = GETDATE() FROM products p INNER JOIN order_items oi ON
                p.product_id = oi.product_id WHERE oi.order_id = @order_id; --
                ATOMICITY & DURABILITY: Commit all changes COMMIT TRANSACTION;
                PRINT 'Payment processed successfully'; PRINT 'Order ID: ' +
                CAST(@order_id AS VARCHAR); PRINT 'Amount: ' +
                FORMAT(@payment_amount, 'N0') + ' VND'; END TRY BEGIN CATCH --
                ATOMICITY: Rollback on any error IF @@TRANCOUNT > 0 ROLLBACK
                TRANSACTION; -- Log error (separate transaction for DURABILITY)
                DECLARE @error_msg VARCHAR(2000) = ERROR_MESSAGE(); BEGIN TRY
                INSERT INTO error_log ( procedure_name, error_message,
                error_time, parameters ) VALUES ( 'sp_process_payment',
                @error_msg, GETDATE(), 'customer_id=' + CAST(@customer_id AS
                VARCHAR) + ', order_id=' + CAST(@order_id AS VARCHAR) + ',
                amount=' + CAST(@payment_amount AS VARCHAR) ); END TRY BEGIN
                CATCH -- If logging fails, at least print the error PRINT 'Error
                logging failed: ' + ERROR_MESSAGE(); END CATCH; -- Re-throw the
                original error THROW; END CATCH; END; -- Test procedure EXEC
                sp_process_payment @customer_id = 1, @order_id = 100,
                @payment_amount = 2500000, @payment_method = 'credit_card';
              </div>
            </div>

            <h3>🔍 Kiểm tra ACID Compliance</h3>
            <div class="example">
              <h4>Tools và queries để verify ACID properties:</h4>
              <div class="code-block">
                -- 1. Kiểm tra Transaction isolation SELECT session_id,
                transaction_isolation_level, CASE transaction_isolation_level
                WHEN 0 THEN 'Unspecified' WHEN 1 THEN 'ReadUncommitted' WHEN 2
                THEN 'ReadCommitted' WHEN 3 THEN 'RepeatableRead' WHEN 4 THEN
                'Serializable' WHEN 5 THEN 'Snapshot' END AS
                isolation_level_name FROM sys.dm_exec_sessions WHERE
                is_user_process = 1; -- 2. Kiểm tra active transactions SELECT
                s.session_id, t.name AS transaction_name,
                t.transaction_begin_time, t.transaction_type,
                t.transaction_state, CASE t.transaction_state WHEN 0 THEN
                'Uninitialized' WHEN 1 THEN 'Not started' WHEN 2 THEN 'Active'
                WHEN 3 THEN 'Ended (read-only)' WHEN 4 THEN 'Commit initiated'
                WHEN 5 THEN 'Prepared' WHEN 6 THEN 'Committed' WHEN 7 THEN
                'Rolling back' WHEN 8 THEN 'Rolled back' END AS
                transaction_state_desc FROM sys.dm_tran_session_transactions s
                INNER JOIN sys.dm_tran_active_transactions t ON s.transaction_id
                = t.transaction_id; -- 3. Kiểm tra locks (Isolation) SELECT
                resource_type, resource_database_id,
                resource_associated_entity_id, resource_lock_partition,
                request_mode, request_type, request_status, request_session_id
                FROM sys.dm_tran_locks WHERE resource_database_id = DB_ID(); --
                4. Kiểm tra log space usage (Durability) DBCC LOGINFO; -- 5.
                Check constraint violations (Consistency) -- Tìm foreign key
                violations SELECT fk.name AS foreign_key_name, tp.name AS
                parent_table, tr.name AS referenced_table FROM sys.foreign_keys
                fk INNER JOIN sys.tables tp ON fk.parent_object_id =
                tp.object_id INNER JOIN sys.tables tr ON fk.referenced_object_id
                = tr.object_id;
              </div>
            </div>

            <h3>⚡ ACID Performance Trade-offs</h3>
            <div class="info-box">
              <h4>⚖️ Cân bằng giữa ACID và Performance:</h4>
              <table>
                <thead>
                  <tr>
                    <th>ACID Property</th>
                    <th>Performance Impact</th>
                    <th>Optimization Strategies</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><b>Atomicity</b></td>
                    <td>Transaction overhead, log writes</td>
                    <td>Batch operations, minimize transaction scope</td>
                  </tr>
                  <tr>
                    <td><b>Consistency</b></td>
                    <td>Constraint checking, trigger execution</td>
                    <td>Efficient indexes, optimized constraints</td>
                  </tr>
                  <tr>
                    <td><b>Isolation</b></td>
                    <td>Locking, blocking, deadlocks</td>
                    <td>Lower isolation levels, read committed snapshot</td>
                  </tr>
                  <tr>
                    <td><b>Durability</b></td>
                    <td>Disk I/O, log flushes</td>
                    <td>Fast storage, delayed durability (carefully)</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <div class="success-box">
              <h4>💡 Best Practices cho ACID:</h4>
              <ul>
                <li><b>Keep transactions short:</b> Minimize lock time</li>
                <li>
                  <b>Use appropriate isolation levels:</b> Balance consistency
                  vs performance
                </li>
                <li>
                  <b>Design efficient constraints:</b> Fast validation rules
                </li>
                <li><b>Monitor transaction log:</b> Ensure adequate space</li>
                <li><b>Regular backups:</b> Protect durability</li>
                <li>
                  <b>Test failure scenarios:</b> Verify recovery procedures
                </li>
              </ul>
            </div>

            <div class="highlight-box">
              <h4>🎯 Kết luận:</h4>
              <p>
                <b>ACID Properties</b> là nền tảng của
                <b>database reliability và data integrity</b>:
              </p>
              <ul>
                <li><b>Atomicity:</b> All-or-nothing transactions</li>
                <li><b>Consistency:</b> Valid data states và business rules</li>
                <li><b>Isolation:</b> Concurrent transaction separation</li>
                <li>
                  <b>Durability:</b> Permanent storage của committed changes
                </li>
              </ul>
              <p>
                Hiểu và áp dụng đúng ACID giúp xây dựng
                <b>hệ thống database đáng tin cậy</b> cho các ứng dụng critical.
              </p>
            </div>
          </section>

          <!-- VIDEO -->
          <section class="section" id="video-tricks">
            <h2>🎬 Mẹo & Video</h2>
            <p><em>Đang cập nhật…</em></p>
          </section>
        </main>
      </div>
    </div>

    <button class="back-to-top" id="backTop" aria-label="Lên đầu trang">
      ↑
    </button>

    <script>
      // Tabs
      const tabButtons = document.querySelectorAll(".tab-btn");
      const tabContents = document.querySelectorAll(".tab-content");
      tabButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
          tabButtons.forEach((b) => b.classList.remove("active"));
          tabContents.forEach((c) => c.classList.remove("active"));
          btn.classList.add("active");
          document.getElementById(btn.dataset.tab).classList.add("active");
        });
      });

      // TOC click -> show section
      const sections = document.querySelectorAll(".section");
      function showSection(id) {
        sections.forEach((s) => s.classList.remove("active"));
        const el = document.getElementById(id);
        if (el) {
          el.classList.add("active");
          document
            .querySelector(".content-area")
            .scrollTo({ top: 0, behavior: "smooth" });
        }
        document
          .querySelectorAll(".toc-item")
          .forEach((i) => i.classList.remove("active"));
        const item = document.querySelector(`.toc-item[data-target="${id}"]`);
        if (item) item.classList.add("active");
      }
      document.querySelectorAll(".toc-item").forEach((item) => {
        item.addEventListener("click", () => showSection(item.dataset.target));
      });

      // Search filter for TOC
      const searchBox = document.getElementById("searchBox");
      searchBox.addEventListener("input", (e) => {
        const q = e.target.value.toLowerCase();
        document.querySelectorAll(".toc-item").forEach((item) => {
          item.style.display = item.textContent.toLowerCase().includes(q)
            ? ""
            : "none";
        });
      });

      // Back to top
      const backBtn = document.getElementById("backTop");
      window.addEventListener("scroll", () => {
        backBtn.style.display = window.scrollY > 200 ? "block" : "none";
      });
      backBtn.addEventListener("click", () =>
        window.scrollTo({ top: 0, behavior: "smooth" })
      );
    </script>
  </body>
</html>
